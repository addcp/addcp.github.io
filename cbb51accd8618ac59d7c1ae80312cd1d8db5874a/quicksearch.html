<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"add-tools-browser-api_src_services_BA2933307.service.js.html":{"id":"add-tools-browser-api_src_services_BA2933307.service.js.html","title":"Source: add-tools-browser-api/src/services/BA2933307.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-browser-api/src/services/BA2933307.service.js \"use strict\"; const { chromium } = require('playwright'); const fs = require('fs'); /** * @namespace {object} add-tools-browser-api */ /** * O Serviço BA2933307 automatiza o navegador para baixar documentos do Rio de Janeiro&lt;/br&gt; * @namespace add-tools-browser-api.BA2933307 * @property {string} name - Nome do serviço, que obtém o nome do arquivo atual sem a extensão * @property {object} settings - Configurações internas do serviço * @property {string} settings.IDAPP - ID do APP que pode ser usado em permissões para chamar este serviço */ module.exports = { name: __filename.split('.')[0].split('/').pop(), settings: { IDAPP: `${/\\add-\\w*-\\w*-api(?!.*\\add-\\w*-\\w*-api)/.exec(__dirname)}`, }, /** * @summary Actions do serviço * @property {object} getDocuments - Baixa documentos do Rio de Janeiro {@link add-tools-browser-api.BA2933307#getDocuments action getDocuments} * @memberof add-tools-browser-api.BA2933307# */ actions: { /** * A ação getDocuments automatiza a tarefa de navegar até um site, fazer login, navegar até uma página específica, inserir algumas informações e baixar um documento. &lt;/br&gt; * @summary Action getDocuments * @action getDocuments * @memberof add-tools-browser-api.BA2933307# * @property {string} description - Descrição breve da ação usada em listas automáticas * @property {object} params - Parâmetros da ação * @property {string} params.REQ_XML - string contendo xml com os dados para baixar documentos do Rio de Janeiro * @property {string} params.secretAlias - é o alias do secret que contém o usuário e senha para acessar o site do Rio de Janeiro * @property {boolean} cache - Cache da ação * @returns {string} Retorna uma string como o conteúdo do arquivo envolvido com a tag &lt;strong&gt;ListNFSe&lt;/strong&gt; * @example * &lt;caption&gt;Chamada da ação getDocuments&lt;/caption&gt; * const result = await ctx.call(\"BA2933307.getDocuments\", { * REQ_XML: \"&lt;xml&gt;Seu XML aqui&lt;/xml&gt;\", * secretAlias: \"aliasDoSeuSecret\" * }); * console.log(result); // Exibe o conteúdo do arquivo baixado */ getDocuments: { description: \"Baixa documentos do rio de janeiro\", params: { REQ_XML: { type: \"string\" }, secretAlias: { type: \"string\" }, }, cache: false, async handler(ctx) { debugger /** * * * Esse serviço pode ser invocado para baixar notas fiscais de Rio de Janeiro * * */ const browser = await chromium.launch(); const context = await browser.newContext({ acceptDownloads: true }); const page = await context.newPage(); let [year, month, day] = ctx.params.REQ_XML.match(/(?&lt;=DTINI&gt;)(.*?)(?=&lt;\\/DTINI&gt;)/s)[0].split('-'); const DTINI = `${day}${month}${year}`; [year, month, day] = ctx.params.REQ_XML.match(/(?&lt;=DTFIM&gt;)(.*?)(?=&lt;\\/DTFIM&gt;)/s)[0].split('-'); const DTFIM = `${day}${month}${year}`; const CNPJ = ctx.params.REQ_XML.match(/(?&lt;=CNPJ&gt;)(.*?)(?=&lt;\\/CNPJ&gt;)/s)[0]; const vault = await ctx.call(\"vault.retrieveSecret\", { secretType: \"\", secretAlias: ctx.params.secretAlias, addDecrypt: \"X\" }); await page.goto('https://ba-vitoriadaconquista-pm-nfs.cloud.el.com.br'); await page.waitForLoadState(); await new Promise(resolve =&gt; setTimeout(resolve, 5000)); const inputUsuario = await page.$('#usuario'); console.log(\"INSERINDO LOGIN\"); await inputUsuario.type(vault.data.userAccount, { delay: 100 }); const inputSenha = await page.$('#senha'); await inputSenha.type(vault.data.userPassword, { delay: 100 }); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); await page.click(\"xpath=/html/body/div/main/div/div/div/div[1]/form/div[4]/span/button\"); await page.waitForLoadState(); await new Promise(resolve =&gt; setTimeout(resolve, 5000)); await page.click(\"xpath=/html/body/div/header/nav/div/ul/li[2]/a\"); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); await page.click(\"xpath=/html/body/div/header/nav/div/ul/li[2]/div/a[2]\"); await page.waitForLoadState(); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); await page.click(\"xpath=/html/body/div/main/div/div/div/div/div[2]/div[2]/div[1]/span/div/span\"); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); await page.click(\"xpath=/html/body/div/main/div/div/div/div/div[2]/div[2]/div[1]/span/div/div[3]/div/ul/li[4]\"); console.log(\"SELECIONANDO NOTAS FISCAIS TOMADAS\"); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); const inputDataIni = await page.$('#dataIni'); console.log(\"INSERINDO DATA INICIO\"); await inputDataIni.type(DTINI, { delay: 100 }); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); const inputDataFim = await page.$('#dataFim'); console.log(\"INSERINDO DATA FIM\"); await inputDataFim.type(DTFIM, { delay: 100 }); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); const inputTomador = await page.$('#filtro'); await inputTomador.type(CNPJ, { delay: 100 }); console.log(\"INSERINDO CNPJ DO TOMADOR\"); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); await page.click(\"xpath=/html/body/div/main/div/div/div/div/div[2]/div[2]/div[6]/span/div/span\"); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); await page.click(\"xpath=/html/body/div/main/div/div/div/div/div[2]/div[2]/div[6]/span/div/div[3]/div/ul/li[1]\"); console.log(\"SELECIONANDO STATUS DA NOTA\"); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); const [download] = await Promise.all([ page.waitForEvent('download'), // Aguardar o início do download await page.click(\"xpath=/html/body/div/main/div/div/div/div/div[2]/div[3]/button[3]/span[2]\") ]); console.log(\"EFETUANDO DOWNLOAD XML\"); const downloadedFilePath = await download.path(); const fileContent = fs.readFileSync(downloadedFilePath, 'utf-8'); fs.unlinkSync(downloadedFilePath); // Feche o pop-up await page.close(); await browser.close(); return `&lt;ListNFSe&gt;${fileContent}&lt;/ListNFSe&gt;`; } }, }, methods: {}, }; × Search results Close "},"add-tools-browser-api_src_services_BROWSER.service.js.html":{"id":"add-tools-browser-api_src_services_BROWSER.service.js.html","title":"Source: add-tools-browser-api/src/services/BROWSER.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-browser-api/src/services/BROWSER.service.js const puppeteer = require(\"puppeteer\"); const fs = require(\"fs\"); const { chromium, firefox, webkit } = require(\"playwright\"); const { XMLParser, XMLBuilder, XMLValidator } = require(\"fast-xml-parser\"); const bwipjs = require(\"bwip-js\"); // Importe a biblioteca bwip-js const qr = require(\"qrcode\"); // Importe a biblioteca qrcode const zlib = require(\"zlib\"); /** * @desc O Serviço BROWSER é responsável por automatizar a navegação em um site via navegador&lt;/br&gt; * @namespace add-tools-browser-api.BROWSER * @property {string} name - Nome do serviço * @property {array} mixins - Usado para distribuir funcionalidades reutilizáveis para os serviços * @property {object} metadata - Usado para armazenar qualquer metadados do serviço * @property {string} metadata.$description - Descrição breve do serviço usada em listas automáticas * @property {object} settings - Configurações internas do serviço * @property {string} settings.IDAPP - ID do APP que pode ser usado em permissões * @todo @property {boolean} settings.rest - Se estiver marcado, o serviço será acessível via REST */ module.exports = { name: \"BROWSER\", mixins: [], metadata: { $description: \"Browser Automation\" }, settings: { IDAPP: `${/\\add-\\w*-\\w*-api(?!.*\\add-\\w*-\\w*-api)/.exec(__dirname)}`, rest: true, }, /** * @summary Actions do serviço * @property {object} viewDacte - Gera a visualização DACTE {@link add-tools-browser-api.BROWSER#viewDacte action viewDacte} * @property {object} download - Efetua download de arquivos {@link add-tools-browser-api.BROWSER#download action download} * @property {object} urlToPdf - Converte uma página web em PDF {@link add-tools-browser-api.BROWSER#urlToPdf action urlToPdf} * @memberof add-tools-browser-api.BROWSER# */ actions: { /** * Gera a visualização DACTE * A action viewDacte é responsável por gerar a visualização do Dacte. &lt;/br&gt; * Esta função está no container Browser devido ao grande tamanho do contêiner 2000 * @summary Ação viewDacte * @action viewDacte * @memberof add-tools-browser-api.BROWSER# * @property {string} rest - Rota da ação: \"POST /\" * @property {string} description - Descrição breve da ação usada em listas automáticas * @property {object} params - Parâmetros da ação * @property {Object} params.doc - documento XML * @returns {string} pdfBase64String - Arquivo PDF em base64 */ viewDacte: { rest: \"POST /\", description: \"Dacte\", params: { doc: { type: \"object\" }, }, async handler(ctx) { debugger; const document = await ctx.call(\"TAXD0002.find\", { query: { TYPE: \".XML\", D0000: ctx.params.doc.id, }, }); let xml = await ctx.call(\"TAXDATCHB.find\", { query: { id: document[0].FILNR, }, }); xml = zlib .gunzipSync(new Buffer.from(xml[0].FILBIN, \"base64\")) .toString(\"utf-8\"); const browser = await chromium.launch(); const page = await browser.newPage(); // var xml = fs.readFileSync('./doc.xml', 'utf8'); xml = xml.replace( /&lt;chave&gt;(\\d+)&lt;\\/chave&gt;/g, '&lt;chave&gt;\"$1\"&lt;/chave&gt;', ); xml = xml.replace( /&lt;chCTe&gt;(\\d+)&lt;\\/chCTe&gt;/g, '&lt;chCTe&gt;\"$1\"&lt;/chCTe&gt;', ); const options = { parseNodeValue: false, }; const parser = new XMLParser(options); const jObj = parser.parse(xml); const { emit } = jObj.cteProc.CTe.infCte; const { vPrest } = jObj.cteProc.CTe.infCte; const { rem } = jObj.cteProc.CTe.infCte; const { exped } = jObj.cteProc.CTe.infCte; const recev = jObj.cteProc.CTe.infCte.receb; const { dest } = jObj.cteProc.CTe.infCte; const { ide } = jObj.cteProc.CTe.infCte; const protCTe = jObj.cteProc.CTe.infCte.infCTeNorm; const { imp } = jObj.cteProc.CTe.infCte; const obs = jObj.cteProc.CTe.infCte.compl; const infProt = jObj.cteProc.protCTe; const barcodeData = infProt.infProt.chCTe .replace('\"', \"\") .slice(0, -1); const qrData = infProt.infProt.chCTe .replace('\"', \"\") .slice(0, -1); // let qrData = protCTe.infDoc.infNFe.chave.replace('\"', \"\").slice(0, -1) || ''; let barcodeOptions = { bcid: \"code128\", text: barcodeData, scale: 2, height: 10, }; const base64Image = await new Promise((resolve, reject) =&gt; { bwipjs.toBuffer(barcodeOptions, (err, pngBuffer) =&gt; { if (err) { reject(err); } else { const base64String = pngBuffer.toString(\"base64\"); resolve(base64String); } }); }); barcodeOptions = { bcid: \"qrcode\", // Formato QR code text: qrData, scale: 3, }; const base64QRCode = await new Promise((resolve, reject) =&gt; { bwipjs.toBuffer(barcodeOptions, (err, pngBuffer) =&gt; { if (err) { reject(err); } else { const base64String = pngBuffer.toString(\"base64\"); resolve(base64String); } }); }); let htmlContent = ` &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"card\"&gt; &lt;div class=\"hljs-container\"&gt; &lt;br&gt; &lt;style&gt; body { font-size: 8px; } table, th, td { font-size: 8px; border-radius: 20px; border-collapse: collapse; } th, td { padding: 5px; text-align: left; border-radius: 20px; } &lt;/style&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=\"top\" colspan=\"4\"&gt; &lt;center&gt;DECLARO QUE RECEBI OS VOLUMES DESTE CONHECIMENTO EM PERFEITO ESTADO PELO QUE DOU POR CUMPRIDO O PRESENTE CONTRATO DE TRANSPORTE&lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\" width=\"30%\"&gt;NOME&lt;/td&gt; &lt;td valign=\"top\" rowspan=\"3\"&gt;ASSINATURA / CARIMBO&lt;/td&gt; &lt;td valign=\"top\" rowspan=\"2\"&gt;TÉRMINO DA PRESTAÇÃO - DATA/HORA&lt;br&gt;&lt;br&gt;&lt;br&gt;INÍCIO DA PRESTAÇÃO - DATA/HORA&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/td&gt; &lt;td valign=\"top\" rowspan=\"2\"&gt; &lt;center&gt;&lt;br&gt;&lt;b&gt;CT-E&lt;/b&gt;&lt;br&gt;&lt;br&gt; &lt;font style=\"font-size: 14px\" face=\"Times New Roman\"&gt;Nº 161702&lt;br&gt;Série 2&lt;/font&gt; &lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt;RG&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;hr&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=\"top\" colspan=\"2\" rowspan=\"3\"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;center&gt; &lt;font style=\"font-size: 14px\" face=\"Times New Roman\"&gt;&lt;b&gt;${ emit?.xNome }&lt;/b&gt;&lt;/font&gt;&lt;br&gt;${ emit?.enderEmit?.xLgr },${emit?.enderEmit?.nro}&lt;br&gt;${ emit?.enderEmit?.xBairro } - ${ emit?.enderEmit?.cMun } - ${ emit?.enderEmit?.xMun } - ${ emit?.enderEmit?.UF }&lt;br&gt;Fone/Fax: &lt;/center&gt; &lt;/td&gt; &lt;td valign=\"top\" colspan=\"6\"&gt; &lt;center&gt; &lt;font style=\"font-size: 14px\" face=\"Times New Roman\"&gt;&lt;b&gt;DACTE&lt;/b&gt;&lt;/font&gt;&lt;br&gt;Documento Auxiliar do Conhecimento de Transporte Eletrônico &lt;/center&gt; &lt;/td&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;MODAL&lt;br&gt; &lt;font style=\"font-size: 14px\" face=\"Times New Roman\"&gt;&lt;b&gt;Rodoviário&lt;/b&gt;&lt;/font&gt; &lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;MODELO&lt;br&gt;&lt;b&gt;${ide?.mod} &lt;/b&gt;&lt;/center&gt; &lt;/td&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;SÉRIE&lt;br&gt;&lt;b&gt;${ide?.serie}&lt;/b&gt;&lt;/center&gt; &lt;/td&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;NÚMERO&lt;br&gt;&lt;b&gt;${ide?.nCT}&lt;/b&gt;&lt;/center&gt; &lt;/td&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;FL&lt;br&gt;&lt;/center&gt; &lt;/td&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;DATA E HORA DE EMISSÃO&lt;br&gt;&lt;b&gt;${ide?.dhEmi}&lt;/b&gt;&lt;/center&gt; &lt;/td&gt; &lt;td valign=\"top\"&gt; &lt;center&gt; SC.SUF.DO DEST&lt;br&gt;&lt;/center&gt; &lt;/td&gt; &lt;td valign=\"top\" rowspan=\"5\"&gt;&lt;img width=\"100px\" src=\"data:image/png;base64,${base64QRCode}\" alt=\"50170339115514000390570020001617021930128243\" style=\"border: solid 1px black;\"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\" colspan=\"6\"&gt; &lt;center&gt;&lt;img alt=\"50170339115514000390570020001617021930128243\" width=\"300px\" height=\"40px\" src=\"data:image/png;base64,${base64Image}\"&gt; &lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;TIPO DO CTE&lt;br&gt;&lt;b&gt;Normal&lt;/b&gt;&lt;/center&gt; &lt;/td&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;TIPO DO SERVIÇO&lt;br&gt;&lt;b&gt;Normal&lt;/b&gt;&lt;/center&gt; &lt;/td&gt; &lt;td valign=\"top\" colspan=\"6\"&gt; &lt;center&gt;CHAVE DE ACESSO&lt;br&gt;&lt;b&gt;${infProt?.infProt?.chCTe ?.replace('\"', \"\") .slice(0, -1)}&lt;/b&gt;&lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;IND.DO CT-E GLOBALIZADO&lt;br&gt;&lt;b&gt;&lt;/b&gt;&lt;/center&gt; &lt;/td&gt; &lt;td valign=\"top\"&gt;INF.DO CT-E GLOBALIZADO&lt;br&gt;&lt;/td&gt; &lt;td valign=\"top\" colspan=\"6\"&gt; &lt;center&gt;Consulta em http://www.cte.fazenda.gov.br/portal&lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\" colspan=\"2\"&gt;CFOP - NATUREZA DA PRESTAÇÃO&lt;br&gt;&lt;b&gt;${ide?.CFOP} - ${ide?.natOp}&lt;/b&gt;&lt;/td&gt; &lt;td valign=\"top\" colspan=\"6\"&gt; &lt;center&gt;PROTOCOLO DE AUTORIZAÇÃO DE USO&lt;br&gt;&lt;b&gt;${infProt?.infProt?.nProt} - ${ infProt?.infProt?.dhRecbto }&lt;/b&gt; &lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt;INÍCIO DA PRESTAÇÃO&lt;br&gt;&lt;b&gt;${ide?.xMunIni} - ${ ide?.UFIni }&lt;/b&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;TÉRMINO DA PRESTAÇÃO&lt;br&gt;&lt;b&gt;${ide?.xMunFim} - ${ ide?.UFFim }&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt; REMETENTE: &lt;b&gt;${rem?.xNome} &lt;/b&gt;&lt;br&gt; ENDEREÇO: &lt;b&gt;${rem?.enderReme?.xLgr}, ${rem?.enderReme?.nro}, ${ rem?.enderReme?.xBairro }&lt;/b&gt;&lt;br&gt; MUNICÍPIO: &lt;b&gt;${rem?.enderReme?.xMun} - ${rem?.enderReme?.UF}&lt;/b&gt; CEP: &lt;b&gt;${ rem?.enderReme?.CEP }&lt;/b&gt;&lt;br&gt; CNPJ/CPF: &lt;b&gt;${rem?.CNPJ}&lt;/b&gt; INSCRIÇÃO ESTADUAL: &lt;b&gt;${rem?.IE}&lt;/b&gt;&lt;br&gt; PAÍS: &lt;b&gt;${rem?.enderReme?.xPais}&lt;/b&gt; FONE: &lt;b&gt;${rem?.fone}&lt;/b&gt;&lt;br&gt; &lt;/td&gt; &lt;td valign=\"top\"&gt; DESTINATÁRIO: &lt;b&gt;${dest?.xNome}&lt;/b&gt;&lt;br&gt; ENDEREÇO: &lt;b&gt;${dest?.enderDest?.xLgr}, ${dest?.enderDest?.nro}, ${ dest?.enderDest?.xBairro }&lt;/b&gt;&lt;br&gt; MUNICÍPIO: &lt;b&gt;${dest?.enderDest?.xMun} - ${dest?.enderDest?.UF}&lt;/b&gt; CEP: &lt;b&gt;${ dest?.enderDest?.CEP }&lt;/b&gt;&lt;br&gt; CNPJ/CPF: &lt;b&gt;${dest?.CNPJ}&lt;/b&gt; INSCRIÇÃO ESTADUAL: &lt;b&gt;${dest?.IE}&lt;/b&gt;&lt;br&gt; PAÍS: &lt;b&gt;${dest?.enderDest?.xPais}&lt;/b&gt; FONE: &lt;b&gt;${dest?.fone}&lt;/b&gt;&lt;br&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt; EXPEDIDOR: &lt;b&gt;${exped?.xNome}&lt;/b&gt;&lt;br&gt; ENDEREÇO: &lt;b&gt;${exped?.enderExped?.xLgr}, ${exped?.enderExped?.nro}, ${ exped?.enderExped?.xBairro }&lt;/b&gt;&lt;br&gt; MUNICÍPIO: &lt;b&gt;${exped?.enderExped?.xMun} - ${ exped?.enderExped?.UF }&lt;/b&gt; CEP: &lt;b&gt;${ exped?.enderExped?.CEP }&lt;/b&gt;&lt;br&gt; CNPJ/CPF: &lt;b&gt;${exped?.CNPJ}&lt;/b&gt; INSCRIÇÃO ESTADUAL: &lt;b&gt;${exped?.IE}&lt;/b&gt;&lt;br&gt; PAÍS: &lt;b&gt;${exped?.enderExped?.xPais}&lt;/b&gt; FONE: &lt;b&gt;${exped?.fone}&lt;/b&gt;&lt;br&gt; &lt;/td&gt; &lt;td valign=\"top\"&gt; RECEBEDOR: &lt;b&gt;${recev?.xNome}&lt;/b&gt;&lt;br&gt; ENDEREÇO: &lt;b&gt;${recev?.enderReceb?.xLgr}, ${recev?.enderReceb?.nro}, ${ recev?.enderReceb?.xBairro }&lt;/b&gt;&lt;br&gt; MUNICÍPIO: &lt;b&gt;${recev?.enderReceb?.xMun} - ${ recev?.enderReceb?.UF }&lt;/b&gt; CEP: &lt;b&gt;${ recev?.enderReceb?.CEP }&lt;/b&gt;&lt;br&gt; CNPJ/CPF: &lt;b&gt;${recev?.CNPJ}&lt;/b&gt; INSCRIÇÃO ESTADUAL: &lt;b&gt;${recev?.IE}&lt;/b&gt;&lt;br&gt; PAÍS: &lt;b&gt;${recev?.enderReceb?.xPais}&lt;/b&gt; FONE: &lt;b&gt;${recev?.fone}&lt;/b&gt;&lt;br&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=\"top\" colspan=\"5\"&gt; TOMADOR DO SERVIÇO &lt;b&gt;${dest?.xNome}&lt;/b&gt; MUNICÍPIO &lt;b&gt;${ dest?.enderDest?.xMun }&lt;/b&gt; UF &lt;b&gt;${dest?.enderDest?.UF}&lt;/b&gt; CEP &lt;b&gt;${dest?.enderDest?.CEP}&lt;/b&gt;&lt;br&gt; ENDEREÇO &lt;b&gt;${dest?.enderDest?.xLgr}, ${dest?.enderDest?.nro},${ dest?.enderDest?.xBairro }&lt;/b&gt;&lt;br&gt; CNPJ/CPF &lt;b&gt;${dest?.CNPJ}&lt;/b&gt; INSCRIÇÃO ESTADUAL &lt;b&gt;${dest?.IE}&lt;/b&gt; PAÍS &lt;b&gt;${ dest?.enderDest?.xPais }&lt;/b&gt; FONE &lt;b&gt;${dest?.fone}&lt;/b&gt;&lt;br&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\" colspan=\"3\"&gt;PRODUTO PREDOMINANTE&lt;br&gt;&lt;b&gt;${ protCTe?.infCarga?.proPred }&lt;/b&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;OUTRAS CARACTERÍSTICAS DA CARGA&lt;br&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;VALOR TOTAL DA CARGA&lt;br&gt;&lt;b&gt;${ protCTe?.infCarga?.vCarga ? protCTe?.infCarga?.vCarga.toLocaleString( \"pt-BR\", { style: \"currency\", currency: \"BRL\", }, ) : \"\" }&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt;TP MED /UN. MED&lt;br&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;TP MED /UN. MED&lt;br&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;TP MED /UN. MED&lt;br&gt;&lt;b&gt;PESO BRUTO&lt;br&gt;${ protCTe?.infCarga?.infQ[0]?.qCarga }&lt;/b&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;TP MED /UN. MED&lt;br&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;TP MED /UN. MED&lt;br&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=\"top\" colspan=\"4\"&gt; &lt;center&gt;COMPONENTES DO VALOR DA PRESTAÇÃO DO SERVIÇO&lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\" rowspan=\"2\" width=\"25%\"&gt;NOME | VALOR&lt;br&gt;Tarifa | ${ vPrest?.Comp?.vComp }&lt;br&gt;AdValorem | ${ vPrest?.Comp?.vComp }&lt;br&gt; &lt;/td&gt; &lt;td valign=\"top\" rowspan=\"2\" width=\"25%\"&gt;NOME | VALOR&lt;br&gt;&lt;/td&gt; &lt;td valign=\"top\" rowspan=\"2\" width=\"25%\"&gt;NOME | VALOR&lt;br&gt;&lt;/td&gt; &lt;td valign=\"top\" width=\"25%\"&gt;VALOR TOTAL DO SERVIÇO&lt;br&gt;&lt;b&gt;${ vPrest?.vTPrest ? vPrest?.vTPrest.toLocaleString( \"pt-BR\", { style: \"currency\", currency: \"BRL\", }, ) : \"\" }&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt;VALOR A RECEBER&lt;br&gt;&lt;b&gt;${ vPrest?.vRec ? vPrest?.vRec.toLocaleString( \"pt-BR\", { style: \"currency\", currency: \"BRL\", }, ) : \"\" }&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=\"top\" colspan=\"6\"&gt; &lt;center&gt;INFORMAÇÕES RELATIVAS AO IMPOSTO&lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt;SITUAÇÃO TRIBUTÁRIA&lt;br&gt;&lt;b&gt;60&lt;/b&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;BASE DE CALCULO&lt;br&gt;&lt;b&gt;${ imp?.ICMS?.ICMS00?.vBC ? imp?.ICMS?.ICMS00?.vBC.toLocaleString( \"pt-BR\", { style: \"currency\", currency: \"BRL\", }, ) : \"\" }&lt;/b&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;ALÍQ ICMS&lt;br&gt;&lt;b&gt;${imp?.ICMS?.ICMS00?.pICMS}&lt;/b&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;VALOR ICMS&lt;br&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;% RED. BC ICMS&lt;br&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;VALOR ICMS ST&lt;br&gt;&lt;b&gt;${ imp?.ICMS?.ICMS00?.vICMS ? imp?.ICMS?.ICMS00?.vICMS.toLocaleString( \"pt-BR\", { style: \"currency\", currency: \"BRL\", }, ) : \"\" }&lt;/b&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;DOCUMENTOS ORIGINÁRIOS&lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt;TIPO DOC - CNPJ/CHAVE/OBS - SÉRIE/NRO. DOCUMENTO&lt;br&gt;&lt;br&gt; NF-e - ${ infProt?.infProt?.chCTe ? infProt?.infProt?.chCTe .replace('\"', \"\") .slice(0, -1) : \"\" } - ${ infProt?.infProt?.chCTe ? infProt?.infProt?.chCTe .replace('\"', \"\") .slice(0, -1) .substr(22, 3) : \"\" } /${ infProt?.infProt?.chCTe ? infProt?.infProt?.chCTe .replace('\"', \"\") .slice(0, -1) .substr(25, 9) : \"\" } | &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;OBSERVAÇÕES GERAIS&lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt;${obs?.xObs}&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=\"top\" colspan=\"2\"&gt; &lt;center&gt;DADOS ESPECÍFICOS DO MODAL RODOVIÁRIO&lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt;RNTRC DA EMPRESA&lt;br&gt;&lt;b&gt;&lt;/b&gt;&lt;/td&gt; &lt;td valign=\"top\"&gt;ESTE CONHECIMENTO DE TRANSPORTE ATENDE À LEGISLAÇÃO DE TRANSPORTE RODOVIÁRIO EM VIGOR&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;table border=\"1\" width=\"100%\"&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;USO EXCLUSIVO DO EMISSOR DO CT-E&lt;/center&gt; &lt;/td&gt; &lt;td valign=\"top\"&gt; &lt;center&gt;RESERVADO AO FISCO&lt;/center&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td valign=\"top\"&gt;${obs?.xObs}&lt;/td&gt; &lt;td valign=\"top\" width=\"30%\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; `; htmlContent = htmlContent.replace(/undefined/g, \" \"); await page.goto(\"about:blank\"); await page.setContent(htmlContent); const pdfBuffer = await page.pdf({ format: \"A4\" }); const pdfBase64String = pdfBuffer.toString(\"base64\"); await browser.close(); return pdfBase64String; }, }, /** * Efetua download de arquivos * @summary Ação download * @action download * @memberof add-tools-browser-api.BROWSER# * @property {string} rest - Rota da ação: \"POST /\" * @property {string} description - Descrição breve da ação usada em listas automáticas * @property {function} permissions - Permissões da action * @property {object} params - Parâmetros da ação * @todo @property {string} params.url - url a ser processada * @property {String} [params.responseType=\"BASE64\"] - Tipo de resposta, um enum que pode ter as seguintes opções: &lt;/br&gt; * &lt;strong&gt;\"PDF\"&lt;/strong&gt; - Exibe o retorno como arquivo PDF &lt;/br&gt; * &lt;strong&gt;\"GIF\"&lt;/strong&gt; - Exibe o retorno como arquivo GIF &lt;/br&gt; * &lt;strong&gt;\"XML\"&lt;/strong&gt; - Exibe o retorno como arquivo XML &lt;/br&gt; * &lt;strong&gt;\"BASE64\"&lt;/strong&gt; - Exibe o retorno como Base64 &lt;/br&gt; * @property {String} [params.browser=\"firefox\"] - Navegador a ser utilizado, um enum que pode ter as seguintes opções: &lt;/br&gt; * &lt;strong&gt;\"chromium\"&lt;/strong&gt; - Usa o Chromium como Engine &lt;/br&gt; * &lt;strong&gt;\"firefox\"&lt;/strong&gt; - Usa o Firefox como engine &lt;/br&gt; * &lt;strong&gt;\"webkit\"&lt;/strong&gt; - Usa o webkit como engine &lt;/br&gt; * @property {Boolean} [params.visible] - Exibe o navegador durante o processamento * @property {Array} params.steps - Um array de objetos no qual cada item do array é um objeto que representa uma etapa específica no processo. * @property {Object} params.steps.items - Objeto que representa uma etapa específica no processo. * @property {Object} params.steps.items.props - Propriedades do objeto que representa uma etapa específica no processo. * @property {String} params.steps.items.props.type - Tipo de passo a ser realizado, um enum que pode ter as seguintes opções: &lt;/br&gt; * &lt;strong&gt;\"URL\"&lt;/strong&gt; - Navega para uma URL &lt;/br&gt; * &lt;strong&gt;\"LINK\"&lt;/strong&gt; - Download de Link direto para arquivo &lt;/br&gt; * &lt;strong&gt;\"CLICK\"&lt;/strong&gt; - Clica em um elemento da página &lt;/br&gt; * &lt;strong&gt;\"CLICKDOWNLOAD\"&lt;/strong&gt; - Clica em um seletor e faz Download &lt;/br&gt; * &lt;strong&gt;\"AWAITDOWNLOAD\"&lt;/strong&gt; - Clica em um seletor e faz Download &lt;/br&gt; * &lt;strong&gt;\"POPUP\"&lt;/strong&gt; - Aguarda popup e faz download baseado em seletor &lt;/br&gt; * &lt;strong&gt;\"IMG\"&lt;/strong&gt; - Download de imagem incorporada em uma página &lt;/br&gt; * &lt;strong&gt;\"PORTO\"&lt;/strong&gt; - Caminho personalizado &lt;/br&gt; * &lt;strong&gt;\"PDF\"&lt;/strong&gt; - Gera PDF da URL &lt;/br&gt; * &lt;strong&gt;\"CONTENT\"&lt;/strong&gt; - Retorna o conteúdo da página &lt;/br&gt; * @property {String} [params.steps.items.props.value] - Valor do passo a ser executado. &lt;strong&gt;Nota&lt;/strong&gt;: este campo é opcional, mas se presente, não pode ser uma string vazia. * @returns {String|Object} - Se uma das ações que definem o retorno for realizada, a função retornará o resultado dessa ação. Caso contrário, retornará a string \"Solicitação recebida\". */ download: { rest: \"POST /\", description: \"Download Link\", permissions: () =&gt; true, params: { // url: {type: \"url\"}, responseType: { type: \"string\", default: \"BASE64\", optional: true, enum: [ \"PDF\", // Exibe o retorno como arquivo PDF \"GIF\", // Exibe o retorno como arquivo GIF \"XML\", // Exibe o retorno como arquivo XML \"BASE64\", // Exibe o retorno como Base64 ], }, browser: { type: \"string\", default: \"firefox\", optional: true, enum: [ \"chromium\", // Usa o Chromium como Engine \"firefox\", // Usa o Firefox como engine \"webkit\", // Usa o webkit como engine ], }, visible: \"boolean|optional\", steps: { type: \"array\", items: { type: \"object\", props: { type: { type: \"string\", enum: [ \"URL\", // Navega para uma URL \"LINK\", // Download de Link direto para arquivo \"CLICK\", // Clica em um elemento da página \"CLICKDOWNLOAD\", // Clica em um seletor e faz Download \"AWAITDOWNLOAD\", // Clica em um seletor e faz Download \"POPUP\", // Aguarda popup e faz download baseado em seletor \"IMG\", // Download de imagem incorporada em uma página \"PORTO\", // Caminho personalizado \"PDF\", // Gera PDF da URL \"CONTENT\", // Retorna o conteúdo da página ], }, value: { type: \"string\", empty: false, optional: true, }, }, }, }, }, async handler(ctx) { let retorno; const { page, browser } = await this.createPage(ctx); const { steps } = ctx.params; for (const step of steps) { switch (step.type) { // Navega para uma URL case \"URL\": const url = step.value; await this.goToUrl(page, url); break; // Download de Link direto para arquivo case \"LINK\": const urlFile = step.value; retorno = await this.link(ctx, urlFile); break; // Clica em um elemento da página case \"CLICK\": const selector = step.value; await this.click(page, selector); break; // Navega para uma URL, clica e aguarda o Download case \"CLICKDOWNLOAD\": const downSelector = step.value; retorno = await this.clickDownload( ctx, page, downSelector, ); break; // Navega para uma URL, e aguarda o Download case \"AWAITDOWNLOAD\": retorno = await this.awaitDownload(ctx, page); break; // Aguarda popup e faz download baseado em seletor case \"POPUP\": const popupSelector = step.value; retorno = await this.popup( ctx, page, popupSelector, ); break; // Download de imagem incorporada em uma página case \"IMG\": const imgSelector = step.value; retorno = await this.img(ctx, page, imgSelector); break; // Gera PDF da URL case \"PDF\": const pdfUrl = step.value || \"\"; retorno = await this.pdf(ctx, page, pdfUrl); break; // Retorna o conteúdo da página case \"CONTENT\": retorno = await this.content(ctx, page); break; // Caminho personalizado case \"PORTO\": await page.goto( \"https://nfe.portoalegre.rs.gov.br/nfse/pages/consultaNFS-e_cidadao.jsf\", ); await page .locator('input[name=\"form\\\\:cnpjPrestador\"]') .fill(\"18410549000110\"); await page .locator('input[name=\"form\\\\:numeroNfsE\"]') .fill(\"202000000000305\"); await page .locator('input[name=\"form\\\\:codVerif\"]') .fill(\"fe07a9a8\"); await page .locator( 'input[name=\"form\\\\:bt_procurar_NFS-e\"]', ) .click(); break; default: break; } } await browser.close(); return retorno || \"Solicitação recebida\"; }, openapi: { responses: { 200: { description: \"Download solicitado com sucesso\", content: { \"application/json\": { schema: { type: \"object\", }, }, }, }, }, requestBody: { content: { \"application/json\": { examples: { Ginfes: { summary: \"GINFES\", value: { responseType: \"BASE64\", steps: [ { type: \"URL\", value: \"http://jundiai.ginfes.com.br/birt/frameset?__report=nfs_jundiai.rptdesign&amp;cdVerificacao=628305267&amp;numNota=24522\", }, { type: \"CLICKDOWNLOAD\", value: \"text=Exportar PDF\", }, ], }, }, }, }, }, }, }, }, /** * A action urlToPdf converte uma URL em um PDF, criando um PDF da página web aberta, com certas configurações de margem e formato. &lt;/br&gt; * Ela verifica se o parâmetro urlBase64 foi fornecido. Se sim, ele decodifica a URL que foi codificada em base64. Caso contrário, usa a URL fornecida diretamente. * @summary Ação urlToPdf * @action urlToPdf * @memberof add-tools-browser-api.BROWSER# * @property {String} rest - Rota da ação: \"POST /urlToPdf\" * @property {String} description - Descrição breve da ação usada em listas automáticas * @property {Object} params - Parâmetros da ação * @property {String} [params.url] - URL a ser processada * @property {string} [params.urlBase64] - URL a ser processada em Base64 * @returns Retorna o PDF criado. * @throws Se ocorrer algum erro durante esse processo, ele será registrado no console. */ urlToPdf: { rest: \"POST /urlToPdf\", description: \"Convert URL to PDF\", params: { url: { type: \"url\", optional: true }, urlBase64: { type: \"string\", optional: true }, }, async handler(ctx) { try { let { url } = ctx.params; if (ctx.params.urlBase64) { const { urlBase64 } = ctx.params; url = await ctx.call(\"base64.decode\", { string: urlBase64, }); } const span = ctx.startSpan(\"Inicialização do Browser\"); const browser = await puppeteer.launch({ headless: true, }); const webPage = await browser.newPage(); await webPage.goto(url, { waitUntil: \"networkidle0\", }); ctx.finishSpan(span); const spanPDF = ctx.startSpan(\"Criação do PDF\"); const pdf = await webPage.pdf({ printBackground: false, format: \"A4\", margin: { top: \"20px\", bottom: \"40px\", left: \"20px\", right: \"20px\", }, }); await browser.close(); ctx.finishSpan(spanPDF); ctx.meta.$responseType = \"application/pdf\"; ctx.meta.$responseHeaders = { \"Content-Disposition\": `attachment; filename=\"page.pdf\"`, }; return pdf; } catch (error) { console.log(error.message); } }, openapi: { responses: { 200: { description: \"PDF criado com sucesso\", content: { \"application/json\": { schema: { type: \"object\", }, }, }, }, }, }, }, }, methods: { /** * O method createPage inicia o navegador com o motor selecionado, cria um novo contexto de navegador com configurações específicas (aceitar downloads e ignorar erros HTTPS) e cria uma nova página nesse contexto. * @summary Método createPage * @method createPage * @memberof add-tools-browser-api.BROWSER# * @param {object} ctx - Contexto da requisição * @param {boolean} ctx.params.visible - Exibe o navegador durante o processamento * @param {string} ctx.params.browser - Navegador a ser utilizado, um enum que pode ter as seguintes opções: &lt;/br&gt; * &lt;strong&gt;\"chromium\"&lt;/strong&gt; - Usa o Chromium como Engine &lt;/br&gt; * &lt;strong&gt;\"firefox\"&lt;/strong&gt; - Usa o Firefox como engine &lt;/br&gt; * &lt;strong&gt;\"webkit\"&lt;/strong&gt; - Usa o webkit como engine &lt;/br&gt; * @returns {object} - Retorna um objeto contendo a página criada e o navegador iniciado. */ async createPage(ctx) { const headless = ctx.params.visible; // || // !!ctx.params.steps.find((step) =&gt; step.type === \"POPUP\") // ? false // : true; let engine; switch (ctx.params.browser) { case \"chromium\": engine = chromium; break; case \"firefox\": engine = firefox; break; case \"webkit\": engine = webkit; break; default: break; } const browser = await engine.launch({ headless, timeout: 90000, }); // Or 'firefox' or 'webkit'. const context = await browser.newContext({ acceptDownloads: true, ignoreHTTPSErrors: true, }); const page = await context.newPage(); return { page, browser }; }, /** * O method goToUrl navega para uma URL específica em uma página de navegador e espera até que um elemento com o ID \"Form1\" esteja anexado ao DOM. * @summary método goToUrl * @method goToUrl * @memberof add-tools-browser-api.BROWSER# * @param {object} page - Página do navegador, representa uma única guia ou janela de navegador * @param {string} url - URL para a qual a página deve navegar */ async goToUrl(page, url) { await page.goto(url); await page.waitForSelector(\"#Form1\", { state: \"attached\" }); }, /** * O method link faz uma solicitação HTTP GET para uma URL específica e retorna os dados da resposta. &lt;/br&gt; * @summary método link * @method link * @memberof add-tools-browser-api.BROWSER# * @param {object} ctx - Contém os parâmetros da solicitação e métodos para interagir com o serviço. * @param {string} url - URL para a qual a solicitação HTTP GET deve ser feita. * @returns {Promise} - Retorna uma Promise que resolve para uma string base64 ou um buffer, dependendo do parâmetro responseType. * @throws Se ocorrer algum erro durante esse processo, ele será registrado no console. */ async link(ctx, url) { const response = await ctx .call(\"HTTP.get\", { url, opt: { responseType: \"buffer\", }, }) .catch((err) =&gt; console.log(err)); const data = Buffer.from(response.body.data, \"binary\"); return ctx.params.responseType === \"BASE64\" ? await this.returnBase64(data) : await this.returnBin(ctx, data); // const filePath = `${__dirname}/${filename}`; // await new Promise((resolve) =&gt; { // const writeStream = fs.createWriteStream(filePath); // response.data.pipe(writeStream); // writeStream.on(\"finish\", resolve); // }); }, /** * O method click executa a ação de um click em um seletor da página * @summary método click * @method click * @memberof add-tools-browser-api.BROWSER# * @param {object} page - Página do navegador, representa uma única guia ou janela de navegador * @param {string} selector - Seletor do elemento a ser clicado */ async click(page, selector) { const locator = await page.locator(selector); await locator.click(); }, /** * @desc O method clickDownload efetua a ação de clique e aguarda pelo evento de download * @summary Método para efetuar download * @method clickDownload * @memberof add-tools-browser-api.BROWSER# * @param {object} ctx - Contexto da requisição * @param {object} page - Página do navegador * @param {string} selector - Seletor do elemento a ser clicado */ async clickDownload(ctx, page, selector) { const locator = await page.locator(selector); try { const [download] = await Promise.all([ page.waitForEvent(\"download\"), // wait for download to start await locator.click(), ]); const data = fs.readFileSync(await download.path()); return ctx.params.responseType === \"BASE64\" ? await this.returnBase64(data) : await this.returnBin(ctx, data); } catch (error) { console.log(error); } }, /** * @desc O method awaitDownload aguarda por um evento direto de download * @summary Método para download direto * @method awaitDownload * @memberof add-tools-browser-api.BROWSER# * @param {object} ctx - Contexto da requisição * @param {object} page - Página do navegador */ async awaitDownload(ctx, page) { try { const [download] = await Promise.all([ page.waitForEvent(\"download\"), // wait for download to start ]); const data = fs.readFileSync(await download.path()); return ctx.params.responseType === \"BASE64\" ? await this.returnBase64(data) : await this.returnBin(ctx, data); } catch (error) { console.log(error); } }, /** * @desc O method popup aguarda um popup ser aberto e faz o download do arquivo baseado no seletor informado * @summary Método para tratar popups * @method popup * @memberof add-tools-browser-api.BROWSER# * @param {object} ctx - Contexto da requisição * @param {object} page - Página do navegador * @param {string} selector - Seletor do elemento a ser clicado */ async popup(ctx, page, selector) { await new Promise((resolve) =&gt; { page.on(\"popup\", async (popup) =&gt; { await popup.waitForLoadState(); await popup.title(); const locator = await popup.locator(selector); try { const response = await ctx .call(\"HTTP.get\", { url: locator._frame._url, opt: { responseType: \"buffer\", }, }) .catch((err) =&gt; console.log(err)); const base64 = Buffer.from(response, \"binary\").toString( \"base64\", ); // const base64 = Buffer.from( // response.data, // \"binary\" // ).toString(\"base64\"); return base64; } catch { } finally { } }); }); }, /** * @desc O method &lt;code&gt;img()&lt;/code&gt; faz o download de uma imagem via http * @summary Método para download de imagem * @function img * @memberof add-tools-browser-api.BROWSER# * @param {object} ctx - Contexto da requisição * @param {object} page - Página do navegador * @param {string} selector - Seletor do elemento a ser clicado */ async img(ctx, page, selector) { const locator = await page.locator(selector); // const response = await axios.get(locator._frame._url, { // responseType: \"arraybuffer\", // }); const response = await ctx .call(\"HTTP.get\", { url: locator._frame._url, opt: { responseType: \"buffer\", }, }) .catch((err) =&gt; console.log(err)); const data = Buffer.from(response.body.data, \"binary\"); return ctx.params.responseType === \"BASE64\" ? await this.returnBase64(data) : await this.returnBin(ctx, data); // const base64 = Buffer.from(response.body.data, \"binary\").toString( // \"base64\" // ); // let base64; // base64 = Buffer.from(response.data, \"binary\").toString(\"base64\"); // return base64; }, /** * @desc O method &lt;code&gt;pdf()&lt;/code&gt; retorna o conteúdo da página em formato PDF * @summary Método para conversão em formato PDF * @method pdf * @memberof add-tools-browser-api.BROWSER# * @param {object} ctx - Contexto da requisição * @param {object} page - Página do navegador * @param {string} url - URL a ser processada */ async pdf(ctx, page, url) { if (url) { await this.goToUrl(page, url); } const data = await page.pdf({ printBackground: true, format: \"A4\", margin: { top: \"5mm\", left: \"4mm\", right: \"4mm\" }, }); return ctx.params.responseType === \"BASE64\" ? await this.returnBase64(data) : await this.returnBin(ctx, data); }, /** * @desc O method &lt;code&gt;content()&lt;/code&gt; retorna o conteúdo da página * @summary Método para retornar o conteúdo da página * @method content * @memberof add-tools-browser-api.BROWSER# * @param {object} ctx - Contexto da requisição * @param {object} page - Página do navegador */ async content(ctx, page) { const data = Buffer.from(await page.content(), \"utf-8\"); return ctx.params.responseType === \"BASE64\" ? await this.returnBase64(data) : await this.returnBin(ctx, data); }, /** * @desc O method &lt;code&gt;returnBin()&lt;/code&gt; retorna um arquivo binário * @summary Método para retornar um arquivo binário * @method returnBin * @memberof add-tools-browser-api.BROWSER# * @param {object} ctx - Contexto da requisição * @param {object} data - Dados a serem processados */ async returnBin(ctx, data) { switch (ctx.params.responseType) { case \"PDF\": ctx.meta.$responseType = \"application/pdf\"; ctx.meta.$responseHeaders = { \"Content-Disposition\": `attachment; filename=\"page.pdf\"`, }; break; case \"GIF\": ctx.meta.$responseType = \"image/gif\"; ctx.meta.$responseHeaders = { \"Content-Disposition\": `attachment; filename=\"page.gif\"`, }; break; case \"XML\": ctx.meta.$responseType = \"application/xml\"; ctx.meta.$responseHeaders = { \"Content-Disposition\": `attachment; filename=\"page.xml\"`, }; break; default: break; } return data; }, /** * @desc O method &lt;code&gt;returnBase64()&lt;/code&gt; converte o conteúdo para base64 * @summary Método para encode base64 * @method returnBase64 * @memberof add-tools-browser-api.BROWSER# * @param {object} data - Dados a serem processados */ async returnBase64(data) { const base64 = data.toString(\"base64\"); return base64; }, }, }; × Search results Close "},"add-tools-browser-api_src_services_GOVBR.service.js.html":{"id":"add-tools-browser-api_src_services_GOVBR.service.js.html","title":"Source: add-tools-browser-api/src/services/GOVBR.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-browser-api/src/services/GOVBR.service.js \"use strict\"; const { chromium } = require('playwright'); const request = require('request'); const fs = require('fs'); /** * @desc O Serviço de GOVBR acessa páginas desse sistema para obter o conteúdo de arquivos * @namespace add-tools-browser-api.GOVBR * @memberof add-tools-browser-api * @property {string} name - Nome do serviço, que obtém o nome do arquivo atual sem a extensão * @property {object} settings - Configurações do serviço * @property {object} actions - Ações do serviço: &lt;strong&gt;getDocuments&lt;/strong&gt; * @todo property {object} methods - Métodos do serviço &lt;code&gt;NomeDoMétodo()&lt;/code&gt; */ module.exports = { name: __filename.split('.')[0].split('/').pop(), settings: { IDAPP: `${/\\add-\\w*-\\w*-api(?!.*\\add-\\w*-\\w*-api)/.exec(__dirname)}`, }, /** * @summary Actions do serviço * @property {object} getDocuments - Action getDocuments {@link add-tools-browser-api.GOVBR#getDocuments action getDocuments} * @memberof add-tools-browser-api.GOVBR# */ actions: { /** * @desc Ação para baixar documentos de GOVBR &lt;/br&gt; * @summary Ação getDocuments * @action getDocuments * @memberof add-tools-browser-api.GOVBR# * @property {string} rest - Rota da action * @property {string} description - Descrição da action * @property {object} params - Parâmetros da action * @property {string} params.REQ_XML - Parâmetro REQ_XML * @property {string} params.secretAlias - Parâmetro secretAlias * @property {boolean} cache - Cache da action * @returns {string} Retorna uma string como o conteúdo do arquivo envolvido com a tag &lt;strong&gt;ListNFSe&lt;/strong&gt; */ getDocuments: { rest: '/', description: \"Baixa documentos de GOVBR\", params: { REQ_XML: { type: \"string\" }, secretAlias: { type: \"string\" } }, cache: false, async handler(ctx) { debugger /** * * * esse serviço pode ser invocado para baixar notas fiscais de GOVBR * * */ const browser = await chromium.launch(); const context = await browser.newContext({ acceptDownloads: true }); const page = await context.newPage(); const DTINI = new Date(ctx.params.REQ_XML.match(/(?&lt;=DTINI&gt;)(.*?)(?=&lt;\\/DTINI&gt;)/s)[0]); const DTFIM = new Date(ctx.params.REQ_XML.match(/(?&lt;=DTFIM&gt;)(.*?)(?=&lt;\\/DTFIM&gt;)/s)[0]); const vault = await ctx.call(\"vault.retrieveSecret\", { secretType: \"\", secretAlias: ctx.params.secretAlias, addDecrypt: \"X\" }); await context.route('https://www.nfse.gov.br/EmissorNacional/Certificado', (route, req) =&gt; { const options = { uri: req.url(), method: req.method(), headers: req.headers(), body: req.postDataBuffer(), timeout: 20000, followRedirect: false, agentOptions: { pfx: Buffer.from(vault.data.pkcs12, 'base64'), passphrase: Buffer.from(vault.data.pkcs12Password, 'base64').toString() } }; // Fire off the request manually (example is using using 'request' lib) return request(options, function (err, resp, body) { // Abort interceptedRequest on error if (err) { console.error(`Unable to call ${options.uri}`, err); return route.abort('connectionrefused'); } // Return retrieved response to interceptedRequest route.fulfill({ status: resp.statusCode, contentType: resp.headers['content-type'], headers: resp.headers, body: body }); }); }); let docs = \"\"; await page.goto('https://www.nfse.gov.br/EmissorNacional'); await page.click('xpath=/html/body/section/div/div/div[2]/div[2]/div[2]/div/a'); await page.click('xpath=/html/body/section/div/div/div[2]/div[2]/div[2]/div/a'); console.log(\"LOGANDO NO SISTEMA\"); await new Promise(resolve =&gt; setTimeout(resolve, 5000)); await page.click('xpath=/html/body/nav[1]/div/div[2]/ul/li[4]/a'); console.log(\"MENU NOTAS FISCAIS RECEBIDAS\"); await new Promise(resolve =&gt; setTimeout(resolve, 5000)); const tbody = await page.$('xpath=/html/body/div[1]/table/tbody'); const rows = await tbody.$$('tr'); for (const row of rows) { const cells = await row.$$('td'); const date = await cells[0].textContent(); const value = await cells[2].textContent(); await cells[5].click(); const a = await cells[5].$$('div div a'); const href = await a[1].getAttribute('href'); const [day, month, year] = date.trim().split('/'); const doc = { date: new Date(`${year}-${month}-${day}`), value: value.trim(), link: href } // Verifique se a data de destino está entre a data de início e a data de término if (doc.date &gt;= DTINI &amp;&amp; doc.date &lt;= DTFIM) { const [download] = await Promise.all([ page.waitForEvent('download'), // Aguardar o início do download await page.click(`a[href=\"${href}\"]`) ]); await new Promise(resolve =&gt; setTimeout(resolve, 500)); console.log(\"BAIXANDO NOTAS\"); const downloadedFilePath = await download.path(); let fileContent = fs.readFileSync(downloadedFilePath, 'utf-8'); fileContent = fileContent.replace(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?&gt;\", \"\"); docs += `&lt;Nfse&gt;${fileContent}&lt;/Nfse&gt;`; fs.unlinkSync(downloadedFilePath); } } await browser.close(); return `&lt;ListNFSe&gt;${docs}&lt;/ListNFSe&gt;`; } }, }, methods: {}, }; × Search results Close "},"add-tools-browser-api_src_services_PR4106902.service.js.html":{"id":"add-tools-browser-api_src_services_PR4106902.service.js.html","title":"Source: add-tools-browser-api/src/services/PR4106902.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-browser-api/src/services/PR4106902.service.js \"use strict\"; const { chromium } = require('playwright'); const request = require('request'); const fs = require('fs'); /** * @desc O Serviço de PR4106902 baixa documentos de Curitiba * @namespace add-tools-browser-api.PR4106902 * @memberof add-tools-browser-api * @property {string} name - Nome do serviço, que obtém o nome do arquivo atual sem a extensão * @property {object} settings - Configurações do serviço * @property {object} actions - Ações do serviço: &lt;strong&gt;getDocuments&lt;/strong&gt; * @todo property {object} methods - Métodos do serviço &lt;code&gt;NomeDoMétodo()&lt;/code&gt; */ module.exports = { name: __filename.split('.')[0].split('/').pop(), settings: { IDAPP: `${/\\add-\\w*-\\w*-api(?!.*\\add-\\w*-\\w*-api)/.exec(__dirname)}`, }, /** * @summary actions * @property {object} getDocuments - Action getDocuments * @memberof add-tools-browser-api.PR4106902# */ actions: { /** * @desc Ação para baixar documentos * @summary Action getDocuments * @action getDocuments * @memberof add-tools-browser-api.PR4106902# * @property {string} rest - Rota da action * @property {string} description - Descrição da action * @property {object} params - Parâmetros da action * @property {string} params.REQ_XML - Parâmetro REQ_XML * @property {string} params.secretAlias - Parâmetro secretAlias * @property {boolean} cache - Cache da action * @returns {string|buffer} fileContent */ getDocuments: { rest: '/', description: \"Baixa documentos de curitiba\", params: { REQ_XML: { type: \"string\" }, secretAlias: { type: \"string\" } }, cache: false, async handler(ctx) { debugger /** * * * esse serviço pode ser invocado para baixar notas fiscais de curitiba * * */ const browser = await chromium.launch(); const context = await browser.newContext({ acceptDownloads: true }); const page = await context.newPage(); let [year, month, day] = ctx.params.REQ_XML.match(/(?&lt;=DTINI&gt;)(.*?)(?=&lt;\\/DTINI&gt;)/s)[0].split('-'); const DTINI = `${day}${month}${year}`; [year, month, day] = ctx.params.REQ_XML.match(/(?&lt;=DTFIM&gt;)(.*?)(?=&lt;\\/DTFIM&gt;)/s)[0].split('-'); const DTFIM = `${day}${month}${year}`; const vault = await ctx.call(\"vault.retrieveSecret\", { secretType: \"\", secretAlias: ctx.params.secretAlias, addDecrypt: \"X\" }); await context.route('https://isscuritiba.curitiba.pr.gov.br/iss/default.aspx', (route, req) =&gt; { const options = { uri: req.url(), method: req.method(), headers: req.headers(), body: req.postDataBuffer(), timeout: 20000, followRedirect: false, agentOptions: { pfx: Buffer.from(vault.data.pkcs12, 'base64'), passphrase: Buffer.from(vault.data.pkcs12Password, 'base64').toString() } }; // Fire off the request manually (example is using using 'request' lib) return request(options, function (err, resp, body) { // Abort interceptedRequest on error if (err) { console.error(`Unable to call ${options.uri}`, err); return route.abort('connectionrefused'); } // Return retrieved response to interceptedRequest route.fulfill({ status: resp.statusCode, contentType: resp.headers['content-type'], headers: resp.headers, body: body }); }); }); await page.goto('https://isscuritiba.curitiba.pr.gov.br'); // Aguarde a abertura do pop-up e obtenha a referência à página do pop-up const popUpPage = await page.waitForEvent('popup'); await popUpPage.waitForLoadState(); // Clique no botão para fechar o anúncio // await popUpPage.click('#btnFechar'); // console.log('FECHAR ANÚNCIO'); // Espere por um momento (opcional) await new Promise(resolve =&gt; setTimeout(resolve, 5000)); // Clique no botão para entrar com o certificado await popUpPage.click('#btnLoginCertificado'); console.log('ENTRAR COM CERTIFICADO'); // Espere por um momento (opcional) await new Promise(resolve =&gt; setTimeout(resolve, 5000)); // Localize e clique no frame \"fraMenu\" const fraMenu = popUpPage.frame({ name: 'fraMenu' }); await fraMenu.click('#td1_div5'); console.log('CLICAR NA ABA NFSE'); // Espere por um momento (opcional) await new Promise(resolve =&gt; setTimeout(resolve, 5000)); // Localize e clique no frame \"iFrameMenu\" const iFrameMenu = popUpPage.frame({ name: 'iFrameMenu' }); await iFrameMenu.click('xpath=/html/body/form/div[2]/table/tbody/tr/td/div[4]/a'); console.log('CLICAR NA ABA PESQUISAR NFSE RECEBIDAS'); // Espere por um momento (opcional) await new Promise(resolve =&gt; setTimeout(resolve, 5000)); // Localize e clique no frame \"fraMain\" const fraMain = popUpPage.frame({ name: 'fraMain' }); // Localize o frame \"contentPlaceHolder\" dentro de \"fraMain\" const contentPlaceHolder = fraMain.childFrames(); await contentPlaceHolder[0].waitForLoadState(); // Agora você está dentro do contexto do frame \"contentPlaceHolder\" await new Promise(resolve =&gt; setTimeout(resolve, 2000)); await contentPlaceHolder[0].click('#TipoDataEmissao'); console.log('CLICAR EM TIPO DATA DE EMISSÂO'); await new Promise(resolve =&gt; setTimeout(resolve, 500)); const DataEmissaoInicial = await contentPlaceHolder[0].$('#DataEmissaoInicial'); await DataEmissaoInicial.type(DTINI, { delay: 100 }); console.log('INSERIR DATA INICIAL'); const DataEmissaoFinal = await contentPlaceHolder[0].$('#DataEmissaoFinal'); await DataEmissaoFinal.type(DTFIM, { delay: 100 }); console.log('INSERIR DATA FINAL'); await contentPlaceHolder[0].click('#btnPesquisar'); console.log('PESQUISAR'); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); const [download] = await Promise.all([ popUpPage.waitForEvent('download'), // Aguardar o início do download await contentPlaceHolder[0].click('xpath=/html/body/div[2]/main/div[6]/div/div/div/div/div[2]/div/div[1]/div/a[1]') ]); console.log('EFETUANDO DOWNLOAD XML'); const downloadedFilePath = await download.path(); const fileContent = fs.readFileSync(downloadedFilePath, 'utf-8'); fs.unlinkSync(downloadedFilePath); // Feche o pop-up await popUpPage.close(); await browser.close(); return fileContent; } }, }, methods: {}, }; × Search results Close "},"add-tools-browser-api_src_services_RJ3304557.service.js.html":{"id":"add-tools-browser-api_src_services_RJ3304557.service.js.html","title":"Source: add-tools-browser-api/src/services/RJ3304557.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-browser-api/src/services/RJ3304557.service.js \"use strict\"; const { chromium } = require('playwright'); const request = require('request'); const fs = require('fs'); /** * @desc O Serviço RJ3304557 ... * @namespace add-tools-browser-api.RJ3304557 * @memberof add-tools-browser-api * @property {string} name - Nome do serviço, que obtém o nome do arquivo atual sem a extensão * @property {object} settings - Configurações do serviço * @property {string} [settings.IDAPP] - ID do APP que pode ser usado em permissões * @property {object} actions - Ações do serviço: &lt;strong&gt;getDocuments&lt;/strong&gt; * @todo @property {object} methods - Métodos do serviço: &lt;code&gt;NomeDoMétodo()&lt;/code&gt; */ module.exports = { name: __filename.split('.')[0].split('/').pop(), settings: { IDAPP: `${/\\add-\\w*-\\w*-api(?!.*\\add-\\w*-\\w*-api)/.exec(__dirname)}`, }, /** * @summary Actions do serviço * @property {object} getDocuments - Action getDocuments * @memberof add-tools-browser-api.RJ3304557# */ actions: { /** * @desc Ação para ... * @summary Action getDocuments * @action getDocuments * @memberof add-tools-browser-api.RJ3304557# * @property {string} description - Descrição da action * @property {object} params - Parâmetros da action * @property {string} params.REQ_XML - Parâmetro REQ_XML * @property {string} params.secretAlias - Parâmetro secretAlias * @property {boolean} cache - Cache da action * @returns {string} Retorna ... * @instance */ getDocuments: { description: \"Baixa documentos do rio de janeiro\", params: { REQ_XML: { type: \"string\" }, secretAlias: { type: \"string\" } }, cache: false, async handler(ctx) { debugger /** * * * esse serviço pode ser invocado para baixar notas fiscais de rio de janeiro * * */ const browser = await chromium.launch(); const context = await browser.newContext({ acceptDownloads: true }); const page = await context.newPage(); let [year, month, day] = ctx.params.REQ_XML.match(/(?&lt;=DTINI&gt;)(.*?)(?=&lt;\\/DTINI&gt;)/s)[0].split('-'); const DTINI = `${day}%2F${month}%2F${year}`; [year, month, day] = ctx.params.REQ_XML.match(/(?&lt;=DTFIM&gt;)(.*?)(?=&lt;\\/DTFIM&gt;)/s)[0].split('-'); const DTFIM = `${day}%2F${month}%2F${year}`; const vault = await ctx.call(\"vault.retrieveSecret\", { secretType: \"\", secretAlias: ctx.params.secretAlias, addDecrypt: \"X\" }); await context.route('https://notacarioca.rio.gov.br/senhaweb/loginICP.aspx', (route, req) =&gt; { const options = { uri: req.url(), method: req.method(), headers: req.headers(), body: req.postDataBuffer(), timeout: 20000, followRedirect: false, agentOptions: { pfx: Buffer.from(vault.data.pkcs12, 'base64'), passphrase: Buffer.from(vault.data.pkcs12Password, 'base64').toString() } }; // Fire off the request manually (example is using using 'request' lib) return request(options, function (err, resp, body) { // Abort interceptedRequest on error if (err) { console.error(`Unable to call ${options.uri}`, err); return route.abort('connectionrefused'); } // Return retrieved response to interceptedRequest route.fulfill({ status: resp.statusCode, contentType: resp.headers['content-type'], headers: resp.headers, body: body }); }); }); await page.goto('https://notacarioca.rio.gov.br/senhaweb/loginICP.aspx'); console.log(\"Efetuando login\"); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); await page.click(\"#ctl00_cphCabMenu_btAcesso\"); await page.waitForLoadState(); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); await page.goto(`https://notacarioca.rio.gov.br/tomador/notasrecebidas.aspx?inicio=${DTINI}&amp;fim=${DTFIM}&amp;canceladas=1`); console.log(\"Acessando notas recebidas\"); await page.waitForLoadState(); const selectElement = await page.$('#ctl00_cphCabMenu_btExportar_ddlTipoArquivo'); await selectElement.selectOption({ value: '3' }); await new Promise(resolve =&gt; setTimeout(resolve, 2000)); const [download] = await Promise.all([ page.waitForEvent('download'), // Aguardar o início do download await page.click(\"#ctl00_cphCabMenu_btExportar_btGerar\") ]); console.log(\"Baixando notasss\"); const downloadedFilePath = await download.path(); const fileContent = fs.readFileSync(downloadedFilePath, 'utf-8'); fs.unlinkSync(downloadedFilePath); // Feche o pop-up await page.close(); await browser.close(); return fileContent; } }, }, methods: {}, }; × Search results Close "},"add-tools-browser-api_src_services_test_unit_BA2933307.service.spec.js.html":{"id":"add-tools-browser-api_src_services_test_unit_BA2933307.service.spec.js.html","title":"Source: add-tools-browser-api/src/services/test/unit/BA2933307.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-browser-api/src/services/test/unit/BA2933307.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../BA2933307.service\"); const { ValidationError } = require(\"moleculer\").Errors; const { AddsonServerError, AddsonClientError } = require(\"add-base-utils-lib/libs/customErrors\"); // const Settings = require(\"./cenarios/Settings\"); /** * Testes para os serviços contidos em &lt;strong&gt;add-tools-ocr-api&lt;/strong&gt; * @namespace add-tools-browser-api.Testes */ /** * Este arquivo contém os testes para o serviço BA2933307 * @namespace add-tools-browser-api.Testes.BA2933307 */ /** * Bloco de testes do Serviço BA2933307 */ describe(\"Testando serviço 'BA2933307'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start(), 180000); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço BA2933307 deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-browser-api.Testes.BA2933307# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço BA2933307 existe um código IDAPP. &lt;/br&gt; * O serviço BA2933307 deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-browser-api.Testes.BA2933307# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço BA2933307 */ describe(\"Testando actions do serviço 'BA2933307'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço BA2933307 deve ter uma descrição breve, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-browser-api.Testes.BA2933307# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); }); }); × Search results Close "},"add-tools-browser-api_src_services_test_unit_BROWSER.service.spec.js.html":{"id":"add-tools-browser-api_src_services_test_unit_BROWSER.service.spec.js.html","title":"Source: add-tools-browser-api/src/services/test/unit/BROWSER.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-browser-api/src/services/test/unit/BROWSER.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../BROWSER.service\"); const { ValidationError } = require(\"moleculer\").Errors; const { AddsonServerError, AddsonClientError } = require(\"add-base-utils-lib/libs/customErrors\"); // const Settings = require(\"./cenarios/Settings\"); /** * Este arquivo contém os testes para o serviço BROWSER * @namespace add-tools-browser-api.Testes.BROWSER */ /** * Bloco de testes do Serviço BROWSER */ describe(\"Testando serviço 'BROWSER'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start(), 180000); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço BROWSER deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-browser-api.Testes.BROWSER# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço BROWSER existe um código IDAPP. &lt;/br&gt; * O serviço BROWSER deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-browser-api.Testes.BROWSER# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço BROWSER */ describe(\"Testando actions do serviço 'BROWSER'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço BROWSER deve ter uma descrição, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-browser-api.Testes.BROWSER# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); }); }); × Search results Close "},"add-tools-browser-api_src_services_test_unit_GOVBR.service.spec.js.html":{"id":"add-tools-browser-api_src_services_test_unit_GOVBR.service.spec.js.html","title":"Source: add-tools-browser-api/src/services/test/unit/GOVBR.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-browser-api/src/services/test/unit/GOVBR.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../GOVBR.service\"); const { ValidationError } = require(\"moleculer\").Errors; const { AddsonServerError, AddsonClientError } = require(\"add-base-utils-lib/libs/customErrors\"); // const Settings = require(\"./cenarios/Settings\"); /** * Este arquivo contém os testes para o serviço GOVBR * @namespace add-tools-browser-api.Testes.GOVBR */ /** * Bloco de testes do Serviço GOVBR */ describe(\"Testando serviço 'GOVBR'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start(), 180000); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço GOVBR deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-browser-api.Testes.GOVBR# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço GOVBR existe um código IDAPP. &lt;/br&gt; * O serviço GOVBR deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-browser-api.Testes.GOVBR# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço GOVBR */ describe(\"Testando actions do serviço 'GOVBR'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço GOVBR deve ter uma descrição, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-browser-api.Testes.GOVBR# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); }); }); × Search results Close "},"add-tools-browser-api_src_services_test_unit_PR4106902.service.spec.js.html":{"id":"add-tools-browser-api_src_services_test_unit_PR4106902.service.spec.js.html","title":"Source: add-tools-browser-api/src/services/test/unit/PR4106902.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-browser-api/src/services/test/unit/PR4106902.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../PR4106902.service\"); const { ValidationError } = require(\"moleculer\").Errors; const { AddsonServerError, AddsonClientError } = require(\"add-base-utils-lib/libs/customErrors\"); // const Settings = require(\"./cenarios/Settings\"); /** * Este arquivo contém os testes para o serviço PR4106902 * @namespace add-tools-browser-api.Testes.PR4106902 */ /** * Bloco de testes do Serviço PR4106902 */ describe(\"Testando serviço 'PR4106902'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start(), 180000); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço PR4106902 deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-browser-api.Testes.PR4106902# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço PR4106902 existe um código IDAPP. &lt;/br&gt; * O serviço PR4106902 deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-browser-api.Testes.PR4106902# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço PR4106902 */ describe(\"Testando actions do serviço 'PR4106902'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço PR4106902 deve ter uma descrição, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-browser-api.Testes.PR4106902# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); }); }); × Search results Close "},"add-tools-browser-api_src_services_test_unit_RJ3304557.service.spec.js.html":{"id":"add-tools-browser-api_src_services_test_unit_RJ3304557.service.spec.js.html","title":"Source: add-tools-browser-api/src/services/test/unit/RJ3304557.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-browser-api/src/services/test/unit/RJ3304557.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../RJ3304557.service\"); const { ValidationError } = require(\"moleculer\").Errors; const { AddsonServerError, AddsonClientError } = require(\"add-base-utils-lib/libs/customErrors\"); // const Settings = require(\"./cenarios/Settings\"); /** * Este arquivo contém os testes para o serviço RJ3304557 * @namespace add-tools-browser-api.Testes.RJ3304557 */ /** * Bloco de testes do Serviço RJ3304557 */ describe(\"Testando serviço 'RJ3304557'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start(), 180000); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço RJ3304557 deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-browser-api.Testes.RJ3304557# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço RJ3304557 existe um código IDAPP. &lt;/br&gt; * O serviço RJ3304557 deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-browser-api.Testes.RJ3304557# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço RJ3304557 */ describe(\"Testando actions do serviço 'RJ3304557'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço RJ3304557 deve ter uma descrição, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-browser-api.Testes.RJ3304557# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); }); }); × Search results Close "},"add-tools-drive-api_src_services_DRIVE.service.js.html":{"id":"add-tools-drive-api_src_services_DRIVE.service.js.html","title":"Source: add-tools-drive-api/src/services/DRIVE.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-drive-api/src/services/DRIVE.service.js \"use strict\"; const DriveMixin = require(\"storage/drive\"); const { Response } = require(\"node-fetch\"); const { AddsonClientError } = require(\"add-base-utils-lib/libs/customErrors\"); /** * @namespace {object} add-tools-drive-api */ module.exports = { /** * O Serviço de DRIVE interage com um sistema de armazenamento (local ou S3) para criar, obter em base64, verificar se existe, obter estatísticas, obter conteúdo, obter fluxo (Stream) e deletar arquivos. &lt;/br&gt; * Ele também possui um canal para escutar um evento e criar uma identificação de uma corporação no S3 quando uma corporação é criada. * @namespace add-tools-drive-api.DRIVE * @property {string} name - Nome do serviço * @property {object} mixins - Mixins do serviço * @property {array} mixins.DriveMixin - O Mixin DriveMixin é responsável por criar um sistema de armazenamento * @property {object} metadata - Usado para armazenar qualquer metadados do serviço * Estas informações podem ser acessadas via this.metadata e são transferidas para outros nós durante a chamada * @property {string} metadata.$description - Descrição breve do serviço usada em listas automáticas * @property {object} settings - Configurações internas do serviço * @property {string} settings.IDAPP - ID do APP que pode ser usado em permissões para chamar este serviço * @property {boolean} settings.rest - Se o serviço é REST ou não * @property {string} settings.STORAGE_ROOT - Diretório raiz do armazenamento: \"/upload\" * @property {object} settings.storageConfig - Configurações do armazenamento * @property {object} settings.storageConfig.disks - Tipos de discos do armazenamento * @property {object} settings.storageConfig.disks.local - Disco local * @property {String} settings.storageConfig.disks.local.driver - Driver do disco local * @property {object} settings.storageConfig.disks.s3 - Disco S3 * @property {String} settings.storageConfig.disks.s3.driver - Driver do disco S3 * @property {object} settings.storageConfig.disks.s3.config - Configurações do disco S3 */ name: \"DRIVE\", mixins: [DriveMixin()], metadata: { $description: \"Drive Storage\" }, settings: { IDAPP: `${/\\add-\\w*-\\w*-api(?!.*\\add-\\w*-\\w*-api)/.exec(__dirname)}`, rest: false, STORAGE_ROOT: \"/upload\", storageConfig: { default: \"local\", disks: { local: { driver: \"local\", }, s3: { driver: \"s3\", config: { key: process.env.AWS_ACCESS_KEY_ID, secret: process.env.AWS_SECRET_ACCESS_KEY, region: process.env.S3_REGION, bucket: process.env.S3_BUCKET, storageClass: process.env.S3_STORAGE_CLASS, // endpoint: process.env.S3_ENDPOINT, }, }, // ftp: { // driver: \"ftp\", // host: \"FTP_HOST\", // port: 21, // user: \"FTP_USER\", // pass: \"FTP_PASS\", // longLive: false, // }, }, }, }, /** * @summary Actions do serviço * @property {object} create - Action create {@link add-tools-drive-api.DRIVE#create action create} * @property {object} getBase64 - Action getBase64 {@link add-tools-drive-api.DRIVE#getBase64 action getBase64} * @property {object} exists - Action exists {@link add-tools-drive-api.DRIVE#exists action exists} * @property {object} getStat - Action getStat {@link add-tools-drive-api.DRIVE#getStat action getStat} * @property {object} getContent - Action getContent {@link add-tools-drive-api.DRIVE#getContent action getContent} * @property {object} getStream - Action getStream {@link add-tools-drive-api.DRIVE#getStream action getStream} * @property {object} delete - Action delete {@link add-tools-drive-api.DRIVE#delete action delete} * @memberof add-tools-drive-api.DRIVE# */ actions: { /** * Ação para criar um arquivo no sistema de armazenamento. &lt;/br&gt; * Ela recebe o nome do arquivo &lt;strong&gt;filename&lt;/strong&gt;, o conteúdo &lt;strong&gt;fileContent&lt;/strong&gt; em diferentes formatos (string, Buffer ou Stream), ou uma string codificada em Base64 &lt;strong&gt;base64&lt;/strong&gt;. * Ela retorna a chamada da função this.storage (que vem do Mixin DriveMixin). Essa função é chamada com os métodos &lt;strong&gt;disk&lt;/strong&gt; (com o parâmetro \"s3\") e &lt;strong&gt;create&lt;/strong&gt; (com os parâmetros filename e fileContent). * @summary Ação create * @action create * @memberof add-tools-drive-api.DRIVE# * @property {string} description - Descrição breve da ação usada em listas automáticas * @property {string} params.filename - Nome do arquivo * @property {array} [params.fileContent] - Conteúdo do arquivo que pode ser uma string, Buffer ou Stream * @property {string} [params.base64] - Conteúdo do arquivo em base64 * @returns {Promise&lt;any&gt;} Promessa que resolve quando o arquivo é criado. */ create: { description: \"Create File\", params: { filename: \"string\", fileContent: [ { type: \"string\", optional: true }, { type: \"class\", instanceOf: Buffer, optional: true }, { type: \"class\", instanceOf: ReadableStream, optional: true, }, ], base64: { type: \"string\", // base64: true, optional: true, }, }, async handler(ctx) { if (ctx.params.base64) { ctx.params.fileContent = Buffer.from( ctx.params.base64, \"base64\", ); } return await this.storage .disk(\"s3\") .create(ctx.params.filename, ctx.params.fileContent); }, }, /** * Ação para retornar o conteúdo de um arquivo em Base64. &lt;/br&gt; * Ela recebe o nome do arquivo &lt;strong&gt;filename&lt;/strong&gt; e retorna o conteúdo em Base64 ou uma mensagem de erro. * @summary Ação getBase64 * @action getBase64 * @memberof add-tools-drive-api.DRIVE# * @property {string} description - - Descrição breve da ação usada em listas automáticas * @property {object} params - Parâmetros da ação * @property {string} params.filename - Nome do arquivo * @returns {string} Conteúdo do arquivo em Base64 */ getBase64: { description: \"Get Base64 from File\", params: { filename: \"string\", }, async handler(ctx) { try { const fileStream = await this.storage .disk(\"s3\") .getStream(ctx.params.filename); const res = new Response(fileStream); const buffer = await res.arrayBuffer(); return Buffer.from(buffer).toString(\"base64\"); } catch (error) { throw new AddsonClientError( \"Context required\", 400, \"ERR_HAS_NO_CONTEXT\", ); } }, }, /** * Ação para verificar se um arquivo existe. &lt;/br&gt; * Ela recebe o nome do arquivo &lt;strong&gt;filename&lt;/strong&gt; e retorna um booleano indicando se o arquivo existe ou não. * @summary Ação exists * @action exists * @memberof add-tools-drive-api.DRIVE# * @property {string} description - Descrição breve da ação usada em listas automáticas * @property {string} description - Descrição breve da ação usada em listas automáticas * @property {string} params.filename - Nome do arquivo * @returns {boolean} Retorna o caminho do arquivo */ exists: { description: \"Check if file exists\", params: { filename: \"string\", }, async handler(ctx) { // let result = await this.storage.disk().exists(ctx.params.filename); // let result = await this.storage.disk(\"local\").exists(ctx.params.filename); const result = await this.storage .disk(\"s3\") .exists(ctx.params.filename); return result; // return await this.storage.exists(ctx.params.filename); //will use the default storage defined }, }, /** * Ação para retornar estatísticas de um arquivo. &lt;/br&gt; * Ela recebe o nome do arquivo &lt;strong&gt;filename&lt;/strong&gt; e retorna um objeto com as estatísticas do arquivo. * @summary Ação getStat * @action getStat * @memberof add-tools-drive-api.DRIVE# * @property {string} description - Descrição da action * @property {string} description - Descrição breve da ação usada em listas automáticas * @property {string} params.filename - Nome do arquivo * @returns {object} Estatísticas do arquivo */ getStat: { description: \"Return Stats from file\", params: { filename: \"string\", }, async handler(ctx) { const result = await this.storage .disk(\"s3\") .getStat(ctx.params.filename); return result; }, }, /** * Ação para retornar o conteúdo de um arquivo. &lt;/br&gt; * Ela recebe como parâmetro: o nome do arquivo &lt;strong&gt;filename&lt;/strong&gt; e a codificação &lt;strong&gt;encoding&lt;/strong&gt;&lt;/br&gt; * Ela retorna o conteúdo do arquivo como string. * @summary Ação getContent * @action getContent * @memberof add-tools-drive-api.DRIVE# * @property {string} description - Descrição da action * @property {string} description - Descrição breve da ação usada em listas automáticas * @property {string} params.filename - Nome do arquivo * @property {string} [params.encoding=\"utf-8\"] - Codificação do arquivo * @returns {string} Conteúdo do arquivo como string */ getContent: { description: \"Return content as string\", params: { filename: \"string\", encoding: { type: \"string\", optional: true, default: \"utf-8\" }, }, async handler(ctx) { return await this.storage .disk(\"s3\") .get(ctx.params.filename, ctx.params.encoding); }, }, /** * Ação para retornar o conteúdo de um arquivo como um fluxo (Stream) do armazenamento S3.&lt;/br&gt; * Ela recebe o nome do arquivo &lt;strong&gt;filename&lt;/strong&gt; e retorna o conteúdo do arquivo como um fluxo (Stream). * @summary Ação getStream * @action getStream * @memberof add-tools-drive-api.DRIVE# * @property {string} description - Descrição breve da ação usada em listas automáticas * @property {string} params.filename - Nome do arquivo * @returns {Stream} Conteúdo do arquivo como um fluxo (Stream) */ getStream: { description: \"Return content as Stream\", params: { filename: \"string\", }, async handler(ctx) { return await this.storage .disk(\"s3\") .getStream(ctx.params.filename); }, }, /** * Ação para deletar um arquivo. &lt;/br&gt; * Ela recebe o nome do arquivo &lt;strong&gt;filename&lt;/strong&gt; e retorna um booleano indicando se o arquivo foi deletado ou não. * @summary Ação delete * @action delete * @property {string} description - Descrição breve da ação usada em listas automáticas * @property {string} params.filename - Nome do arquivo * @returns {boolean} Retorna um booleano indicando se o arquivo foi deletado ou não * @memberof add-tools-drive-api.DRIVE# */ delete: { description: \"Delete file\", params: { filename: \"string\", }, async handler(ctx) { return await this.storage .disk(\"s3\") .delete(ctx.params.filename); }, }, }, /** * @desc Possui um canal para escutar um evento e criar uma pasta no S3 quando uma corporação é criada &lt;/br&gt; * &lt;strong&gt;\"corporation.created\"&lt;/strong&gt; * @summary channels * @memberof add-tools-drive-api.DRIVE# */ channels: { \"corporation.created\": async function (payload) { const ctx = payload?.ctx; if (!ctx) { throw new AddsonClientError( \"Context required\", 400, \"ERR_HAS_NO_CONTEXT\", ); } const filename = `${payload.corporation.CLIENT}/`.toUpperCase(); const fileContent = \"\"; const location = await this.actions.create( { filename, fileContent, }, { parentCtx: ctx }, ); }, }, }; × Search results Close "},"add-tools-drive-api_src_services_test_unit_DRIVE.service.spec.js.html":{"id":"add-tools-drive-api_src_services_test_unit_DRIVE.service.spec.js.html","title":"Source: add-tools-drive-api/src/services/test/unit/DRIVE.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-drive-api/src/services/test/unit/DRIVE.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../DRIVE.service\"); const { ValidationError } = require(\"moleculer\").Errors; const StorageManager = require('../../node_modules/storage/StorageManager'); /** * Testes para os serviços contidos em &lt;strong&gt;add-tools-ocr-api&lt;/strong&gt; * @namespace add-tools-drive-api.Testes */ /** * Este arquivo contém os testes para o serviço OCR * @namespace add-tools-drive-api.Testes.DRIVE */ /** * Bloco de testes do Serviço DRIVE */ describe(\"Testando serviço 'DRIVE'\", () =&gt; { let broker; let mockDisk; let mockCreate; beforeAll(() =&gt; { broker = new ServiceBroker({ logger: false }); broker.createService(service); return broker.start(); }); beforeEach(() =&gt; { // Limpa o mock para não interferir nos testes jest.clearAllMocks(); }); afterAll(() =&gt; { return broker.stop(); }); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço DRIVE deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-drive-api.Testes.DRIVE# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço DRIVE existe um código IDAPP. &lt;/br&gt; * O serviço DRIVE deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-drive-api.Testes.DRIVE# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes de todas as actions do Serviço DRIVE */ describe(\"Testando todas as actions do serviço 'DRIVE'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço DRIVE deve ter uma descrição breve, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-drive-api.Testes.DRIVE# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); /** * @desc Teste para verificar o parâmetro filename de todas as actions&lt;/br&gt; * Todas as actions do serviço DRIVE deve ter o parâmetro filename, que não pode ser opcional e deve ser do tipo string. * @summary Parâmetro filename * @test Parâmetro_Filename * @memberof add-tools-drive-api.Testes.DRIVE# */ test('Deveria ter o parâmetro não opcional filename do tipo string em cada ação', () =&gt; { Object.values(service?.actions).forEach((action) =&gt; { expect(action.params.filename).toBeDefined(); expect(action.params.filename).toBe(\"string\"); expect(action.params.filename).not.toBe(\"optional\"); }); }); /** * @desc Teste para verificar exceção de validação ao enviar parâmetros inválidos. &lt;/br&gt; * Todas as actions do serviço DRIVE devem lançar uma exceção de validação quando enviado o parâmetro filename de tipo diferente de string (number). * @summary Tipo de parâmetro inválido * @test Parâmetro_Inválido * @memberof add-tools-drive-api.Testes.DRIVE# */ test(\"Deveria lançar uma exceção de validação quando o filename for do tipo number\", async function () { const actions = ['create', 'getBase64', 'exists', 'getStat', 'getContent', 'getStream', 'delete']; actions.forEach(async (action) =&gt; { let resultado = null; try { resultado = await broker.call(`DRIVE.${action}`, { filename: 2, }); } catch (error) { resultado = error; } expect(resultado).toBeInstanceOf(ValidationError); }); }); /** * Bloco de testes para a action 'create' do Serviço DRIVE */ describe(\"Testando action 'create\", () =&gt; { /** * @desc Teste para verificar a chamada da função 'this.storage'. &lt;/br&gt; * A action create do serviço DRIVE deve chamar a função 'this.storage' com os parâmetros corretos e na ordem correta. * @summary Chamada da função this.storage * @test Chamada_thisStorage * @memberof add-tools-drive-api.Testes.DRIVE# */ test(\"Action 'create' deve chamar 'this.storage' com os parâmetros corretos e na ordem correta\", async () =&gt; { // Configuração do mock da função create que recebe o nome do arquivo e o conteúdo do arquivo mockCreate = jest.fn(); mockStream = jest.fn(); // Configuração do mock da função disk que recebe o nome do disco e chama a função create mockDisk = jest.fn(() =&gt; ({ create: mockCreate, getStream: mockStream })); // Substitui a função chamada 'disk' que faz parte da classe StorageManager pelo mockDisk StorageManager.prototype.disk = mockDisk; await broker.call(\"DRIVE.create\", { filename: 'testFile.txt', fileContent: 'Conteúdo do arquivo testFile.txt' }); expect(mockDisk).toHaveBeenCalledWith('s3'); expect(mockDisk).toHaveBeenCalledTimes(1); expect(mockCreate).toHaveBeenCalledWith((expect.any(String)), (expect.any(String))); expect(mockCreate).toHaveBeenCalledTimes(1); mockDisk = mockDisk.mock.invocationCallOrder[0]; mockCreate = mockCreate.mock.invocationCallOrder[0]; expect(mockDisk).toBeLessThan(mockCreate); // expect(mockDisk).toHaveBeenCalledBefore(mockCreate); // estudar usar cenários com mock function }); }); /** * Bloco de testes para a action getBase64 do Serviço DRIVE */ }); }); × Search results Close "},"add-tools-http-api_src_services_HTTP.service.js.html":{"id":"add-tools-http-api_src_services_HTTP.service.js.html","title":"Source: add-tools-http-api/src/services/HTTP.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-http-api/src/services/HTTP.service.js \"use strict\"; const path = require(\"path\"); const HTTPClientService = require(\"moleculer-http-client\"); const { AddsonServerError } = require(\"add-base-utils-lib/libs/customErrors\"); const _ = require(\"lodash\"); const got = require(\"got\"); var httpError = (error) =&gt; { const { response } = error; // Not a HTTP Error /* istanbul ignore next */ if (!response) { return new MoleculerHTTPClientError( `Moleculer HTTP Client Error.`, error, ); } const parsedError = { message: error.message, method: response.req &amp;&amp; response.req.method ? response.req.method : undefined, url: response.url, statusCode: response.statusCode, // stack: error.stack }; return new MoleculerHTTPClientError( `Moleculer HTTP Client Error.`, parsedError, ); }; class MoleculerHTTPClientError extends AddsonServerError { constructor(msg, data) { super(msg, 500, \"MOLECULER_HTTP_CLIENT_ERROR\", data); } } /** * @namespace {object} add-tools-http-api */ /** * O Serviço de HTTP é usado para fazer solicitações HTTP e lidar com erros e respostas de uma maneira específica. &lt;/br&gt; * @namespace add-tools-http-api.HTTP * @property {string} name - Nome do serviço * @property {array} mixins - Mixins do serviço: &lt;strong&gt;HTTPClientService&lt;/strong&gt; * @property {object} metadata - Usado para armazenar qualquer metadados do serviço * Estas informações podem ser acessadas via this.metadata e são transferidas para outros nós durante a chamada * @property {string} metadata.$description - Descrição breve do serviço usada em listas automáticas * @property {object} settings - Configurações internas do serviço * @property {string} settings.IDAPP - ID do APP que pode ser usado em permissões * @property {object} settings.httpClient - Configurações do cliente HTTP, valor booleano que indica se a solicitação deve ser registrada ou não. */ module.exports = { name: \"HTTP\", mixins: [HTTPClientService], metadata: { $description: \"HTTP Client\" }, settings: { IDAPP: `${/\\add-\\w*-\\w*-api(?!.*\\add-\\w*-\\w*-api)/.exec(__dirname)}`, // HTTP client settings httpClient: { // Boolean value indicating whether request should be logged or not - GOT Options logging: true, errorFormatter: httpError, responseFormatter: (response) =&gt; ({ body: response.body, headers: response.headers, statusCode: response.statusCode, statusMessage: response.statusMessage, }), }, }, /** * @desc created é um dos métodos do ciclo de vida do serviço no Moleculer. Ele é chamado uma vez, quando o serviço é criado. &lt;/br&gt; * Aqui, ele está configurando um cliente HTTP personalizado para o serviço, com opções para registro e formatação de resposta. O cliente é então armazenado no serviço para uso posterior. * @method created * @memberof add-tools-http-api.HTTP# */ created() { // Add Logging functions Got's default options const { defaultOptions } = this.settings.httpClient; if (this.settings.httpClient.logging) { defaultOptions.logger = this.logger; defaultOptions.logIncomingResponse = this.settings.httpClient.logIncomingResponse; defaultOptions.logOutgoingRequest = this.settings.httpClient.logOutgoingRequest; } // Set Response formatting function const { responseFormatter } = this.settings.httpClient; if (_.isFunction(responseFormatter)) { defaultOptions.responseFormatter = responseFormatter; } else { defaultOptions.responseFormatter = (response) =&gt; response; } /** * @type {GotInstance} */ this._client = got.extend(defaultOptions); }, }; × Search results Close "},"add-tools-http-api_src_services_test_unit_HTTP.service.spec.js.html":{"id":"add-tools-http-api_src_services_test_unit_HTTP.service.spec.js.html","title":"Source: add-tools-http-api/src/services/test/unit/HTTP.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-http-api/src/services/test/unit/HTTP.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../HTTP.service\"); const { ValidationError } = require(\"moleculer\").Errors; const { AddsonServerError, AddsonClientError } = require(\"add-base-utils-lib/libs/customErrors\"); const Settings = require(\"./cenarios/Settings\"); /** * Testes para os serviços contidos em &lt;strong&gt;add-tools-ocr-api&lt;/strong&gt; * @namespace add-tools-http-api.Testes */ /** * Este arquivo contém os testes para o serviço HTTP * @namespace add-tools-http-api.Testes.HTTP */ /** * Bloco de testes do Serviço HTTP */ describe(\"Testando serviço 'HTTP'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start(), 180000); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço HTTP deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-http-api.Testes.HTTP# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço HTTP existe um código IDAPP. &lt;/br&gt; * O serviço HTTP deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-http-api.Testes.HTTP# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); }); × Search results Close "},"add-tools-mail-api_src_services_mail-portal.service.js.html":{"id":"add-tools-mail-api_src_services_mail-portal.service.js.html","title":"Source: add-tools-mail-api/src/services/mail-portal.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-mail-api/src/services/mail-portal.service.js \"use strict\"; const path = require(\"path\"); /** * @namespace {object} add-tools-mail-api */ /** * O Serviço de MailPortal faz ... &lt;/br&gt; * @namespace add-tools-mail-api.mail-portal * @property {string} name - Nome do serviço * @property {object} metadata - Metadados do serviço * @property {object} settings - Configurações do serviço * @property {object} actions - Ações do serviço: (&lt;strong&gt;send&lt;/strong&gt;) */ module.exports = { name: \"MAIL-PORTAL\", metadata: { $description: \"Envio de Email: Portal de Documentos\" }, settings: { IDAPP: `${/\\add-\\w*-\\w*-api(?!.*\\add-\\w*-\\w*-api)/.exec(__dirname)}`, }, /** * @summary Actions do serviço * @property {object} send - Action send {@link add-tools-mail-api.mail-portal#send action send} * @memberof add-tools-mail-api.mail-portal# */ actions: { /** * @A ação send ... * @summary Ação send * @action send * @memberof add-tools-mail-api.mail-portal# * @property {string} rest - Rota da action * @property {string} description - Descrição da action * @property {object} params - Parâmetros da action * @property {string} [params.language=\"pt-BR\"] - Idioma do email * @property {string} params.to - Email do destinatário * @property {string} params.subject - Assunto do email * @property {string} [params.app=\"Portal de Documentos\"] - Nome do app * @property {string} [params.title=\"Recebimento de Arquivos\"] - Título do email * @property {object} [params.info] - Informações do email * @property {array} [params.attachments] - Anexos do email * @property {string} params.attachments.filename - Nome do anexo, neste caso não pode ser vazio * @property {string} params.attachments.content - Conteúdo do anexo, neste caso é um base64 e não pode ser vazio * @property {string} [params.attachments.encoding=\"base64\"] - Codificação do anexo */ send: { rest: \"/mail-portal\", description: \"Envio de Email: Portal de documentos\", params: { language: { type: \"string\", optional: true, default: \"pt-BR\" }, to: { type: \"email\" }, subject: { type: \"string\" }, app: { type: \"string\", optional: true, default: \"Portal de Documentos\", }, title: { type: \"string\", optional: true, default: \"Recebimento de Arquivos\", }, info: { type: \"object\", optional: true, }, attachments: { type: \"array\", optional: true, items: { type: \"object\", props: { filename: { type: \"string\", empty: false }, content: { type: \"string\", base64: true, empty: false, }, encoding: { type: \"string\", optional: true, default: \"base64\", }, }, }, }, }, async handler(ctx) { const info = []; if (ctx.params?.info) for (const [key, value] of Object.entries(ctx.params.info)) { info.push({ key: key, value: value, }); }; const mail = await ctx.call(\"MAIL.send\", { from: \"addplatform@addvisor.com.br\", to: ctx.params.to, subject: ctx.params.subject, template: ctx.params.template || \"portal\", language: ctx.params.language, data: { user: ctx.meta.user.id, subject: ctx.params.subject, app: ctx.params.app, title: ctx.params.title, ano: new Date().getFullYear(), info }, attachments: ctx.params.attachments, }); if (mail.messageId) { return `Email enviado: ${mail.messageId}`; } else { return `Houve algum erro no envio: ${mail}`; } }, }, }, }; × Search results Close "},"add-tools-mail-api_src_services_mail-welcome.service.js.html":{"id":"add-tools-mail-api_src_services_mail-welcome.service.js.html","title":"Source: add-tools-mail-api/src/services/mail-welcome.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-mail-api/src/services/mail-welcome.service.js \"use strict\"; const path = require(\"path\"); /** * @desc O Serviço de MailWelcome faz ... &lt;/br&gt; * @namespace add-tools-mail-api.mail-welcome * @memberof add-tools-mail-api * @property {string} name - Nome do serviço * @property {object} metadata - Metadados do serviço * @property {object} settings - Configurações do serviço * @property {object} actions - Ações do serviço: (&lt;strong&gt;send&lt;/strong&gt;) */ module.exports = { name: \"MAIL-WELCOME\", metadata: { $description: \"Envio de Email: Welcome\" }, settings: { IDAPP: `${/\\add-\\w*-\\w*-api(?!.*\\add-\\w*-\\w*-api)/.exec(__dirname)}`, }, /** * @summary actions * @property {object} send - Action send {@link add-tools-mail-api.mail-welcome#send action send} * @memberof add-tools-mail-api.mail-welcome# */ actions: { /** * @desc A ação send ... * @summary Action send * @action send * @memberof add-tools-mail-api.mail-welcome# * @property {string} rest - Rota da action * @property {string} description - Descrição da action * @property {object} params - Parâmetros da action * @property {string} params.user - Nome do usuário * @property {string} params.email - Email do usuário * @property {string} [params.language=\"pt-BR\"] - Idioma do email * @property {object} params.modules - Módulos... * @property {string[]} params.modules.type - Tipo de módulos, deve ser um array de strings * @property {string[]} params.modules.enum - Lista de módulos possíveis: \"nfe\", \"nfse\", \"cte\", \"mde\" * @returns {string} - Retorna uma mensagem de sucesso */ send: { rest: \"/mail-welcome\", description: \"Envio de Email: Welcome\", params: { user: { type: \"string\" }, email: { type: \"email\" }, language: { type: \"string\", optional: true, default: \"pt-BR\" }, modules: { type: \"array\", items: { type: \"string\" }, enum: [\"nfe\", \"nfse\", \"cte\", \"mde\"], }, }, async handler(ctx) { await ctx.call(\"MAIL.send\", { from: \"contato@smartdocx.com.br\", to: ctx.params.email, template: \"welcome\", language: ctx.params.language, data: { user: ctx.params.user, modules: ctx.params.modules, }, attachments: [ { // utf-8 string as an attachment filename: \"bemvindo.txt\", content: \"Bem vindo!\", }, ], }); return \"Email enviado\"; }, }, }, }; × Search results Close "},"add-tools-mail-api_src_services_mail.service.js.html":{"id":"add-tools-mail-api_src_services_mail.service.js.html","title":"Source: add-tools-mail-api/src/services/mail.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-mail-api/src/services/mail.service.js \"use strict\"; const MailService = require(\"moleculer-mail\"); const path = require(\"path\"); const MAILTRAP = { host: \"sandbox.smtp.mailtrap.io\", port: 2525, auth: { user: \"0f90dc5ad43818\", pass: \"947f046b090822\", }, }; const SES = { host: process.env.SES_SMTP, port: 465, auth: { user: process.env.SES_USER, pass: process.env.SES_PASS, }, }; /** * @desc O Serviço de MailService faz ... &lt;/br&gt; * @namespace add-tools-mail-api.mail * @memberof add-tools-mail-api * @property {string} name - Nome do serviço * @property {object} metadata - Metadados do serviço * @property {object} settings - Configurações do serviço * @property {object} settings - Configurações do serviço * @instance */ module.exports = { name: \"MAIL\", metadata: { $description: \"Envio de E-mails\" }, mixins: [MailService], settings: { IDAPP: `${/\\add-\\w*-\\w*-api(?!.*\\add-\\w*-\\w*-api)/.exec(__dirname)}`, from: \"addplatform@addvisor.com.br\", transport: SES, templateFolder: path.join(__dirname, \"templates\"), }, }; × Search results Close "},"add-tools-mail-api_src_services_test_unit_mail-portal.service.spec.js.html":{"id":"add-tools-mail-api_src_services_test_unit_mail-portal.service.spec.js.html","title":"Source: add-tools-mail-api/src/services/test/unit/mail-portal.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-mail-api/src/services/test/unit/mail-portal.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../mail-portal.service\"); const { ValidationError } = require(\"moleculer\").Errors; const { AddsonServerError, AddsonClientError } = require(\"add-base-utils-lib/libs/customErrors\"); /** * Testes para os serviços contidos em &lt;strong&gt;add-tools-mail-api&lt;/strong&gt; * @namespace add-tools-mail-api.Testes */ /** * Este arquivo contém os testes para o serviço mail-portal * @namespace add-tools-mail-api.Testes.mail-portal */ /** * Bloco de testes do Serviço MailPortal */ describe(\"Testando serviço 'MailPortal'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start(), 180000); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço MailPortal deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-mail-api.Testes.mail-portal# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço MailPortal existe um código IDAPP. &lt;/br&gt; * O serviço MailPortal deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-mail-api.Testes.mail-portal# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço MailPortal */ describe(\"Testando actions do serviço 'MailPortal'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço MailPortal deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-mail-api.Testes.mail-portal# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); }); }); × Search results Close "},"add-tools-mail-api_src_services_test_unit_mail-welcome.service.spec.js.html":{"id":"add-tools-mail-api_src_services_test_unit_mail-welcome.service.spec.js.html","title":"Source: add-tools-mail-api/src/services/test/unit/mail-welcome.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-mail-api/src/services/test/unit/mail-welcome.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../mail-welcome.service\"); const { ValidationError } = require(\"moleculer\").Errors; const { AddsonServerError, AddsonClientError } = require(\"add-base-utils-lib/libs/customErrors\"); /** * Este arquivo contém os testes para o serviço mail-welcome * @namespace add-tools-mail-api.Testes.mail-welcome */ /** * Bloco de testes do Serviço MailWelcome */ describe(\"Testando serviço 'MailWelcome'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start(), 180000); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço MailWelcome deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-mail-api.Testes.mail-welcome# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço MailWelcome existe um código IDAPP. &lt;/br&gt; * O serviço MailWelcome deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-mail-api.Testes.mail-welcome# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço MailWelcome */ describe(\"Testando actions do serviço 'MailWelcome'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço MailWelcome deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-mail-api.Testes.mail-welcome# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); }); }); × Search results Close "},"add-tools-mail-api_src_services_test_unit_mail.service.spec.js.html":{"id":"add-tools-mail-api_src_services_test_unit_mail.service.spec.js.html","title":"Source: add-tools-mail-api/src/services/test/unit/mail.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-mail-api/src/services/test/unit/mail.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../mail.service\"); const { ValidationError } = require(\"moleculer\").Errors; const { AddsonServerError, AddsonClientError } = require(\"add-base-utils-lib/libs/customErrors\"); /** * Este arquivo contém os testes para o serviço mail * @namespace add-tools-mail-api.Testes.mail */ /** * Bloco de testes do Serviço MailService */ describe(\"Testando serviço 'MailService'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start(), 180000); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço MailService deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-mail-api.Testes.mail# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço MailService existe um código IDAPP. &lt;/br&gt; * O serviço MailService deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-mail-api.Testes.mail# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço MailService */ describe(\"Testando actions do serviço 'MailService'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço MailService deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-mail-api.Testes.mail# */ test.todo(\"Deveria ter uma descrição breve em cada ação\"); // function () { // Object.values(service?.actions).forEach((action) =&gt; { // expect(action.description).toEqual(expect.any(String)); // }); // }); }); }); × Search results Close "},"add-tools-ocr-api_src_services_OCR.service.js.html":{"id":"add-tools-ocr-api_src_services_OCR.service.js.html","title":"Source: add-tools-ocr-api/src/services/OCR.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-ocr-api/src/services/OCR.service.js const tesseract = require(\"node-tesseract-ocr\"); const { AddsonServerError } = require(\"add-base-utils-lib/libs/customErrors\"); const sharp = require(\"sharp\"); const im = require(\"gm\").subClass({ imageMagick: true }); const fs = require(\"fs\"); const path = require(\"path\"); const { promises } = require(\"dns\"); /** * @namespace {object} add-tools-ocr-api */ /** * O Serviço de OCR faz o Reconhecimento Óptico de Caracteres em imagens e PDFs. &lt;/br&gt; * Ele tem duas ações principais: img e pdf. &lt;/br&gt; * Ele também tem um hook before para a ação img que verifica o template a ser utilizado no OCR. &lt;/br&gt; * Se nenhum template for especificado, o template 1 é usado por padrão. * @namespace add-tools-ocr-api.OCR * @property {string} name - Nome do serviço * @property {object} metadata - Usado para armazenar qualquer metadados do serviço * Estas informações podem ser acessadas via this.metadata e são transferidas para outros nós durante a chamada * @property {string} metadata.$description - Descrição breve do serviço usada em listas automáticas * @property {object} settings - Configurações internas do serviço * @property {string} settings.IDAPP - ID do APP que pode ser usado em permissões * @property {boolean} settings.MONETIZATION - Se estiver marcado, o usuário precisa ter um contrato para chamar este serviço */ module.exports = { name: \"OCR\", metadata: { $description: \"OCR - Optical Character Recognition\" }, settings: { IDAPP: `${/add-\\w*-\\w*-api(?!.*add-\\w*-\\w*-api)/.exec(__dirname)}`, MONETIZATION: true, }, /** * O serviço OCR possui hooks * @summary Hooks do Serviço de OCR * @property {object} before - Executado antes da chamada da ação * @property {array} before.img - {@link add-tools-ocr-api.OCR#metodoTeste Lista de funções executadas antes da ação img} * @memberof add-tools-ocr-api.OCR# * @see {@link add-tools-ocr-api.OCR#getTemplate methods getTemplate} */ hooks: { before: { img: [this.getTemplate], }, }, /** * @summary Actions do serviço * @property {object} img - Processa arquivos com formato de imagem {@link add-tools-ocr-api.OCR#img action img} * @property {object} pdf - Tenta chamar a action text do Serviço PDF {@link add-tools-ocr-api.OCR#pdf action pdf} * @memberof add-tools-ocr-api.OCR# */ actions: { /** * A ação img recebe uma imagem (como uma URL, um caminho de arquivo ou um buffer) e retorna o texto contido nela. &lt;/br&gt; * A imagem pode ser pré-processada antes do OCR, incluindo: a conversão para escala de cinza, redimensionamento, aplicação de um limite e a extensão da imagem. * @summary Ação img * @action img * @memberof add-tools-ocr-api.OCR# * @property {string} description - Descrição breve da ação usada em listas automáticas * @property {string} rest - Rota da ação: \"POST /\" * @property {object} params - Parâmetros da ação * @property {string} [params.input] - Imagem a ser processada. Pode ser no formato de URL, um caminho para o filesystem ou um buffer * @property {string} [params.base64] - Imagem a ser processada no formato base64 * @property {number} [params.resize] - Tamanho que a imagem será redimensionada * @property {boolean} [params.removeBorder=false] - Remove bordas da imagem no formato de tabela * @property {object} [params.config] - Configurações do OCR * @property {array} [permissions] - Permissões da ação. Se estiver preenchido, o usuário precisa ter todas as permissões listadas para executar * @returns {object} Retorna um objeto com uma única propriedade result, que contém o texto extraído da imagem * @throws {AddsonServerError} ERR_OCR_IMG - Erro no servidor OCR */ img: { description: \"Send image file to OCR\", rest: \"POST /\", params: { input: { // URL ou Path ou Buffer type: \"string\", optional: true, }, base64: { type: \"string\", base64: true, optional: true }, // Img Base64 resize: { type: \"number\", optional: true }, removeBorder: { type: \"boolean\", optional: true, default: false, }, config: { type: \"object\", optional: true, }, }, permissions: [\"add-tools-ocr-api\", \"ORG\"], async handler(ctx) { try { let preProcess; if (ctx.params.base64) { let buf = Buffer.from(ctx.params.base64, \"base64\"); ctx.params.input = buf; ctx.locals.file = path.join(__dirname, \"original.png\"); await fs.promises.writeFile( ctx.locals.file, ctx.params.input, ); // Pre Processing Image Buffer if (ctx?.params?.removeBorder) { await new Promise((resolve, reject) =&gt; { im(buf) .type(\"Grayscale\") .negative(true) .compose(\"darken\") // .define(\"morphology:compose=darken\") .out( \"-morphology\", \"Thinning\", \"Rectangle:1x20+0+0\", ) .out( \"-morphology\", \"Thinning\", \"Rectangle:20x1+0+0\", ) .negative(true) .toBuffer(\"PNG\", async (err, buffer) =&gt; { if (err) reject(err); buf = buffer; resolve(); }); }); } preProcess = await sharp(buf); if (ctx?.params?.greyscale) { preProcess = preProcess.greyscale(); } if (ctx?.params?.resize) { preProcess = preProcess.resize({ height: ctx?.params?.resize, }); } if (ctx?.params?.threshold) { preProcess = preProcess.threshold( ctx?.params?.threshold, { greyscale: true }, ); } if (ctx?.params?.extend) { preProcess = preProcess.extend({ top: 20, bottom: 20, left: 20, right: 20, background: { r: 255, g: 255, b: 255, alpha: 1, }, }); } const imageAfterProcess = await preProcess .png() .toBuffer(); ctx.locals.file2 = path.join(__dirname, \"final.png\"); await fs.promises.writeFile( ctx.locals.file2, imageAfterProcess, ); ctx.params.input = imageAfterProcess; } const text = await tesseract.recognize( ctx.params.input, ctx.params.config, ); return { result: text }; } catch (error) { throw new AddsonServerError( \"OCR Server Error\", 500, \"ERR_OCR_IMG\", { IDAPP: ctx.params.IDAPP, ACTION: ctx.action.name, ERROR: JSON.stringify(error), }, ); } }, openapi: { responses: { 200: { description: \"OCR processado com sucesso\", content: { \"application/json\": { schema: { type: \"object\", }, }, }, }, }, requestBody: { content: { \"application/json\": { examples: { URLSP: { summary: \"URL SP\", value: { MANDT: \"ADD-0001\", input: \"https://i.pinimg.com/originals/bb/91/05/bb9105aaea7d24e5f4449c46257d3b64.gif\", }, }, URLRJ: { summary: \"URL RJ\", value: { MANDT: \"ADD-0001\", input: \"https://wiki.dealernet.com.br/images/c/c4/Modelorps4.jpg\", }, }, }, }, }, }, }, }, /** * @desc A ação pdf tenta chamar o serviço \"PDF.text\" {@link @link add-tools-ocr-api.PDF#text PDF.text} com os parâmetros fornecidos no contexto (ctx.params). &lt;/br&gt; * O resultado dessa chamada (que é uma Promise) é aguardado e o valor resolvido é armazenado na variável text. &lt;/br&gt; * Se a chamada ao serviço \"PDF.text\" for bem-sucedida, a função retorna um objeto com uma única propriedade result, que contém o texto extraído do serviço \"PDF.text\". * @summary Action pdf * @action pdf * @memberof add-tools-ocr-api.OCR# * @property {string} description - Descrição breve da ação usada em listas automáticas * @property {string} rest - Rota da ação * @property {object} params - Parâmetros da ação: \"POST /\" * @property {string} [params.fileName] - nome do arquivo PDF a ser processado * @property {string} [params.base64] - PDF a ser processado codificado em formato base64 * @property {string} [params.type=\"ocr\"] - Tipo de processamento do PDF, pode ser \"text\" ou \"ocr\", mas \"ocr\" é o padrão. * @property {array} permissions - Permissões da ação. Se estiver preenchido, o usuário precisa ter todas as permissões listadas para executar * @returns {object} Retorna um objeto com uma única propriedade result, que contém o texto extraído do PDF * @throws {AddsonServerError} ERR_OCR_PDF - Erro no servidor OCR */ pdf: { description: \"Send pdf file to OCR\", rest: \"POST /\", params: { fileName: { type: \"string\", optional: true, }, base64: { type: \"string\", base64: true, optional: true }, type: { type: \"string\", optional: true, default: \"ocr\", enum: [\"text\", \"ocr\"], }, }, permissions: [\"add-tools-ocr-api\", \"ORG\"], async handler(ctx) { try { const text = await ctx.call(\"PDF.text\", ctx.params); return { result: text }; } catch (error) { throw new AddsonServerError( \"OCR Server Error\", 500, \"ERR_OCR_PDF\", { IDAPP: ctx.params.IDAPP, ACTION: ctx.action.name, }, ); } }, openapi: { responses: { 200: { description: \"PDF processado com sucesso\", content: { \"application/json\": { schema: { type: \"object\", }, }, }, }, }, }, }, }, methods: { /** * Função para verificar o template a ser utilizado no OCR. &lt;/br&gt; * Caso não seja informado um template, o template 1 é utilizado por padrão. * @function getTemplate * @param {object} ctx - Contexto da requisição * @memberof add-tools-ocr-api.OCR# */ getTemplate(ctx) { switch (ctx?.params?.config?.template) { default: case 1: ctx.params.config = { lang: \"eng+por\", oem: 3, psm: 6, textord_heavy_nr: 1, tessedit_char_blacklist: \"]\", }; // ctx.params.resize = ctx.params.resize || 1200; break; case 2: ctx.params.config = { lang: \"eng+por\", oem: 3, psm: 4, textord_heavy_nr: 1, }; // ctx.params.resize = ctx.params.resize || 1270; // ctx.params.threshold = ctx.params.threshold || 160; break; } }, }, }; × Search results Close "},"add-tools-ocr-api_src_services_PDF.service.js.html":{"id":"add-tools-ocr-api_src_services_PDF.service.js.html","title":"Source: add-tools-ocr-api/src/services/PDF.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-ocr-api/src/services/PDF.service.js const pdfExtract = require(\"pdf-extract\"); const { AddsonServerError } = require(\"add-base-utils-lib/libs/customErrors\"); const path = require(\"path\"); const fs = require(\"fs\"); /** * @desc O Serviço de PDF extrai texto de arquivos PDF.&lt;/br&gt; * O Serviço tem uma ação principal: text. &lt;/br&gt; * Ele também tem um método &lt;strong&gt;extractText()&lt;/strong&gt; que recebe o caminho para o arquivo PDF e o tipo de processamento. * @namespace add-tools-ocr-api.PDF * @memberof add-tools-ocr-api * @property {string} name - Nome do serviço * @todo @property {number} version - Versão do serviço * @property {array} mixins - Usado para distribuir funcionalidades reutilizáveis para os serviços * @property {object} metadata - Usado para armazenar qualquer metadados do serviço * @property {string} metadata.$description - Descrição breve do serviço usada em listas automáticas * @property {object} settings - Configurações internas do serviço * @property {string} settings.IDAPP - ID do APP que pode ser usado em permissões * @todo @property {boolean} settings.rest - Se estiver marcado, o serviço será acessível via REST */ module.exports = { name: \"PDF\", // version: 1, mixins: [], metadata: { $description: \"Extract text from PDF\" }, settings: { IDAPP: `${/add-\\w*-\\w*-api(?!.*\\\\add-\\w*-\\w*-api)/.exec(__dirname)}`, // rest: true }, /** * @summary Actions do serviço * @property {object} text - Processa arquivos com formato PDF {@link add-tools-ocr-api.PDF#text action text} * @memberof add-tools-ocr-api.PDF# * @instance */ actions: { /** * @desc A ação text recebe um arquivo PDF (como uma string base64) e um tipo de processamento (\"text\" ou \"ocr\"). &lt;/br&gt; * Se o tipo de processamento não for especificado, será definido \"text\" por padrão. &lt;/br&gt; * A ação salva o arquivo PDF, extrai o texto dele usando o método &lt;strong&gt;extractText()&lt;/strong&gt;, e retorna o texto extraído. &lt;/br&gt; * Se ocorrer um erro durante este processo, um erro de servidor é lançado. * @summary Ação text * @action text * @memberof add-tools-ocr-api.PDF# * @property {string} description - Descrição da action * @property {string} rest - Rota da action: \"POST /\" * @property {object} params - Parâmetros da action * @property {string} [params.fileName] - Nome do arquivo a ser processado * @property {string} params.base64 - PDF a ser processado codificado em formato base64 * @property {string} [params.type=\"text\"] - Tipo de processamento do PDF (text ou ocr) * @returns {string} Retorna o texto extraído do PDF * @throws {AddsonServerError} - ERR_PDF_TEXT - Erro no servidor OCR */ text: { description: \"PDF to Text\", rest: \"POST /\", params: { fileName: { type: \"string\", optional: true, }, base64: { type: \"string\", base64: true }, type: { type: \"string\", optional: true, default: \"text\", enum: [\"text\", \"ocr\"], }, }, async handler(ctx) { try { ctx.params.fileName = `${ctx.id}.pdf`; ctx.locals.file = path.join(__dirname, ctx.params.fileName); await fs.promises.writeFile( ctx.locals.file, ctx.params.base64, { encoding: \"base64\" }, ); ctx.locals.file = path.join(__dirname, ctx.params.fileName); const text = await this.extractText( ctx.locals.file, ctx.params.type, ); fs.unlink(ctx.locals.file, () =&gt; { // if (err) throw err; }); return text.text_pages; } catch (error) { throw new AddsonServerError( \"OCR Server Error\", 500, \"ERR_PDF_TEXT\", { IDAPP: ctx.params.IDAPP, ACTION: ctx.action.name, TYPE: ctx.params.type, }, ); } }, openapi: { responses: { 200: { description: \"PDF processado com sucesso\", content: { \"application/json\": { schema: { type: \"object\", }, }, }, }, }, }, }, }, methods: { /** * A função &lt;strong&gt;extractText()&lt;/strong&gt; recebe como parâmetro o caminho para o arquivo PDF e o tipo de processamento. &lt;/br&gt; * Se o tipo de processamento for \"ocr\", ele usará o OCR para extrair o texto. * @summary Método para extração de texto * @function extractText * @param {string} filePath - Caminho para do aqruivo * @param {string} type - Tipo de processamento \"text\" ou \"ocr\" * @returns {string} - Texto extraído do PDF * @memberof add-tools-ocr-api.PDF# */ async extractText(filePath, type) { const absolutePathToPdf = path.resolve(filePath); const options = { type, // extract searchable text from PDF // ocr_flags: [\"-l por\", \"--oem 3\", \"--psm 3\", \"-c tessedit_char_whitelist=abcdefghijklmnopqrstuvwxyz\"], // ocr options ocr_flags: [ \"-l por\", \"--oem 3\", \"--psm 4\", // \"-c textord_heavy_nr=1\", ], // ocr options enc: \"UTF-16\", // optional, encoding to use for the text output clean: true, mode: \"layout\", // optional, mode to use when reading the pdf }; return new Promise((resolve, reject) =&gt; { const processor = pdfExtract( absolutePathToPdf, options, () =&gt; {}, ); processor.on(\"complete\", resolve); processor.on(\"error\", (err) =&gt; { reject(err); }); }); }, }, }; × Search results Close "},"add-tools-ocr-api_src_services_test_unit_OCR.service.spec.js.html":{"id":"add-tools-ocr-api_src_services_test_unit_OCR.service.spec.js.html","title":"Source: add-tools-ocr-api/src/services/test/unit/OCR.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-ocr-api/src/services/test/unit/OCR.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../OCR.service\"); const { ValidationError } = require(\"moleculer\").Errors; const { AddsonServerError, AddsonClientError } = require(\"add-base-utils-lib/libs/customErrors\"); const Settings = require(\"./cenarios/Settings\"); /** * Testes para os serviços contidos em &lt;strong&gt;add-tools-ocr-api&lt;/strong&gt; * @namespace add-tools-ocr-api.Testes */ /** * Este arquivo contém os testes para o serviço OCR * @namespace add-tools-ocr-api.Testes.OCR */ const settings = new Settings(); const cenarios = settings.getSettings(); /** * Bloco de testes do Serviço OCR */ describe(\"Testando serviço 'OCR'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start(), 180000); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço OCR deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-ocr-api.Testes.OCR# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço OCR existe um código IDAPP. &lt;/br&gt; * O serviço OCR deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-ocr-api.Testes.OCR# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço OCR */ describe(\"Testando ação 'img'\", () =&gt; { /** * @desc Teste para verificar se a descrição da action img está preenchida. &lt;/br&gt; * A action img do serviço OCR deve ter uma descrição breve, que aceita qualquer valor do tipo string. * @summary Descrição da action img * @test Descrição_Action * @memberof add-tools-ocr-api.Testes.OCR# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { expect(service?.actions?.[\"img\"].description).toEqual( expect.any(String) ); }); /** * Bloco de testes dos parâmetros da action img do Serviço OCR */ describe('Testando validação de parâmetros', () =&gt; { /** * @desc Teste para verificar a validação de parâmetro opcional para base64 da action img do Serviço OCR. &lt;/br&gt; * O parâmetro base64 da action img do serviço OCR deve ser opcional. * @summary Validação de parâmetro opcional * @test Base64_Opcional * @memberof add-tools-ocr-api.Testes.OCR# */ test(\"Deveria tratar o parâmetro base64 como opcional\", () =&gt; { expect(service?.actions?.[\"img\"]?.params?.base64?.optional).toEqual(true); }); /** * @desc Teste para verificar a exceção AddsonClientError ao enviar parâmetro input em branco. &lt;/br&gt; * Quando o parâmetro base64 da actiom img estiver em branco o parâmetro input da action img deve estar preenchido. * @summary Validação de parâmetro input * @test Input_Preenchido * @memberof add-tools-ocr-api.Testes.OCR# */ test(\"Deveria lançar uma exceção do tipo AddsonClientError se o parâmetro base64 e o input estiverem em branco\", async () =&gt; { let resultado = null; try { resultado = await broker.call(\"OCR.img\"); } catch (error) { resultado = error; } expect(resultado).toBeInstanceOf(AddsonClientError); }); }); /** * @desc Teste para verificar exceção de validação ao enviar parâmetros inválidos. &lt;/br&gt; * A action img do serviço OCR deve lançar uma exceção de validação quando enviado o parâmetro base64 inválido. * @summary Parâmetro base64 inválido * @test Parâmetro_Inválido * @memberof add-tools-ocr-api.Testes.OCR# */ test(\"Deveria lançar uma exceção de validação quando o base64 for inválido\", async function () { let resultado = null; try { resultado = await broker.call(\"OCR.img\", { base64: \"em9uaQ=\", }); } catch (error) { resultado = error; } expect(resultado).toBeInstanceOf(ValidationError); }); /** * @desc Teste para verificar exceção ao enviar um base64 que não é uma imagem. &lt;/br&gt; * A action img do serviço OCR deve lançar uma exceção ao enviar um base64 que não é uma imagem. * @summary Imagem inválida * @test Imagem_Inválida * @memberof add-tools-ocr-api.Testes.OCR# */ test(\"Deveria lançar uma exceção, pois o base64 não é uma imagem\", async function () { let resultado = null; try { await broker.call(\"OCR.img\", { base64: \"em9uaQ==\", }); } catch (error) { resultado = error; } expect(resultado).toBeInstanceOf(AddsonServerError); }); for (const cenario in cenarios) { const fields = cenarios[cenario].fields; let resultado = null; /** * Bloco de testes para os cenários do Serviço OCR */ describe(`Testando cenário: ${cenarios[cenario]?.name}`, () =&gt; { beforeAll(async () =&gt; { // jest.setTimeout(180 * 1000); resultado = await broker.call(\"OCR.img\", { input: cenarios[cenario].input, base64: cenarios[cenario].base64, resize: cenarios[cenario].resize, config: { template: cenarios[cenario].template, }, }); }, 180000); for (const field in fields) { if (fields[field].optional) { /** * @desc Teste deve ser pulado quando o campo for opcional. &lt;/br&gt; * Aqui sempre que o campo estiver marcado com 'opcional true', o teste deve ser pulado. * @summary Campos opcionais * @todo @function Campos_Opcionais_Serviço * @memberof add-tools-ocr-api.Testes.OCR# */ test.todo( `Deveria retornar ${fields[field].value} para o campo ${fields[field].name}` // async function () { // // const resultado = await broker.call(\"OCR.img\", { // // base64: cenarios[cenario].base64, // // }); // expect(resultado.result).toMatch( // fields[field].value // ); // } ); } else { /** * @desc Teste para verificar o valor dos campos de acordo com o nome dos campos. &lt;/br&gt; * Aqui o teste deve ser executado quando o campo não for opcional. * Este teste verifica cada campo que não está marcado como opcional e confirma se o valor do campo retornado está de acordo com o cenário. * @summary Valores dos campos * @test Campos_Serviço * @memberof add-tools-ocr-api.Testes.OCR# */ test(`Deveria retornar ${fields[field].value} para o campo ${fields[field].name}`, async function () { expect(resultado.result).toMatch( fields[field].value ); }); } } }); } }); }); × Search results Close "},"add-tools-ocr-api_src_services_test_unit_PDF.service.spec.js.html":{"id":"add-tools-ocr-api_src_services_test_unit_PDF.service.spec.js.html","title":"Source: add-tools-ocr-api/src/services/test/unit/PDF.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-ocr-api/src/services/test/unit/PDF.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../PDF.service\"); const { ValidationError } = require(\"moleculer\").Errors; const { AddsonServerError } = require(\"add-base-utils-lib/libs/customErrors\"); const Settings = require(\"./cenarios/Settings\"); const settings = new Settings(\"PDF\"); const cenarios = settings.getSettings(); /** * Este arquivo contém os testes para o serviço PDF * @namespace add-tools-ocr-api.Testes.PDF */ /** * Blocos de testes do Serviço PDF */ describe(\"Testando serviço 'PDF'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; { broker.start(); jest.setTimeout(30 * 1000); }); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço PDF deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do Serviço * @test Descrição_Serviço * @memberof add-tools-ocr-api.Testes.PDF# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", function () { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço PDF existe um código IDAPP. &lt;/br&gt; * O serviço PDF deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-ocr-api.Testes.PDF# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço PDF */ describe(\"Testando ação 'text'\", () =&gt; { /** * @desc Teste para verificar se a descrição da action text está preenchida. &lt;/br&gt; * A action text do serviço PDF deve ter uma descrição breve, que aceita qualquer valor do tipo string. * @summary Descrição da action text * @test Descrição_Action * @memberof add-tools-ocr-api.Testes.PDF# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { expect(service?.actions?.[\"text\"].description).toEqual( expect.any(String) ); }); /** * @desc Teste para verificar a exceção de validação para os parâmetros da action text do Serviço PDF. &lt;/br&gt; * O parâmetro base64 da action text do serviço PDF deve ser obrigatório. * @summary Validação de parâmetro obrigatório * @test Base64_Obrigatório * @memberof add-tools-ocr-api.Testes.PDF# */ test(\"Deveria lançar uma exceção de validação quando o parâmetro base64 estiver em branco\", async function () { let resultado = null; try { resultado = await broker.call(\"PDF.text\"); } catch (error) { resultado = error; } expect(resultado).toBeInstanceOf(ValidationError); }); /** * @desc Teste para verificar exceção de validação ao enviar parâmetros inválidos. &lt;/br&gt; * A action text do serviço PDF deve lançar uma exceção de validação quando enviado o parâmetro base64 inválido. * @summary Validação de parâmetro base64 * @test Base64_Inválido * @memberof add-tools-ocr-api.Testes.PDF# */ test(\"Deveria lançar uma exceção de validação quando o parâmetro base64 for inválido\", async function () { let resultado = null; try { resultado = await broker.call(\"PDF.text\", { base64: \"em9uaQ=\", }); } catch (error) { resultado = error; } expect(resultado).toBeInstanceOf(ValidationError); }); /** * @desc Teste para verificar exceção ao enviar um base64 que não é uma imagem. &lt;/br&gt; * A action text do serviço PDF deve lançar uma exceção ao enviar um base64 que não é uma imagem. * @summary Imagem inválida * @test Imagem_Inválida * @memberof add-tools-ocr-api.Testes.PDF# */ test(\"Deveria lançar uma exceção quando o base64 não for uma imagem\", async function () { let resultado = null; try { await broker.call(\"PDF.text\", { base64: \"em9uaQ==\", }); } catch (error) { resultado = error; } expect(resultado).toBeInstanceOf(AddsonServerError); }); for (const cenario in cenarios) { const fields = cenarios[cenario].fields; let resultado = null; /** * Bloco de testes para os cenários do Serviço OCR */ describe(`Testando cenário: ${cenarios[cenario]?.name}`, () =&gt; { beforeAll(async () =&gt; { // jest.setTimeout(180 * 1000); resultado = await broker.call(\"PDF.text\", { base64: cenarios[cenario].base64, resize: cenarios[cenario].resize, config: { template: cenarios[cenario].template, }, type: cenarios[cenario].type, }); }, 180000); for (const field in fields) { if (fields[field].optional) { /** * @desc Teste deve ser pulado quando o campo for opcional. &lt;/br&gt; * Aqui sempre que o campo estiver marcado com 'opcional true', o teste deve ser pulado. * @summary Campos opcionais * @todo @function Campos_Opcionais_Serviço * @memberof add-tools-ocr-api.Testes.PDF# */ test.todo( `Deveria retornar ${fields[field].value} para o campo ${fields[field].name}` // async function () { // // const resultado = await broker.call(\"OCR.img\", { // // base64: cenarios[cenario].base64, // // }); // expect(resultado.result).toMatch( // fields[field].value // ); // } ); } else { /** * @desc Teste para verificar o valor dos campos de acordo com o nome dos campos. &lt;/br&gt; * Aqui o teste deve ser executado quando o campo não for opcional. * Este teste verifica cada campo que não está marcado como opcional e confirma se o valor do campo retornado está de acordo com o cenário. * @summary Valores dos campos * @test Campos_Serviço * @memberof add-tools-ocr-api.Testes.PDF# */ test(`Deveria retornar ${fields[field].value} para o campo ${fields[field].name}`, async function () { expect(resultado[0]).toMatch(fields[field].value); }); } } }); } }); }); × Search results Close "},"add-tools-ocr-api_src_services_test_unit_cenarios_Settings.js.html":{"id":"add-tools-ocr-api_src_services_test_unit_cenarios_Settings.js.html","title":"Source: add-tools-ocr-api/src/services/test/unit/cenarios/Settings.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-ocr-api/src/services/test/unit/cenarios/Settings.js const fs = require(\"fs\"); const path = require(\"path\"); /** Cenários para testes unitários */ class Settings { /** * Construtor para classe base * @param {string} path - Diretório de cenários */ constructor(path = null) { this.path = path; } /** * Retorna os cenários configurados * @return {array} Cenários configurados */ getSettings() { const dirPath = this.path ? path.join(__dirname, this.path) : __dirname; try { return require(dirPath); } catch (error) { return console.log( \"Não foi possível acessar o diretório: \" + error ); } } } module.exports = Settings; × Search results Close "},"add-tools-platform-api_src_services_addplatform.service.js.html":{"id":"add-tools-platform-api_src_services_addplatform.service.js.html","title":"Source: add-tools-platform-api/src/services/addplatform.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-platform-api/src/services/addplatform.service.js const path = require(\"path\"); const fs = require(\"fs\"); const utilslib = require(\"add-base-utils-lib/libs/utils\"); /** * @namespace {object} add-tools-platform-api */ module.exports = { /** * O Serviço de addPlatform faz ... * @namespace add-tools-platform-api.addplatform * @memberof add-tools-platform-api * @property {string} name - Nome do serviço * @todo @property {number} version - Versão do serviço * @property {array} mixins - Mixins do serviço * @property {object} metadata - Metadados do serviço * @property {object} settings - Configurações do serviço * @property {object} actions - Ações do serviço: &lt;strong&gt;callJava&lt;/strong&gt; e &lt;strong&gt;callVersion&lt;/strong&gt; * @property {object} methods - Métodos do serviço: &lt;code&gt;createHash()&lt;/code&gt;, &lt;code&gt;getMailInfo()&lt;/code&gt;, &lt;code&gt;encodeBase64()&lt;/code&gt; e &lt;code&gt;decodeBase64()&lt;/code&gt; * @instance */ name: \"addplatform\", // version: 1, mixins: [], metadata: { $description: \"AddPlatform Java API\" }, settings: { IDAPP: `${/\\add-\\w*-\\w*-api(?!.*\\add-\\w*-\\w*-api)/.exec(__dirname)}`, rest: true, MONETIZATION: true, }, /** * @summary actions * @property {object} callJava - Executa API Java {@link add-tools-platform-api.addplatform#callJava action callJava} * @property {object} callVersion - Teste Versao {@link add-tools-platform-api.addplatform#callVersion action callVersion} * @memberof add-tools-platform-api.addplatform# */ actions: { /** * @desc A ação callJava ... * @summary Ação callJava * @action callJava * @memberof add-tools-platform-api.addplatform# * @property {string} description - Descrição da action * @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} [params.hash] - Hash da requisição * @property {array} permissions - Permissões da action */ callJava: { description: \"Executa API Java\", rest: \"POST /\", params: { hash: { type: \"string\", optional: true, }, }, permissions: [\"add-tools-platform-api\", \"ORG\"], async handler(ctx) { const addResponse = {}; try { // Procura maxBuffer em variavel de ambiente // Caso nao encontre aplica o valor máximo de 30MB // 30MB: 31457280 // 10MB 10485760 const maxBufferArg = process.env?.MAX_BUFFER ? process.env.MAX_BUFFER : 31457280; let hash = \"\"; let limitMailMessageSize = false; let maxMailMessageSize = 0; if (ctx.params.hash) hash = ctx.params.hash; else if (ctx.params?.operation &amp;&amp; ctx.params?.parameters) { if (ctx.params.parameters?.maxMailMessageSize) { limitMailMessageSize = true; maxMailMessageSize = parseInt( ctx.params.parameters.maxMailMessageSize, ); } hash = this.createHash(ctx.params); } else { addResponse.addPlatform = \"ERRO: Parametros insuficientes\"; return addResponse; } const callJarRequests = require(\"classes/callJar\"); const callJarInstance = new callJarRequests( hash, maxBufferArg, ); let response = await callJarInstance.execute(); if (limitMailMessageSize) { if (response.length &gt; maxMailMessageSize) { const mailInfo = this.getMailInfo(response); response = `&lt;ContextResponse&gt;&lt;context&gt;${mailInfo}&lt;/context&gt;&lt;statusInfo&gt;&lt;status&gt;false&lt;/status&gt;&lt;errorCode&gt;400&lt;/errorCode&gt;&lt;message&gt;Tamanho do retorno acima do esperado&lt;/message&gt;&lt;solution&gt;Remover e-mail da caixa&lt;/solution&gt;&lt;trace/&gt;&lt;/statusInfo&gt;&lt;/ContextResponse&gt;`; } } addResponse.addPlatform = response; } catch (err) { let exMsg = \"ERRO: Exception ao processar requisicao\"; try { exMsg = `ERRO: Exception ao processar requisicao - ${JSON.stringify( err, )}`; } catch (err2) {} addResponse.addPlatform = \"ERRO: Exception\"; addResponse.exception = exMsg; } if (!addResponse.addPlatform) addResponse.addPlatform = \"ERRO: Erro ao processar a requisicao\"; return addResponse; }, openapi: { responses: { 200: { description: \"API executada com sucesso\", content: { \"application/json\": { schema: { type: \"object\", }, }, }, }, }, }, }, /** * @desc A ação callVersion ... * @summary Ação callVersion * @action callVersion * @memberof add-tools-platform-api.addplatform# * @property {string} description - Descrição da action * @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} [params.hash] - Hash da requisição */ callVersion: { description: \"Teste Versao\", rest: \"POST /\", params: { hash: { type: \"string\", optional: true, }, }, async handler(ctx) { const addResponse = \"20230321-13h25 - TESTE002 - JORGE\"; return addResponse; }, openapi: { responses: { 200: { description: \"Testa Versao da aplicação\", content: { \"application/json\": { schema: { type: \"object\", }, }, }, }, }, }, }, }, methods: { /** * @desc O method &lt;code&gt;createHash()&lt;/code&gt; ... * @summary Método para ... * @method createHash * @memberof add-tools-platform-api.addplatform# * @param {object} params - Parâmetros do método * @returns {string} - Hash da requisição */ createHash(params) { const envelope = '&lt;?xml version=\"1.0\" encoding=\"iso-8859-1\"?&gt;&lt;asx:abap xmlns:asx=\"http://www.sap.com/abapxml\" version=\"1.0\"&gt;&lt;asx:values&gt;&lt;STAB&gt;&lt;CLASS&gt;br.com.addtax.facade.AddTaxFacade&lt;/CLASS&gt;&lt;METHOD&gt;@OPERATION@&lt;/METHOD&gt;&lt;PARAMETERS&gt;@PARAMETERS@&lt;/PARAMETERS&gt;&lt;/STAB&gt;&lt;/asx:values&gt;&lt;/asx:abap&gt;'; const envParam = \"&lt;_-ADD_-ES_JAVA_API_PARAM&gt;&lt;PARAMETER&gt;@PARAMETER@&lt;/PARAMETER&gt;&lt;VALUE&gt;@VALUE@&lt;/VALUE&gt;&lt;/_-ADD_-ES_JAVA_API_PARAM&gt;\"; let paramsStr = \"\"; if ( params.parameters &amp;&amp; Object.keys(params.parameters).length &gt; 0 ) { Object.keys(params.parameters).forEach(function (element) { let eachParam = envParam; eachParam = eachParam.replace(\"@PARAMETER@\", element); eachParam = eachParam.replace( \"@VALUE@\", params.parameters[element], ); paramsStr += eachParam; }); } let finalEnvelope = envelope; finalEnvelope = finalEnvelope.replace( \"@OPERATION@\", params.operation, ); finalEnvelope = finalEnvelope.replace(\"@PARAMETERS@\", paramsStr); const hash = this.encodeBase64(finalEnvelope); return hash; }, /** * @desc O method &lt;code&gt;getMailInfo()&lt;/code&gt; ... * @summary Método para ... * @method getMailInfo * @memberof add-tools-platform-api.addplatform# * @param {object} javaResponse - Parâmetros do método * @returns {string} - MailInfo */ getMailInfo(javaResponse) { if (javaResponse) { let mailInfoMessage = \"\"; try { if ( javaResponse.indexOf(\"&lt;context&gt;\") &gt; 0 &amp;&amp; javaResponse.indexOf(\"&lt;/context&gt;\") &gt; 0 ) { const responseCtx = javaResponse.substring( javaResponse.indexOf(\"&lt;context&gt;\") + 9, javaResponse.indexOf(\"&lt;/context&gt;\"), ); if (!this._zlib) this._zlib = require(\"zlib\"); const mailDecompress = this._zlib .gunzipSync(Buffer.from(responseCtx, \"base64\")) .toString(); mailInfoMessage = { mailSubject: \"\", mailSender: \"\", mailSize: \"\", mailId: \"\", }; mailInfoMessage.mailSubject = mailDecompress.substring( mailDecompress.indexOf(\"&lt;SUBJE&gt;\") + 7, mailDecompress.indexOf(\"&lt;/SUBJE&gt;\"), ); mailInfoMessage.mailSender = mailDecompress.substring( mailDecompress.indexOf(\"&lt;SENDE&gt;\") + 7, mailDecompress.indexOf(\"&lt;/SENDE&gt;\"), ); mailInfoMessage.mailDtEnv = mailDecompress.substring( mailDecompress.indexOf(\"&lt;DTENV&gt;\") + 7, mailDecompress.indexOf(\"&lt;/DTENV&gt;\"), ); mailInfoMessage.mailHrEnv = mailDecompress.substring( mailDecompress.indexOf(\"&lt;HRENV&gt;\") + 7, mailDecompress.indexOf(\"&lt;/HRENV&gt;\"), ); mailInfoMessage.mailSize = mailDecompress.substring( mailDecompress.indexOf(\"&lt;SIZEE&gt;\") + 7, mailDecompress.indexOf(\"&lt;/SIZEE&gt;\"), ); mailInfoMessage.mailId = mailDecompress.substring( mailDecompress.indexOf(\"&lt;IDEME&gt;\") + 7, mailDecompress.indexOf(\"&lt;/IDEME&gt;\"), ); mailInfoMessage = this.encodeBase64( JSON.stringify(mailInfoMessage), ); return mailInfoMessage; } } catch (err) { return \"\"; } } }, /** * @desc O method &lt;code&gt;encodeBase64()&lt;/code&gt; ... * @summary Método para ... * @method encodeBase64 * @memberof add-tools-platform-api.addplatform# * @param {object} str - Parâmetros do método * @returns {string} - string codificada em base64 */ encodeBase64(str) { return Buffer.from(str).toString(\"base64\"); }, /** * @desc O method &lt;code&gt;decodeBase64()&lt;/code&gt; ... * @summary Método para ... * @method decodeBase64 * @memberof add-tools-platform-api.addplatform# * @param {object} str - Parâmetros do método * @returns {string} - string decodificada */ decodeBase64(str) { return Buffer.from(str, \"base64\").toString(\"utf-8\"); }, }, }; × Search results Close "},"add-tools-platform-api_src_services_test_unit_addplatform.service.spec.js.html":{"id":"add-tools-platform-api_src_services_test_unit_addplatform.service.spec.js.html","title":"Source: add-tools-platform-api/src/services/test/unit/addplatform.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-platform-api/src/services/test/unit/addplatform.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../addplatform.service\"); const { ValidationError } = require(\"moleculer\").Errors; /** * Testes para os serviços contidos em &lt;strong&gt;add-tools-ocr-api&lt;/strong&gt; * @namespace add-tools-platform-api.Testes */ /** * Este arquivo contém os testes para o serviço addplatform * @namespace add-tools-platform-api.Testes.addplatform */ /** * Bloco de testes do Serviço addplatform */ describe(\"Testando serviço 'addPlatform'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start()); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço addplatform deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-platform-api.Testes.addplatform# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço addPlatform existe um código IDAPP. &lt;/br&gt; * O serviço addplatform deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-platform-api.Testes.addplatform# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço addPlatform */ describe(\"Testando actions do serviço 'addPlatform'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço addplatform deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-platform-api.Testes.addplatform# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); }); }); × Search results Close "},"add-tools-vault-api_src_services_test_unit_vault.service.spec.js.html":{"id":"add-tools-vault-api_src_services_test_unit_vault.service.spec.js.html","title":"Source: add-tools-vault-api/src/services/test/unit/vault.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-vault-api/src/services/test/unit/vault.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../vault.service\"); const { ValidationError } = require(\"moleculer\").Errors; /** * Testes para os serviços contidos em &lt;strong&gt;add-tools-vault-api&lt;/strong&gt; * @namespace add-tools-vault-api.Testes */ /** * Este arquivo contém os testes para o serviço vault * @namespace add-tools-vault-api.Testes.vault */ /** * Bloco de testes do Serviço vault */ describe(\"Testando serviço 'vault'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start()); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço vault deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-vault-api.Testes.vault# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço vault existe um código IDAPP. &lt;/br&gt; * O serviço vault deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-vault-api.Testes.vault# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço vault */ describe(\"Testando actions do serviço 'vault'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço vault deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-vault-api.Testes.vault# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); }); }); × Search results Close "},"add-tools-vault-api_src_services_test_unit_vaultapp.service.spec.js.html":{"id":"add-tools-vault-api_src_services_test_unit_vaultapp.service.spec.js.html","title":"Source: add-tools-vault-api/src/services/test/unit/vaultapp.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-vault-api/src/services/test/unit/vaultapp.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../vaultapp.service\"); const { ValidationError } = require(\"moleculer\").Errors; /** * Este arquivo contém os testes para o serviço vaultapp * @namespace add-tools-vault-api.Testes.vaultapp */ /** * Bloco de testes do Serviço vaultapp */ describe(\"Testando serviço 'vaultapp'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start()); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço vaultapp deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-vault-api.Testes.vaultapp */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço vaultapp existe um código IDAPP. &lt;/br&gt; * O serviço vaultapp deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-vault-api.Testes.vaultapp */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço vaultapp */ describe(\"Testando actions do serviço 'vaultapp'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço vaultapp deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-vault-api.Testes.vaultapp */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); }); }); × Search results Close "},"add-tools-vault-api_src_services_test_unit_vaultcommunication.service.spec.js.html":{"id":"add-tools-vault-api_src_services_test_unit_vaultcommunication.service.spec.js.html","title":"Source: add-tools-vault-api/src/services/test/unit/vaultcommunication.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-vault-api/src/services/test/unit/vaultcommunication.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../vaultcommunication.service\"); const { ValidationError } = require(\"moleculer\").Errors; /** * Este arquivo contém os testes para o serviço vaultapp * @namespace add-tools-vault-api.Testes.vaultCommunication */ /** * Bloco de testes do Serviço vaultCommunication. */ describe(\"Testando serviço 'vaultCommunication.'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start()); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço vaultCommunication. deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-vault-api.Testes.vaultCommunication# */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço vaultCommunication. existe um código IDAPP. &lt;/br&gt; * O serviço vaultCommunication. deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-vault-api.Testes.vaultCommunication# */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço vaultCommunication. */ describe(\"Testando actions do serviço 'vaultCommunication.'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço vaultCommunication. deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-vault-api.Testes.vaultCommunication# */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); }); }); × Search results Close "},"add-tools-vault-api_src_services_test_unit_vaultsignature.service.spec.js.html":{"id":"add-tools-vault-api_src_services_test_unit_vaultsignature.service.spec.js.html","title":"Source: add-tools-vault-api/src/services/test/unit/vaultsignature.service.spec.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-vault-api/src/services/test/unit/vaultsignature.service.spec.js \"use strict\"; const { ServiceBroker } = require(\"moleculer\"); const service = require(\"../../vaultsignature.service\"); const { ValidationError } = require(\"moleculer\").Errors; /** * Este arquivo contém os testes para o serviço vaultsignature * @namespace add-tools-vault-api.Testes.vaultsignature */ /** * Bloco de testes do Serviço vaultsignature */ describe(\"Testando serviço 'vaultsignature'\", () =&gt; { const broker = new ServiceBroker({ logger: false }); broker.createService(service); beforeAll(() =&gt; broker.start()); afterAll(() =&gt; broker.stop()); /** * @desc Teste para verificar se a descrição do serviço está preenchida. &lt;/br&gt; * O serviço vaultsignature deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição do serviço * @test Descrição_Serviço * @memberof add-tools-vault-api.Testes.vaultsignature */ test(\"Deveria ter uma descrição breve em cada serviço com qualquer valor do tipo String\", () =&gt; { expect(service?.metadata?.$description).toEqual(expect.any(String)); }); /** * @desc Teste para verificar se nas configurações do serviço vaultsignature existe um código IDAPP. &lt;/br&gt; * O serviço vaultsignature deve ter um código IDAPP nas suas configurações definido. * @summary IDAPP do Serviço * @test IDAPP_Serviço * @memberof add-tools-vault-api.Testes.vaultsignature */ test(\"Deveria ter um código IDAPP nas configurações de cada serviço\", function () { expect(service?.settings?.IDAPP).toBeDefined(); }); /** * Bloco de testes das actions do Serviço vaultsignature */ describe(\"Testando actions do serviço 'vaultsignature'\", () =&gt; { /** * @desc Teste para verificar se a descrição das actions está preenchida. &lt;/br&gt; * Todas as actions do serviço vaultsignature deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. * @summary Descrição das actions * @test Descrição_Action * @memberof add-tools-vault-api.Testes.vaultsignature */ test(\"Deveria ter uma descrição breve em cada ação\", function () { Object.values(service?.actions).forEach((action) =&gt; { expect(action.description).toEqual(expect.any(String)); }); }); }); }); × Search results Close "},"add-tools-vault-api_src_services_vault.service.js.html":{"id":"add-tools-vault-api_src_services_vault.service.js.html","title":"Source: add-tools-vault-api/src/services/vault.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-vault-api/src/services/vault.service.js const path = require(\"path\"); const fs = require(\"fs\"); const cp = require(\"child_process\"); const tmpdir = require(\"os\").tmpdir(); const crypto = require(\"crypto\"); const vaultErrorMessage = require(\"classes/resources/vaultErrorMessage\"); const utilslib = require(\"add-base-utils-lib/libs/utils\"); const roleId = process.env.ROLE_ID; const secretId = process.env.SECRET_ID; /** * @namespace {object} add-tools-vault-api */ /** * O Serviço vault faz ... * @namespace add-tools-vault-api.vault * @property {string} name - Nome do serviço * @todo @property {number} version - Versão do serviço * @property {array} mixins - Mixins do serviço * @property {object} metadata - Metadados do serviço * @property {object} settings - Configurações do serviço * @property {object} actions - Ações do serviço: &lt;strong&gt;retrieveSecret&lt;/strong&gt;, &lt;strong&gt;upsertSecret&lt;/strong&gt;, &lt;strong&gt;listSecrets&lt;/strong&gt;, &lt;strong&gt;copySecret&lt;/strong&gt;, &lt;strong&gt;deleteSecret&lt;/strong&gt;, &lt;strong&gt;convertCertificate&lt;/strong&gt; * @property {object} methods - Métodos do serviço: &lt;code&gt;validateInputParams()&lt;/code&gt;, &lt;code&gt;addEncrypt()&lt;/code&gt;, &lt;code&gt;addDecrypt()&lt;/code&gt;, &lt;code&gt;encodeBase64()&lt;/code&gt;, &lt;code&gt;decodeBase64()&lt;/code&gt;, &lt;code&gt;deleteTempFiles()&lt;/code&gt;, &lt;code&gt;readFromString()&lt;/code&gt;, &lt;code&gt;localConvertCertificate()&lt;/code&gt; */ module.exports = { name: \"vault\", // version: 1, mixins: [], metadata: { $description: \"Vault client API\" }, settings: { IDAPP: `${path.dirname(__filename).split(path.sep).pop()}`, rest: true, MONETIZATION: false, }, /** * @summary actions do serviço VAULT * @property {object} retrieveSecret - Recuperar segredo do cofre {@link add-tools-vault-api.vault#retrieveSecret action retrieveSecret} * @property {object} upsertSecret - Gravar segredo no cofre {@link add-tools-vault-api.vault#upsertSecret action upsertSecret} * @property {object} listSecrets - Listar segredos do cofre {@link add-tools-vault-api.vault#listSecrets action listSecrets} * @property {object} copySecret - Copiar segredo do cofre {@link add-tools-vault-api.vault#copySecret action copySecret} * @property {object} deleteSecret - Deletar segredo do cofre {@link add-tools-vault-api.vault#deleteSecret action deleteSecret} * @property {object} convertCertificate - Converter certificado {@link add-tools-vault-api.vault#convertCertificate action convertCertificate} * @memberof add-tools-vault-api.vault# */ actions: { /** * A ação retrieveSecret faz ... * @summary Ação retrieveSecret * @action retrieveSecret * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {array} permissions - Permissões da action * @property {object} ctx.params - Parâmetros da action * @property {string} ctx.params.secretType - Tipo do segredo Tipo do segredo Tipo do segredo Tipo do segredo Tipo do segredoTipo do segredoTipo do segredoTipo do segredoTipo do segredoTipo do segredo Tipo do segredo * @property {string} ctx.params.secretAlias - Alias do segredo * @memberof add-tools-vault-api.vault# */ retrieveSecret: { description: \"Retrieve secret from Vault\", // rest: \"POST /retrieveSecret\", params: { secretType: { type: \"string\", }, secretAlias: { type: \"string\", }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { if (!ctx.params.secretAlias) ctx.params.secretAlias = \"-\"; const validateInputParamsError = this.validateInputParams( ctx.params, ctx.nodeID, ); if (validateInputParamsError) return validateInputParamsError; let { secretAlias } = ctx.params; secretAlias = secretAlias.toLowerCase(); let { secretType } = ctx.params; secretType = secretType.toLowerCase(); const vaultImpl = require(\"classes/resources/VaultObjectFactory\").vaultObjectFactory(); const secretObjResponse = await vaultImpl.retrieveSecret( ctx.meta.user.mandt, ctx.params.companyCode, secretType, secretAlias, ); let secretObj; secretObjResponse?.data ? (secretObj = secretObjResponse.data) : null; // Tenta decriptar tipos de campos 'conhecidos' if (ctx.params.addDecrypt) { try { secretObj?.pbKey ? (secretObj.pbKey = this.addDecrypt( secretObj.pbKey, )) : null; secretObj?.pvKey ? (secretObj.pvKey = this.addDecrypt( secretObj.pvKey, )) : null; secretObj?.pkcs12 ? (secretObj.pkcs12 = this.addDecrypt( secretObj.pkcs12, )) : null; secretObj?.pkcs12Password ? (secretObj.pkcs12Password = this.addDecrypt( secretObj.pkcs12Password, )) : null; secretObj?.mailId ? (secretObj.mailId = this.addDecrypt( secretObj.mailId, )) : null; secretObj?.mailAddress ? (secretObj.mailAddress = this.addDecrypt( secretObj.mailAddress, )) : null; secretObj?.mailUserAccount ? (secretObj.mailUserAccount = this.addDecrypt( secretObj.mailUserAccount, )) : null; secretObj?.mailPassword ? (secretObj.mailPassword = this.addDecrypt( secretObj.mailPassword, )) : null; secretObj?.userDomain ? (secretObj.userDomain = this.addDecrypt( secretObj.userDomain, )) : null; secretObj?.userAccount ? (secretObj.userAccount = this.addDecrypt( secretObj.userAccount, )) : null; secretObj?.userPassword ? (secretObj.userPassword = this.addDecrypt( secretObj.userPassword, )) : null; secretObj?.tenant ? (secretObj.tenant = this.addDecrypt( secretObj.tenant, )) : null; secretObj?.clientId ? (secretObj.clientId = this.addDecrypt( secretObj.clientId, )) : null; secretObj?.clientSecret ? (secretObj.clientSecret = this.addDecrypt( secretObj.clientSecret, )) : null; secretObj?.credentialSecret ? (secretObj.credentialSecret = this.addDecrypt( secretObj.credentialSecret, )) : null; } catch (err) { let traceMsg = \"Nao foi possivel obter detalhes do erro\"; try { traceMsg = Buffer.from( JSON.stringify(err), ).toString(\"base64\"); } catch (eex) {} return vaultErrorMessage.getErrorMessageObj( \"ApplicationError\", \"Application Encrypting Secret\", 503, \"APPLICATION_ERROR\", null, // Data Array para multiplas mensagens vaultErrorMessage.getErrorMessageDataObj( \"application\", \"Erro durante a criptografia\", \"secret\", // field ctx.nodeID, \"vault.retrieveSecret\", traceMsg, ), ); } } return secretObjResponse; }, openapi: { responses: { 200: { description: \"Secret obtido com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Secret obtido com sucesso - Alias: companycert1\", }, data: { type: \"object\", properties: { mailAddress: { type: \"string\", example: \"mailbox@company.com\", }, mailId: { type: \"string\", example: \"mailbox\", }, mailPassword: { type: \"string\", example: \"hash121j22jl21jl1\", }, mailUserAccount: { type: \"string\", example: \"mailboxuser\", }, mailUserDomain: { type: \"string\", example: \"companydomain\", }, passwordExpiryDate: { type: \"string\", example: \"20230606\", }, secretType: { type: \"string\", example: \"mailcredentials\", }, updatedAt: { type: \"string\", example: \"2022-08-15T11:44:18.203Z\", }, }, }, }, }, }, }, }, }, }, }, /** * A ação upsertSecret ... * @summary Ação upsertSecret * @action upsertSecret * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} params.secretType - Tipo do segredo * @property {string} params.secretAlias - Alias do segredo * @property {array} permissions - Permissões da action * @property {function} handler @Link VAULT.upsertSecret.handler * @memberof add-tools-vault-api.vault# */ upsertSecret: { description: \"Upsert secret in Vault\", // rest: \"POST /upsertSecret\", params: { secretType: { type: \"string\", }, secretAlias: { type: \"string\", }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { if (!ctx.params.secretAlias) ctx.params.secretAlias = \"-\"; const validateInputParamsError = this.validateInputParams( ctx.params, ctx.nodeID, ); if (validateInputParamsError) return validateInputParamsError; let { secretAlias } = ctx.params; secretAlias = secretAlias.toLowerCase(); let { secretType } = ctx.params; secretType = secretType.toLowerCase(); // Quando for um secret do tipo certificado // Verifica se foi utilizado o parametro para converter o arquivo if (secretType == \"certificate\") { if (ctx.params?.convertCertificate) if ( ctx.params?.secret?.pkcs12 &amp;&amp; ctx.params?.secret?.pkcs12Password ) { try { const pfx = Buffer.from( ctx.params.secret.pkcs12, \"base64\", ); const p12Password = Buffer.from( ctx.params.secret.pkcs12Password, \"base64\", ); const convertedCertificate = await this.localConvertCertificate( pfx, p12Password, ); if ( convertedCertificate &amp;&amp; convertedCertificate?.key &amp;&amp; convertedCertificate?.cert ) { ctx.params.secret.pbKey = convertedCertificate.cert; ctx.params.secret.pvKey = convertedCertificate.key; } else { // TODO: RETORNAR MENSAGEM DE ERRO DA CONVERSAO } } catch (err) { // TODO: RETORNAR MENSAGEM DE ERRO DA OPERACAO } } else { // TODO: RETORNAR MENSAGEM DE ERRO DE PARAMETROS INSUFICIENTES } } // Tenta encriptar tipos de campos 'conhecidos' const secretObj = ctx.params.secret; try { secretObj?.pbKey ? (secretObj.pbKey = this.addEncrypt(secretObj.pbKey)) : null; secretObj?.pvKey ? (secretObj.pvKey = this.addEncrypt(secretObj.pvKey)) : null; secretObj?.pkcs12 ? (secretObj.pkcs12 = this.addEncrypt(secretObj.pkcs12)) : null; secretObj?.pkcs12Password ? (secretObj.pkcs12Password = this.addEncrypt( secretObj.pkcs12Password, )) : null; secretObj?.mailId ? (secretObj.mailId = this.addEncrypt(secretObj.mailId)) : null; secretObj?.mailAddress ? (secretObj.mailAddress = this.addEncrypt( secretObj.mailAddress, )) : null; secretObj?.mailUserAccount ? (secretObj.mailUserAccount = this.addEncrypt( secretObj.mailUserAccount, )) : null; secretObj?.mailPassword ? (secretObj.mailPassword = this.addEncrypt( secretObj.mailPassword, )) : null; secretObj?.userDomain ? (secretObj.userDomain = this.addEncrypt( secretObj.userDomain, )) : null; secretObj?.userAccount ? (secretObj.userAccount = this.addEncrypt( secretObj.userAccount, )) : null; secretObj?.userPassword ? (secretObj.userPassword = this.addEncrypt( secretObj.userPassword, )) : null; secretObj?.tenant ? (secretObj.tenant = this.addEncrypt(secretObj.tenant)) : null; secretObj?.clientId ? (secretObj.clientId = this.addEncrypt( secretObj.clientId, )) : null; secretObj?.clientSecret ? (secretObj.clientSecret = this.addEncrypt( secretObj.clientSecret, )) : null; secretObj?.credentialSecret ? (secretObj.credentialSecret = this.addEncrypt( secretObj.credentialSecret, )) : null; } catch (err) { let traceMsg = \"Nao foi possivel obter detalhes do erro\"; try { traceMsg = Buffer.from(JSON.stringify(err)).toString( \"base64\", ); } catch (eex) {} return vaultErrorMessage.getErrorMessageObj( \"ApplicationError\", \"Application Encrypting Secret\", 503, \"APPLICATION_ERROR\", null, // Data Array para multiplas mensagens vaultErrorMessage.getErrorMessageDataObj( \"application\", \"Erro durante a criptografia\", \"secret\", // field ctx.nodeID, \"vault.upsertSecret\", traceMsg, ), ); } const vaultImpl = require(\"classes/resources/VaultObjectFactory\").vaultObjectFactory(); const vaultResponse = await vaultImpl.upsertSecret( ctx.meta.user.mandt, ctx.params.companyCode, secretType, secretAlias, secretObj, ); return vaultResponse; }, openapi: { responses: { 200: { description: \"Secret gravado com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Gravado com sucesso\", }, }, }, }, }, }, }, }, }, /** * A ação listSecrets ... * @summary Ação listSecrets * @action listSecrets * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} [params.secretType] - Tipo do segredo * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vault# */ listSecrets: { description: \"List secrets in Vault\", // rest: \"POST /listSecrets\", params: { secretType: { type: \"string\", optional: true, }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { const validateInputParamsError = this.validateInputParams( ctx.params, ctx.nodeID, ); if (validateInputParamsError) return validateInputParamsError; let { secretType } = ctx.params; secretType = secretType.toLowerCase(); const vaultImpl = require(\"classes/resources/VaultObjectFactory\").vaultObjectFactory(); const vaultResponse = await vaultImpl.listSecrets( ctx.meta.user.mandt, ctx.params.companyCode, secretType, ); return vaultResponse; }, openapi: { responses: { 200: { description: \"Secrets listados com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Secrets obtidos com sucesso\", }, count: { type: \"integer\", example: 7, }, data: { type: \"array\", items: { type: \"string\", example: [ \"companycert1\", \"companycert2\", \"companymail1\", \"companyoauth1\", \"companyothers1\", \"companyothers3\", \"companyuser1\", ], }, }, }, }, }, }, }, }, }, }, /** * @A ação copySecret ... * @summary Ação copySecret * @action copySecret * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} params.secretType - Tipo do segredo * @property {string} params.secretAlias - Alias do segredo * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vault# */ copySecret: { description: \"Copy secret in Vault\", // rest: \"POST /copySecret\", params: { secretType: { type: \"string\", }, secretAlias: { type: \"string\", }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { if (!ctx.params.secretAlias) ctx.params.secretAlias = \"-\"; if (!ctx.params.newSecretAlias) ctx.params.newSecretAlias = \"-\"; const validateInputParamsError = this.validateInputParams( ctx.params, ctx.nodeID, ); if (validateInputParamsError) return validateInputParamsError; let { secretAlias } = ctx.params; secretAlias = secretAlias.toLowerCase(); let { newSecretAlias } = ctx.params; newSecretAlias = newSecretAlias.toLowerCase(); let { secretType } = ctx.params; secretType = secretType.toLowerCase(); const vaultImpl = require(\"classes/resources/VaultObjectFactory\").vaultObjectFactory(); const vaultResponse = await vaultImpl.copySecret( ctx.meta.user.mandt, ctx.params.companyCode, secretType, secretAlias, newSecretAlias, ); return vaultResponse; }, openapi: { responses: { 200: { description: \"Secrets copiado com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Gravado com sucesso\", }, }, }, }, }, }, }, }, }, /** * @A ação deleteSecret ... * @summary Ação deleteSecret * @action deleteSecret * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} params.secretType - Tipo do segredo * @property {string} params.secretAlias - Alias do segredo * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vault# */ deleteSecret: { description: \"Delete secret in Vault\", // rest: \"POST /deleteSecret\", params: { secretType: { type: \"string\", }, secretAlias: { type: \"string\", }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { if (!ctx.params.secretAlias) ctx.params.secretAlias = \"-\"; const validateInputParamsError = this.validateInputParams( ctx.params, ctx.nodeID, ); if (validateInputParamsError) return validateInputParamsError; let { secretAlias } = ctx.params; secretAlias = secretAlias.toLowerCase(); let { secretType } = ctx.params; secretType = secretType.toLowerCase(); const vaultImpl = require(\"classes/resources/VaultObjectFactory\").vaultObjectFactory(); const vaultResponse = await vaultImpl.deleteSecret( ctx.meta.user.mandt, ctx.params.companyCode, secretType, secretAlias, ); // TODO&gt;Validar resultado // TODO&gt;Formatar mensagem de retorno return vaultResponse; }, openapi: { responses: { 200: { description: \"Operacao enviada com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Deletado com sucesso\", }, }, }, }, }, }, }, }, }, /** * A ação convertCertificate ... * @summary Ação convertCertificate * @action convertCertificate * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} params.pkcs12File - Arquivo pkcs12 * @property {string} params.pkcs12Password - Senha do arquivo pkcs12 * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vault# */ convertCertificate: { description: \"Convert Certificate\", // rest: \"POST /convertCertificate\", params: { pkcs12File: { type: \"string\", }, pkcs12Password: { type: \"string\", }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { const pfx = Buffer.from(ctx.params.pkcs12File, \"base64\"); const p12Password = Buffer.from( ctx.params.pkcs12Password, \"base64\", ); return await this.localConvertCertificate(pfx, p12Password); }, openapi: { responses: { 200: { description: \"Operacao enviada com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Convertido\", }, }, }, }, }, }, }, }, }, }, methods: { /** * @desc O method &lt;code&gt;validateInputParams()&lt;/code&gt; ... * @summary Método para ... * @method validateInputParams * @param {object} params - Parâmetros de entrada * @param {object} nodeID - ID do nó * @returns {undefined} - Se passar por todas validacoes retorna 'undefined' * @memberof add-tools-vault-api.vault# */ validateInputParams(params, nodeID) { const regex = /^[A-Za-z0-9]+$/; let isValid = false; isValid = params?.secretAlias ? regex.test(params.secretAlias) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"secretAlias\", nodeID, \"vault\", ), ); return errorResponse; } isValid = params?.newSecretAlias ? regex.test(params.newSecretAlias) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"newSecretAlias\", nodeID, \"vault\", ), ); return errorResponse; } isValid = params?.secretType ? regex.test(params.secretType) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"secretType\", nodeID, \"vault\", ), ); return errorResponse; } isValid = params?.companyCode ? regex.test(params.companyCode) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"companyCode\", nodeID, \"vault\", ), ); return errorResponse; } // Se passou por todas validacoes retorna 'undefined' }, /** * @desc O method &lt;code&gt;addEncrypt()&lt;/code&gt; ... * @summary Método para ... * @method addEncrypt * @param {string} e - String a ser encriptada * @returns {string} - String encriptada * @memberof add-tools-vault-api.vault# */ addEncrypt(e) { try { for ( var r = \"\", t = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", s = t.length, c = 0; c &lt; 15; c++ ) r += t.charAt(Math.floor(Math.random() * s)); return ( (e = this.encodeBase64(e)), (e = e.replace(\"=\", \".\")), (e = `${e.substring(0, 2)}W${r.substring( 0, 2, )}add${e.substring(2, e.length)}${r.substring( 2, r.length, )}`), e ); } catch (err) { return \"ERRO: Falha ao encriptar secret\"; } }, /** * @desc O method &lt;code&gt;addDecrypt()&lt;/code&gt; ... * @summary Método para ... * @method addDecrypt * @param {string} r - String a ser decriptada * @returns {string} - String decriptada * @memberof add-tools-vault-api.vault# */ addDecrypt(r) { try { if (!r || r.length &lt; 10) return \"ERRO: secret invalido\"; if (r.length == 19) return \"\"; } catch (err) { return \"ERRO: Falha ao avaliar o secret\"; } try { let e = r.substring(0, 2) + r.substring(8, r.length - 13); return (e = e.replace(\".\", \"=\")), (e = this.decodeBase64(e)); } catch (r) { return \"ERRO: Falha ao realizar o decrypt do secret informado\"; } }, /** * @desc O method &lt;code&gt;encodeBase64()&lt;/code&gt; ... * @summary Método para ... * @method encodeBase64 * @param {string} str - String a ser codificada * @returns {string} - String codificada em base64 * @memberof add-tools-vault-api.vault# */ encodeBase64(str) { return Buffer.from(str).toString(\"base64\"); }, /** * @desc O method &lt;code&gt;decodeBase64()&lt;/code&gt; ... * @summary Método para ... * @method decodeBase64 * @param {string} str - String a ser decodificada * @returns {string} - String decodificada em utf-8 * @memberof add-tools-vault-api.vault# */ decodeBase64(str) { return Buffer.from(str, \"base64\").toString(\"utf-8\"); }, /** * @desc O method &lt;code&gt;deleteTempFiles()&lt;/code&gt; ... * @summary Método para ... * @type {methods} * @param {array} list - Lista de arquivos a serem deletados * @memberof vault * @instance */ deleteTempFiles(list) { for (const a in list) { fs.unlinkSync(list[a]); } }, /** * @desc O method &lt;code&gt;readFromString()&lt;/code&gt; ... * @summary Método para ... * @method readFromString * @param {string} string - String a ser lida * @param {string} start - String de inicio * @param {string} end - String de fim * @returns {array} - Array de strings * @memberof add-tools-vault-api.vault# */ readFromString(string, start, end) { const output = []; let offset = string.indexOf(start); while (offset !== -1) { string = string.substring(offset); let endOffset = string.indexOf(end); if (endOffset === -1) { break; } endOffset += end.length; output.push(string.substring(0, endOffset)); offset = string.indexOf(start, endOffset); } return output; }, /** * @desc O method &lt;code&gt;localConvertCertificate()&lt;/code&gt; ... * @summary Método para ... * @method localConvertCertificate * @param {string} certificateFile - Arquivo de certificado * @param {string} certificatePassword - Senha do certificado * @returns {object} - Objeto com chave e certificado * @memberof add-tools-vault-api.vault# */ localConvertCertificate(certificateFile, certificatePassword) { if (!certificateFile || !certificatePassword) { return { context: \"ERROR\", statusInfo: { status: false, errorCode: \"503\", message: \"Parametros invalidos\", solution: \"Verificar parametros\", trace: null, }, }; } const pfx = certificateFile; const p12Password = certificatePassword; const KEY_START = \"-----BEGIN PRIVATE KEY-----\"; const KEY_END = \"-----END PRIVATE KEY-----\"; const CERT_START = \"-----BEGIN CERTIFICATE-----\"; const CERT_END = \"-----END CERTIFICATE-----\"; const tmpfiles = []; let args = [\"pkcs12\", \"-in\"]; const pfxFilePath = path.join( tmpdir, crypto.randomBytes(20).toString(\"hex\"), ); args.push(pfxFilePath); tmpfiles.push(pfxFilePath); fs.writeFileSync(pfxFilePath, pfx); const passwordFilePath = path.join( tmpdir, crypto.randomBytes(20).toString(\"hex\"), ); args.push(\"-passin\"); args.push(`file:${passwordFilePath}`); tmpfiles.push(passwordFilePath); fs.writeFileSync(passwordFilePath, p12Password); args.push(\"-nodes\"); let openssl = cp.spawnSync(\"openssl\", args); let stdout = openssl.stdout.toString(); let stderr = openssl.stderr.toString(); if (stderr != \"\") { return { context: \"ERROR\", statusInfo: { status: false, errorCode: \"ERR\", message: \"Não foi possivel converter o certificado\", solution: null, trace: stderr, }, }; } const keybundle = {}; const certs = this.readFromString(stdout, CERT_START, CERT_END); keybundle.cert = certs.shift(); keybundle.ca = certs; keybundle.key = this.readFromString( stdout, KEY_START, KEY_END, ).pop(); args = [\"rsa\", \"-in\"]; const privateKeyFilePath = path.join( tmpdir, crypto.randomBytes(20).toString(\"hex\"), ); args.push(privateKeyFilePath); tmpfiles.push(privateKeyFilePath); fs.writeFileSync(privateKeyFilePath, keybundle.key); openssl = cp.spawnSync(\"openssl\", args); stdout = openssl.stdout.toString(); stderr = openssl.stderr.toString(); keybundle.key = stdout; keybundle.key = this.encodeBase64(keybundle.key); keybundle.cert = this.encodeBase64(keybundle.cert); this.deleteTempFiles(tmpfiles); return { key: keybundle.key, cert: keybundle.cert, }; }, }, }; × Search results Close "},"add-tools-vault-api_src_services_vaultapp.service.js.html":{"id":"add-tools-vault-api_src_services_vaultapp.service.js.html","title":"Source: add-tools-vault-api/src/services/vaultapp.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-vault-api/src/services/vaultapp.service.js const path = require(\"path\"); const fs = require(\"fs\"); const cp = require(\"child_process\"); const tmpdir = require(\"os\").tmpdir(); const crypto = require(\"crypto\"); const vaultErrorMessage = require(\"classes/resources/vaultErrorMessage\"); const utilslib = require(\"add-base-utils-lib/libs/utils\"); const roleId = process.env.ROLE_ID; const secretId = process.env.SECRET_ID; /** * @desc O Serviço de vaultapp faz ... * @namespace add-tools-vault-api.vaultapp * @memberof add-tools-vault-api * @property {string} name - Nome do serviço * @todo @property {number} version - Versão do serviço * @property {array} mixins - Mixins do serviço * @property {object} metadata - Metadados do serviço * @property {object} settings - Configurações do serviço * @property {object} actions - Ações do serviço: &lt;strong&gt;get&lt;/strong&gt;, &lt;strong&gt;create&lt;/strong&gt;, &lt;strong&gt;update&lt;/strong&gt;, &lt;strong&gt;list&lt;/strong&gt;, &lt;strong&gt;copySecret&lt;/strong&gt;, &lt;strong&gt;remove&lt;/strong&gt;, &lt;strong&gt;convertCertificate&lt;/strong&gt; * @property {object} methods - Métodos do serviço: &lt;code&gt;validateInputParams()&lt;/code&gt;, &lt;code&gt;addEncrypt()&lt;/code&gt;, &lt;code&gt;encodeBase64()&lt;/code&gt;, &lt;code&gt;decodeBase64()&lt;/code&gt;, &lt;code&gt;deleteTempFiles()&lt;/code&gt;, &lt;code&gt;readFromString()&lt;/code&gt; e &lt;code&gt;localConvertCertificate()&lt;/code&gt; */ module.exports = { name: \"vaultapp\", // version: 1, mixins: [], metadata: { $description: \"Vault client APP\" }, settings: { IDAPP: `${path.dirname(__filename).split(path.sep).pop()}`, rest: true, MONETIZATION: false, fields: { secretAlias: { type: \"string\", required: true }, secretType: { type: \"string\", required: false, optional: true }, }, }, /** * @summary actions * @property {object} get - Ação para obter um secret {@link add-tools-vault-api.vaultapp#get action get} * @property {object} create - Ação para criar um secret {@link add-tools-vault-api.vaultapp#create action create} * @property {object} update - Ação para atualizar um secret {@link add-tools-vault-api.vaultapp#update action update} * @property {object} list - Ação para listar secrets {@link add-tools-vault-api.vaultapp#list action list} * @property {object} copySecret - Ação para copiar um secret {@link add-tools-vault-api.vaultapp#copySecret action copySecret} * @property {object} remove - Ação para remover um secret {@link add-tools-vault-api.vaultapp#remove action remove} * @property {object} convertCertificate - Ação para converter um certificado {@link add-tools-vault-api.vaultapp#convertCertificate action convertCertificate} * @memberof add-tools-vault-api.vaultapp# */ actions: { /** * @desc A ação get faz ... * @summary Ação get * @action get * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} [params.secretType] - Tipo do segredo * @property {string} params.secretAlias - Alias do segredo * @property {string} [params.SECRETALIAS] - Alias do segredo * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vaultapp# */ get: { description: \"Retrieve secret from Vault\", // rest: \"POST /retrieveSecret\", params: { secretType: { type: \"string\", optional: true, }, secretAlias: { type: \"string\", }, SECRETALIAS: { type: \"string\", optional: true, }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { if (!ctx.params.secretAlias) { if (ctx.params?.SECRETALIAS) ctx.params.secretAlias = ctx.params.SECRETALIAS; else ctx.params.secretAlias = \"-\"; } const validateInputParamsError = this.validateInputParams( ctx.params, ctx.nodeID, ); if (validateInputParamsError) return validateInputParamsError; let { secretAlias } = ctx.params; secretAlias = secretAlias.toLowerCase(); const secretType = \"\"; const vaultImpl = require(\"classes/resources/VaultObjectFactory\").vaultObjectFactory(); const secretObjResponse = await vaultImpl.retrieveSecret( ctx.meta.user.mandt, ctx.params.companyCode, secretType, secretAlias, ); let secretObj; secretObjResponse?.data ? (secretObj = secretObjResponse.data) : null; // Remove campos sensiveis secretObjResponse.data?.pbKey ? delete secretObjResponse.data.pbKey : null; secretObjResponse.data?.pvKey ? delete secretObjResponse.data.pvKey : null; secretObjResponse.data?.pkcs12 ? delete secretObjResponse.data.pkcs12 : null; secretObjResponse.data?.pkcs12Password ? delete secretObjResponse.data.pkcs12Password : null; secretObjResponse.data?.mailPassword ? delete secretObjResponse.data.mailPassword : null; secretObjResponse.data?.userPassword ? delete secretObjResponse.data.userPassword : null; secretObjResponse.data?.clientSecret ? delete secretObjResponse.data.clientSecret : null; secretObjResponse.data?.credentialSecret ? delete secretObjResponse.data.credentialSecret : null; // Tenta decriptar tipos de campos 'conhecidos' ctx.params.addDecrypt = true; if (ctx.params.addDecrypt) { try { secretObj?.pbKey ? (secretObj.pbKey = this.addDecrypt( secretObj.pbKey, )) : null; secretObj?.pvKey ? (secretObj.pvKey = this.addDecrypt( secretObj.pvKey, )) : null; secretObj?.pkcs12 ? (secretObj.pkcs12 = this.addDecrypt( secretObj.pkcs12, )) : null; secretObj?.pkcs12Password ? (secretObj.pkcs12Password = this.addDecrypt( secretObj.pkcs12Password, )) : null; secretObj?.mailId ? (secretObj.mailId = this.addDecrypt( secretObj.mailId, )) : null; secretObj?.mailAddress ? (secretObj.mailAddress = this.addDecrypt( secretObj.mailAddress, )) : null; secretObj?.mailUserAccount ? (secretObj.mailUserAccount = this.addDecrypt( secretObj.mailUserAccount, )) : null; secretObj?.mailPassword ? (secretObj.mailPassword = this.addDecrypt( secretObj.mailPassword, )) : null; secretObj?.userDomain ? (secretObj.userDomain = this.addDecrypt( secretObj.userDomain, )) : null; secretObj?.userAccount ? (secretObj.userAccount = this.addDecrypt( secretObj.userAccount, )) : null; secretObj?.userPassword ? (secretObj.userPassword = this.addDecrypt( secretObj.userPassword, )) : null; secretObj?.tenant ? (secretObj.tenant = this.addDecrypt( secretObj.tenant, )) : null; secretObj?.clientId ? (secretObj.clientId = this.addDecrypt( secretObj.clientId, )) : null; secretObj?.clientSecret ? (secretObj.clientSecret = this.addDecrypt( secretObj.clientSecret, )) : null; secretObj?.credentialSecret ? (secretObj.credentialSecret = this.addDecrypt( secretObj.credentialSecret, )) : null; } catch (err) { let traceMsg = \"Nao foi possivel obter detalhes do erro\"; try { traceMsg = Buffer.from( JSON.stringify(err), ).toString(\"base64\"); } catch (eex) {} return vaultErrorMessage.getErrorMessageObj( \"ApplicationError\", \"Application Encrypting Secret\", 503, \"APPLICATION_ERROR\", null, // Data Array para multiplas mensagens vaultErrorMessage.getErrorMessageDataObj( \"application\", \"Erro durante a criptografia\", \"secret\", // field ctx.nodeID, \"vault.retrieveSecret\", traceMsg, ), ); } } return secretObjResponse; }, openapi: { responses: { 200: { description: \"Secret obtido com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Secret obtido com sucesso - Alias: companycert1\", }, data: { type: \"object\", properties: { mailAddress: { type: \"string\", example: \"mailbox@company.com\", }, mailId: { type: \"string\", example: \"mailbox\", }, mailPassword: { type: \"string\", example: \"hash121j22jl21jl1\", }, mailUserAccount: { type: \"string\", example: \"mailboxuser\", }, mailUserDomain: { type: \"string\", example: \"companydomain\", }, passwordExpiryDate: { type: \"string\", example: \"20230606\", }, secretType: { type: \"string\", example: \"mailcredentials\", }, updatedAt: { type: \"string\", example: \"2022-08-15T11:44:18.203Z\", }, }, }, }, }, }, }, }, }, }, }, /** * @desc A ação create faz ... * @summary Ação create * @action create * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} params.SECRETALIAS - Alias do segredo * @property {string} params.SECRETTYPE - Tipo do segredo * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vaultapp# */ create: { description: \"Upsert secret in Vault\", // rest: \"POST /upsertSecret\", params: { SECRETALIAS: { type: \"string\", }, SECRETTYPE: { type: \"string\", }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { ctx.params.secretAlias = ctx.params.SECRETALIAS; ctx.params.secretType = ctx.params.SECRETTYPE; if (!ctx.params.secretAlias) ctx.params.secretAlias = \"-\"; const validateInputParamsError = this.validateInputParams( ctx.params, ctx.nodeID, ); if (validateInputParamsError) return validateInputParamsError; let { secretAlias } = ctx.params; secretAlias = secretAlias.toLowerCase(); let { secretType } = ctx.params; secretType = secretType.toLowerCase(); // Quando for um secret do tipo certificado // Verifica se foi utilizado o parametro para converter o arquivo if (secretType == \"certificate\") { if (ctx.params?.convertCertificate) if ( ctx.params?.secret?.pkcs12 &amp;&amp; ctx.params?.secret?.pkcs12Password ) { try { const pfx = Buffer.from( ctx.params.secret.pkcs12, \"base64\", ); const p12Password = Buffer.from( ctx.params.secret.pkcs12Password, \"base64\", ); const convertedCertificate = await this.localConvertCertificate( pfx, p12Password, ); if ( convertedCertificate &amp;&amp; convertedCertificate?.key &amp;&amp; convertedCertificate?.cert ) { ctx.params.secret.pbKey = convertedCertificate.cert; ctx.params.secret.pvKey = convertedCertificate.key; } else { // TODO: RETORNAR MENSAGEM DE ERRO DA CONVERSAO } } catch (err) { // TODO: RETORNAR MENSAGEM DE ERRO DA OPERACAO } } else { // TODO: RETORNAR MENSAGEM DE ERRO DE PARAMETROS INSUFICIENTES } } // Tenta encriptar tipos de campos 'conhecidos' const secretObj = ctx.params.secret; try { secretObj?.pbKey ? (secretObj.pbKey = this.addEncrypt(secretObj.pbKey)) : null; secretObj?.pvKey ? (secretObj.pvKey = this.addEncrypt(secretObj.pvKey)) : null; secretObj?.pkcs12 ? (secretObj.pkcs12 = this.addEncrypt(secretObj.pkcs12)) : null; secretObj?.pkcs12Password ? (secretObj.pkcs12Password = this.addEncrypt( secretObj.pkcs12Password, )) : null; secretObj?.mailId ? (secretObj.mailId = this.addEncrypt(secretObj.mailId)) : null; secretObj?.mailAddress ? (secretObj.mailAddress = this.addEncrypt( secretObj.mailAddress, )) : null; secretObj?.mailUserAccount ? (secretObj.mailUserAccount = this.addEncrypt( secretObj.mailUserAccount, )) : null; secretObj?.mailPassword ? (secretObj.mailPassword = this.addEncrypt( secretObj.mailPassword, )) : null; secretObj?.userDomain ? (secretObj.userDomain = this.addEncrypt( secretObj.userDomain, )) : null; secretObj?.userAccount ? (secretObj.userAccount = this.addEncrypt( secretObj.userAccount, )) : null; secretObj?.userPassword ? (secretObj.userPassword = this.addEncrypt( secretObj.userPassword, )) : null; secretObj?.tenant ? (secretObj.tenant = this.addEncrypt(secretObj.tenant)) : null; secretObj?.clientId ? (secretObj.clientId = this.addEncrypt( secretObj.clientId, )) : null; secretObj?.clientSecret ? (secretObj.clientSecret = this.addEncrypt( secretObj.clientSecret, )) : null; secretObj?.credentialSecret ? (secretObj.credentialSecret = this.addEncrypt( secretObj.credentialSecret, )) : null; } catch (err) { let traceMsg = \"Nao foi possivel obter detalhes do erro\"; try { traceMsg = Buffer.from(JSON.stringify(err)).toString( \"base64\", ); } catch (eex) {} return vaultErrorMessage.getErrorMessageObj( \"ApplicationError\", \"Application Encrypting Secret\", 503, \"APPLICATION_ERROR\", null, // Data Array para multiplas mensagens vaultErrorMessage.getErrorMessageDataObj( \"application\", \"Erro durante a criptografia\", \"secret\", // field ctx.nodeID, \"vault.upsertSecret\", traceMsg, ), ); } const vaultImpl = require(\"classes/resources/VaultObjectFactory\").vaultObjectFactory(); const vaultResponse = await vaultImpl.upsertSecret( ctx.meta.user.mandt, ctx.params.companyCode, secretType, secretAlias, secretObj, ); if ( vaultResponse?.vaultResponse &amp;&amp; vaultResponse.vaultResponse.includes(\"sucesso\") ) vaultResponse.id = secretAlias; vaultResponse.secretAlias = secretAlias; vaultResponse.SECRETALIAS = secretAlias; return vaultResponse; }, openapi: { responses: { 200: { description: \"Secret gravado com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Gravado com sucesso\", }, }, }, }, }, }, }, }, }, /** * @desc A ação update faz ... * @summary Ação update * @action update * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} params.SECRETTYPE - Tipo do segredo * @property {string} params.SECRETALIAS - Alias do segredo * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vaultapp# */ update: { description: \"Upsert secret in Vault\", // rest: \"POST /upsertSecret\", params: { SECRETTYPE: { type: \"string\", }, SECRETALIAS: { type: \"string\", }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { ctx.params.secretAlias = ctx.params.SECRETALIAS; ctx.params.secretType = ctx.params.SECRETTYPE; const vaultImpl = require(\"classes/resources/VaultObjectFactory\").vaultObjectFactory(); const originalSecret = await vaultImpl.retrieveSecret( ctx.meta.user.mandt, ctx.params.companyCode, ctx.params.SECRETTYPE, ctx.params.SECRETALIAS, ); try { originalSecret?.data?.pbKey ? (originalSecret.data.pbKey = this.addDecrypt( originalSecret?.data.pbKey, )) : null; originalSecret?.data?.pvKey ? (originalSecret.data.pvKey = this.addDecrypt( originalSecret?.data.pvKey, )) : null; originalSecret?.data?.pkcs12 ? (originalSecret.data.pkcs12 = this.addDecrypt( originalSecret?.data.pkcs12, )) : null; originalSecret?.data?.pkcs12Password ? (originalSecret.data.pkcs12Password = this.addDecrypt( originalSecret?.data.pkcs12Password, )) : null; originalSecret?.data?.mailId ? (originalSecret.data.mailId = this.addDecrypt( originalSecret?.data.mailId, )) : null; originalSecret?.data?.mailAddress ? (originalSecret.data.mailAddress = this.addDecrypt( originalSecret?.data.mailAddress, )) : null; originalSecret?.data?.mailUserAccount ? (originalSecret.data.mailUserAccount = this.addDecrypt( originalSecret?.data.mailUserAccount, )) : null; originalSecret?.data?.mailPassword ? (originalSecret.data.mailPassword = this.addDecrypt( originalSecret?.data.mailPassword, )) : null; originalSecret?.data?.userDomain ? (originalSecret.data.userDomain = this.addDecrypt( originalSecret?.data.userDomain, )) : null; originalSecret?.data?.userAccount ? (originalSecret.data.userAccount = this.addDecrypt( originalSecret?.data.userAccount, )) : null; originalSecret?.data?.userPassword ? (originalSecret.data.userPassword = this.addDecrypt( originalSecret?.data.userPassword, )) : null; originalSecret?.data?.tenant ? (originalSecret.data.tenant = this.addDecrypt( originalSecret?.data.tenant, )) : null; originalSecret?.data?.clientId ? (originalSecret.data.clientId = this.addDecrypt( originalSecret?.data.clientId, )) : null; originalSecret?.data?.clientSecret ? (originalSecret.data.clientSecret = this.addDecrypt( originalSecret?.data.clientSecret, )) : null; originalSecret?.data?.credentialSecret ? (originalSecret.data.credentialSecret = this.addDecrypt( originalSecret?.data.credentialSecret, )) : null; } catch (err) {} ctx.params.secret = originalSecret?.data ? originalSecret.data : {}; switch (ctx.params.secretType) { case \"mailcredentials\": if (ctx.params?.MAILID) ctx.params.secret.mailId = ctx.params.MAILID; if (ctx.params?.MAILADDRESS) ctx.params.secret.mailAddress = ctx.params.MAILADDRESS; if (ctx.params?.MAILPASSWORD) ctx.params.secret.mailPassword = ctx.params.MAILPASSWORD; if (ctx.params?.MAILUSERDOMAIN) ctx.params.secret.mailUserDomain = ctx.params.MAILUSERDOMAIN; if (ctx.params?.MAILUSERACCOUNT) ctx.params.secret.mailUserAccount = ctx.params.MAILUSERACCOUNT; if (ctx.params?.PASSWORDEXPIRYDATE) ctx.params.secret.passwordExpiryDate = ctx.params.PASSWORDEXPIRYDATE; break; case \"certificate\": if (ctx.params?.PBKEY) ctx.params.secret.pbKey = ctx.params.PBKEY; if (ctx.params?.PVKEY) ctx.params.secret.pvKey = ctx.params.PVKEY; if (ctx.params?.PKCS12) ctx.params.secret.pkcs12 = ctx.params.PKCS12; if (ctx.params?.PKCS12PASSWORD) ctx.params.secret.pkcs12Password = ctx.params.PKCS12PASSWORD; if (ctx.params?.EXPIRYDATE) ctx.params.secret.expiryDate = ctx.params.EXPIRYDATE; if (ctx.params?.OUFIELD) ctx.params.secret.ouField = ctx.params.OUFIELD; break; case \"usercredentials\": if (ctx.params?.USERDOMAIN) ctx.params.secret.userDomain = ctx.params.USERDOMAIN; if (ctx.params?.USERACCOUNT) ctx.params.secret.userAccount = ctx.params.USERACCOUNT; if (ctx.params?.USERPASSWORD) ctx.params.secret.userPassword = ctx.params.USERPASSWORD; if (ctx.params?.PASSWORDEXPIRYDATE) ctx.params.secret.passwordExpiryDate = ctx.params.PASSWORDEXPIRYDATE; if (ctx.params?.USERDIRECTORYADDRESS) ctx.params.secret.userDirectoryAddress = ctx.params.USERDIRECTORYADDRESS; break; case \"oauthcredentials\": if (ctx.params?.TENANT) ctx.params.secret.tenant = ctx.params.TENANT; if (ctx.params?.CLIENTID) ctx.params.secret.clientId = ctx.params.CLIENTID; if (ctx.params?.CLIENTSECRET) ctx.params.secret.clientSecret = ctx.params.CLIENTSECRET; if (ctx.params?.SECRETEXPIRYDATE) ctx.params.secret.secretExpiryDate = ctx.params.SECRETEXPIRYDATE; break; case \"others\": if (ctx.params?.CREDENTIALSECRET) ctx.params.secret.credentialSecret = ctx.params.CREDENTIALSECRET; break; } if (!ctx.params.secretAlias) ctx.params.secretAlias = \"-\"; const validateInputParamsError = this.validateInputParams( ctx.params, ctx.nodeID, ); if (validateInputParamsError) return validateInputParamsError; let { secretAlias } = ctx.params; secretAlias = secretAlias.toLowerCase(); let { secretType } = ctx.params; secretType = secretType.toLowerCase(); // Quando for um secret do tipo certificado // Verifica se foi utilizado o parametro para converter o arquivo if (secretType == \"certificate\") { if (ctx.params?.convertCertificate) if ( ctx.params?.secret?.pkcs12 &amp;&amp; ctx.params?.secret?.pkcs12Password ) { try { const pfx = Buffer.from( ctx.params.secret.pkcs12, \"base64\", ); const p12Password = this.decodeBase64( ctx.params.secret.pkcs12Password, ); const convertedCertificate = await this.localConvertCertificate( pfx, p12Password, ); if ( convertedCertificate &amp;&amp; convertedCertificate?.key &amp;&amp; convertedCertificate?.cert ) { ctx.params.secret.pbKey = convertedCertificate.cert; ctx.params.secret.pvKey = convertedCertificate.key; } else { throw new AddsonServerError( \"Vault Conversion Error\", 500, \"ERR_VAULT_CONVERSION\", { IDAPP: ctx.params.IDAPP, ACTION: ctx.action.name, }, ); } } catch (err) { throw new AddsonServerError( \"Vault Conversion Error\", 500, \"ERR_VAULT_CONVERSION\", { IDAPP: ctx.params.IDAPP, ACTION: ctx.action.name, }, ); } } else { throw new AddsonServerError( \"Vault Conversion Error\", 500, \"ERR_VAULT_CONVERSION\", { IDAPP: ctx.params.IDAPP, ACTION: ctx.action.name, }, ); } } // Tenta encriptar tipos de campos 'conhecidos' const secretObj = ctx.params.secret; try { secretObj?.pbKey ? (secretObj.pbKey = this.addEncrypt(secretObj.pbKey)) : null; secretObj?.pvKey ? (secretObj.pvKey = this.addEncrypt(secretObj.pvKey)) : null; secretObj?.pkcs12 ? (secretObj.pkcs12 = this.addEncrypt(secretObj.pkcs12)) : null; secretObj?.pkcs12Password ? (secretObj.pkcs12Password = this.addEncrypt( secretObj.pkcs12Password, )) : null; secretObj?.mailId ? (secretObj.mailId = this.addEncrypt(secretObj.mailId)) : null; secretObj?.mailAddress ? (secretObj.mailAddress = this.addEncrypt( secretObj.mailAddress, )) : null; secretObj?.mailUserAccount ? (secretObj.mailUserAccount = this.addEncrypt( secretObj.mailUserAccount, )) : null; secretObj?.mailPassword ? (secretObj.mailPassword = this.addEncrypt( secretObj.mailPassword, )) : null; secretObj?.userDomain ? (secretObj.userDomain = this.addEncrypt( secretObj.userDomain, )) : null; secretObj?.userAccount ? (secretObj.userAccount = this.addEncrypt( secretObj.userAccount, )) : null; secretObj?.userPassword ? (secretObj.userPassword = this.addEncrypt( secretObj.userPassword, )) : null; secretObj?.tenant ? (secretObj.tenant = this.addEncrypt(secretObj.tenant)) : null; secretObj?.clientId ? (secretObj.clientId = this.addEncrypt( secretObj.clientId, )) : null; secretObj?.clientSecret ? (secretObj.clientSecret = this.addEncrypt( secretObj.clientSecret, )) : null; secretObj?.credentialSecret ? (secretObj.credentialSecret = this.addEncrypt( secretObj.credentialSecret, )) : null; } catch (err) { let traceMsg = \"Nao foi possivel obter detalhes do erro\"; try { traceMsg = Buffer.from(JSON.stringify(err)).toString( \"base64\", ); } catch (eex) {} return vaultErrorMessage.getErrorMessageObj( \"ApplicationError\", \"Application Encrypting Secret\", 503, \"APPLICATION_ERROR\", null, // Data Array para multiplas mensagens vaultErrorMessage.getErrorMessageDataObj( \"application\", \"Erro durante a criptografia\", \"secret\", // field ctx.nodeID, \"vault.upsertSecret\", traceMsg, ), ); } const vaultResponse = await vaultImpl.upsertSecret( ctx.meta.user.mandt, ctx.params.companyCode, secretType, secretAlias, secretObj, ); if (vaultResponse?.vaultResponse.includes(\"sucesso\")) { const secretObjResponse = await vaultImpl.retrieveSecret( ctx.meta.user.mandt, ctx.params.companyCode, secretType, secretAlias, ); if (secretObjResponse?.data) { secretObjResponse.data.secretAlias = secretAlias; secretObjResponse.data.SECRETALIAS = secretAlias; secretObjResponse.data.id = secretAlias; } // secretObjResponse?.data? secretObj = secretObjResponse.data : null; return secretObjResponse.data; } return vaultResponse; }, openapi: { responses: { 200: { description: \"Secret app com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Gravado com sucesso\", }, }, }, }, }, }, }, }, }, /** * @desc A ação list ... * @summary Ação list * @action list * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} [params.secretType] - Tipo do segredo * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vaultapp# */ list: { description: \"List secrets in Vault\", // rest: \"POST /listSecrets\", params: { secretType: { type: \"string\", optional: true, }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { const validateInputParamsError = this.validateInputParams( ctx.params, ctx.nodeID, ); if (validateInputParamsError) return validateInputParamsError; let secretType = ctx.params?.secretType ? ctx.params.secretyType : \"\"; secretType = secretType.toLowerCase(); const vaultImpl = require(\"classes/resources/VaultObjectFactory\").vaultObjectFactory(); const vaultResponse = await vaultImpl.listSecrets( ctx.meta.user.mandt, ctx.params.companyCode, secretType, ); return vaultResponse.data.map((data) =&gt; { return { SECRETALIAS: data }; }); }, openapi: { responses: { 200: { description: \"Secrets listados com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Secrets obtidos com sucesso\", }, count: { type: \"integer\", example: 7, }, data: { type: \"array\", items: { type: \"string\", example: [ \"companycert1\", \"companycert2\", \"companymail1\", \"companyoauth1\", \"companyothers1\", \"companyothers3\", \"companyuser1\", ], }, }, }, }, }, }, }, }, }, }, /** * @desc A ação copySecret faz ... * @summary Ação copySecret * @action copySecret * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} params.secretType - Tipo do segredo * @property {string} params.secretAlias - Alias do segredo * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vaultapp# */ copySecret: { description: \"Copy secret in Vault\", // rest: \"POST /copySecret\", params: { secretType: { type: \"string\", }, secretAlias: { type: \"string\", }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { if (!ctx.params.secretAlias) ctx.params.secretAlias = \"-\"; if (!ctx.params.newSecretAlias) ctx.params.newSecretAlias = \"-\"; const validateInputParamsError = this.validateInputParams( ctx.params, ctx.nodeID, ); if (validateInputParamsError) return validateInputParamsError; let { secretAlias } = ctx.params; secretAlias = secretAlias.toLowerCase(); let { newSecretAlias } = ctx.params; newSecretAlias = newSecretAlias.toLowerCase(); let { secretType } = ctx.params; secretType = secretType.toLowerCase(); const vaultImpl = require(\"classes/resources/VaultObjectFactory\").vaultObjectFactory(); const vaultResponse = await vaultImpl.copySecret( ctx.meta.user.mandt, ctx.params.companyCode, secretType, secretAlias, newSecretAlias, ); return vaultResponse; }, openapi: { responses: { 200: { description: \"Secrets copiado com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Gravado com sucesso\", }, }, }, }, }, }, }, }, }, /** * @desc A ação remove faz ... * @summary Ação remove * @action remove * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} [params.secretType] - Tipo do segredo * @property {string} [params.secretAlias] - Alias do segredo * @property {string} params.id - id do segredo * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vaultapp# */ remove: { description: \"Delete secret in Vault\", // rest: \"POST /deleteSecret\", params: { secretType: { type: \"string\", optional: true, }, secretAlias: { type: \"string\", optional: true, }, id: { type: \"string\", }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { ctx.params.secretAlias = ctx.params?.id; if (!ctx.params.secretAlias) ctx.params.secretAlias = \"-\"; const validateInputParamsError = this.validateInputParams( ctx.params, ctx.nodeID, ); if (validateInputParamsError) return validateInputParamsError; let { secretAlias } = ctx.params; secretAlias = secretAlias.toLowerCase(); let { secretType } = ctx.params; if (!secretType) secretType = \"\"; secretType = secretType.toLowerCase(); const vaultImpl = require(\"classes/resources/VaultObjectFactory\").vaultObjectFactory(); const vaultResponse = await vaultImpl.deleteSecret( ctx.meta.user.mandt, ctx.params.companyCode, secretType, secretAlias, ); // TODO&gt;Validar resultado // TODO&gt;Formatar mensagem de retorno return vaultResponse; }, openapi: { responses: { 200: { description: \"Operacao enviada com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Deletado com sucesso\", }, }, }, }, }, }, }, }, }, /** * @desc A ação convertCertificate faz ... * @summary Ação convertCertificate * @action convertCertificate * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} params.pkcs12File - Arquivo pkcs12 * @property {string} params.pkcs12Password - Senha do arquivo pkcs12 * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vaultapp# */ convertCertificate: { description: \"Convert Certificate\", // rest: \"POST /convertCertificate\", params: { pkcs12File: { type: \"string\", }, pkcs12Password: { type: \"string\", }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { const pfx = Buffer.from(ctx.params.pkcs12File, \"base64\"); const p12Password = Buffer.from( ctx.params.pkcs12Password, \"base64\", ); return await this.localConvertCertificate(pfx, p12Password); }, openapi: { responses: { 200: { description: \"Operacao enviada com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { vaultResponse: { type: \"string\", example: \"Convertido\", }, }, }, }, }, }, }, }, }, }, methods: { /** * @desc O method &lt;code&gt;validateInputParams()&lt;/code&gt; ... * @summary Método para ... * @method validateInputParams * @param {object} params - Parâmetros de entrada * @param {string} nodeID - ID do nó * @returns {undefined} - Se passar por todas validações retorna 'undefined' * @memberof add-tools-vault-api.vaultapp# */ validateInputParams(params, nodeID) { const regex = /^[A-Za-z0-9]+$/; let isValid = false; isValid = params?.secretAlias ? regex.test(params.secretAlias) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"secretAlias\", nodeID, \"vault\", ), ); return errorResponse; } isValid = params?.newSecretAlias ? regex.test(params.newSecretAlias) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"newSecretAlias\", nodeID, \"vault\", ), ); return errorResponse; } isValid = params?.secretType ? regex.test(params.secretType) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"secretType\", nodeID, \"vault\", ), ); return errorResponse; } isValid = params?.companyCode ? regex.test(params.companyCode) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"companyCode\", nodeID, \"vault\", ), ); return errorResponse; } // Se passou por todas validacoes retorna 'undefined' }, /** * @desc O method &lt;code&gt;addEncrypt()&lt;/code&gt; ... * @summary Método para ... * @method addEncrypt * @param {string} e - String a ser encriptada * @returns {string} - String encriptada * @memberof add-tools-vault-api.vaultapp# */ addEncrypt(e) { try { for ( var r = \"\", t = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", s = t.length, c = 0; c &lt; 15; c++ ) r += t.charAt(Math.floor(Math.random() * s)); return ( (e = this.encodeBase64(e)), (e = e.replace(\"=\", \".\")), (e = `${e.substring(0, 2)}W${r.substring( 0, 2, )}add${e.substring(2, e.length)}${r.substring( 2, r.length, )}`), e ); } catch (err) { return \"ERRO: Falha ao encriptar secret\"; } }, /** * @desc O method &lt;code&gt;addDecrypt()&lt;/code&gt; ... * @summary Método para ... * @method addDecrypt * @param {string} r - String a ser decriptada * @returns {string} - String decriptada * @memberof add-tools-vault-api.vaultapp# */ addDecrypt(r) { try { if (!r || r.length &lt; 10) return \"ERRO: secret invalido\"; if (r.length == 19) return \"\"; } catch (err) { return \"ERRO: Falha ao avaliar o secret\"; } try { let e = r.substring(0, 2) + r.substring(8, r.length - 13); return (e = e.replace(\".\", \"=\")), (e = this.decodeBase64(e)); } catch (r) { return \"ERRO: Falha ao realizar o decrypt do secret informado\"; } }, /** * @desc O method &lt;code&gt;encodeBase64()&lt;/code&gt; ... * @summary Método para ... * @method encodeBase64 * @param {string} str - String a ser codificada * @returns {string} - String codificada em base64 * @memberof add-tools-vault-api.vaultapp# */ encodeBase64(str) { return Buffer.from(str).toString(\"base64\"); }, /** * @desc O method &lt;code&gt;decodeBase64()&lt;/code&gt; ... * @summary Método para ... * @method decodeBase64 * @param {string} str - String a ser decodificada * @returns {string} - String decodificada em utf-8 * @memberof add-tools-vault-api.vaultapp# */ decodeBase64(str) { return Buffer.from(str, \"base64\").toString(\"utf-8\"); }, /** * @desc O method &lt;code&gt;deleteTempFiles()&lt;/code&gt; ... * @summary Método para ... * @method deleteTempFiles * @param {array} list - Lista de arquivos a serem excluidos * @memberof add-tools-vault-api.vaultapp# */ deleteTempFiles(list) { for (const a in list) { fs.unlinkSync(list[a]); } }, /** * @desc O method &lt;code&gt;readFromString()&lt;/code&gt; ... * @summary Método para ... * @method readFromString * @param {string} string - String a ser lida * @param {string} start - String de inicio * @param {string} end - String de fim * @returns {array} - Array de strings * @memberof add-tools-vault-api.vaultapp# */ readFromString(string, start, end) { const output = []; let offset = string.indexOf(start); while (offset !== -1) { string = string.substring(offset); let endOffset = string.indexOf(end); if (endOffset === -1) { break; } endOffset += end.length; output.push(string.substring(0, endOffset)); offset = string.indexOf(start, endOffset); } return output; }, /** * @desc O method &lt;code&gt;localConvertCertificate()&lt;/code&gt; ... * @summary Método para ... * @method localConvertCertificate * @param {string} certificateFile - Arquivo do certificado * @param {string} certificatePassword - Senha do certificado * @returns {object} - Objeto com chave e certificado * @memberof add-tools-vault-api.vaultapp# */ localConvertCertificate(certificateFile, certificatePassword) { if (!certificateFile || !certificatePassword) { return { context: \"ERROR\", statusInfo: { status: false, errorCode: \"503\", message: \"Parametros invalidos\", solution: \"Verificar parametros\", trace: null, }, }; } const pfx = certificateFile; const p12Password = certificatePassword; const KEY_START = \"-----BEGIN PRIVATE KEY-----\"; const KEY_END = \"-----END PRIVATE KEY-----\"; const CERT_START = \"-----BEGIN CERTIFICATE-----\"; const CERT_END = \"-----END CERTIFICATE-----\"; const tmpfiles = []; let args = [\"pkcs12\", \"-in\"]; const pfxFilePath = path.join( tmpdir, crypto.randomBytes(20).toString(\"hex\"), ); args.push(pfxFilePath); tmpfiles.push(pfxFilePath); fs.writeFileSync(pfxFilePath, pfx); const passwordFilePath = path.join( tmpdir, crypto.randomBytes(20).toString(\"hex\"), ); args.push(\"-passin\"); args.push(`file:${passwordFilePath}`); tmpfiles.push(passwordFilePath); fs.writeFileSync(passwordFilePath, p12Password); args.push(\"-nodes\"); let openssl = cp.spawnSync(\"openssl\", args); let stdout = openssl.stdout.toString(); let stderr = openssl.stderr.toString(); if (stderr != \"\") { return { context: \"ERROR\", statusInfo: { status: false, errorCode: \"ERR\", message: \"Não foi possivel converter o certificado\", solution: null, trace: stderr, }, }; } const keybundle = {}; const certs = this.readFromString(stdout, CERT_START, CERT_END); keybundle.cert = certs.shift(); keybundle.ca = certs; keybundle.key = this.readFromString( stdout, KEY_START, KEY_END, ).pop(); args = [\"rsa\", \"-in\"]; const privateKeyFilePath = path.join( tmpdir, crypto.randomBytes(20).toString(\"hex\"), ); args.push(privateKeyFilePath); tmpfiles.push(privateKeyFilePath); fs.writeFileSync(privateKeyFilePath, keybundle.key); openssl = cp.spawnSync(\"openssl\", args); stdout = openssl.stdout.toString(); stderr = openssl.stderr.toString(); keybundle.key = stdout; keybundle.key = this.encodeBase64(keybundle.key); keybundle.cert = this.encodeBase64(keybundle.cert); this.deleteTempFiles(tmpfiles); return { key: keybundle.key, cert: keybundle.cert, }; }, }, }; × Search results Close "},"add-tools-vault-api_src_services_vaultcommunication.service.js.html":{"id":"add-tools-vault-api_src_services_vaultcommunication.service.js.html","title":"Source: add-tools-vault-api/src/services/vaultcommunication.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-vault-api/src/services/vaultcommunication.service.js const path = require(\"path\"); const fs = require(\"fs\"); const vaultErrorMessage = require(\"classes/resources/vaultErrorMessage\"); const utilslib = require(\"add-base-utils-lib/libs/utils\"); const NodeRSA = require(\"node-rsa\"); const { SignedXml } = require(\"xml-crypto\"); const axios = require(\"axios\"); const https = require(\"https\"); process.env.NODE_TLS_REJECT_UNAUTHORIZED = \"0\"; /** * @desc O Serviço de vaultcommunication faz ... * @namespace add-tools-vault-api.vaultcommunication * @memberof add-tools-vault-api * @property {string} name - Nome do serviço * @todo @property {number} version - Versão do serviço * @property {array} mixins - Mixins do serviço * @property {object} metadata - Metadados do serviço * @property {object} settings - Configurações do serviço * @property {object} actions - Ações do serviço: &lt;strong&gt;send&lt;/strong&gt; * @property {object} methods - Métodos do serviço: &lt;code&gt;validateInputParams()&lt;/code&gt;, &lt;code&gt;addEncrypt()&lt;/code&gt;, &lt;code&gt;addDecrypt()&lt;/code&gt;, &lt;code&gt;encodeBase64()&lt;/code&gt;, &lt;code&gt;decodeBase64()&lt;/code&gt; */ module.exports = { name: \"vaultcommunication\", // version: 1, mixins: [], metadata: { $description: \"Vault Communication client API\" }, settings: { IDAPP: `${path.dirname(__filename).split(path.sep).pop()}`, rest: true, MONETIZATION: false, }, /** * @summary Actions do serviço * @property {object} send - Action send {@link add-tools-vault-api.vaultcommunication#send action send} * @memberof add-tools-vault-api.vaultcommunication# */ actions: { /** * @desc A ação send fez ... * @summary Ação send * @action send * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} params.secretAlias - Alias do certificado * @property {string} params.messageContent - Conteudo da mensagem * @property {string} [params.messageContentFormat] - Formato do conteudo da mensagem * @property {string} params.endpoint - Endpoint da mensagem * @property {string} params.method - Metodo da mensagem * @property {object} [params.headers] - Headers da mensagem * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vaultcommunication# */ send: { description: \"Communication Message\", // rest: \"POST /send\", params: { secretAlias: { type: \"string\", }, messageContent: { type: \"string\", }, messageContentFormat: { type: \"string\", // raw, escaped, base64 - default é base64 optional: true, }, endpoint: { type: \"string\", }, method: { type: \"string\", }, headers: { type: \"object\", optional: true, }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { if (!ctx.params.secretAlias) ctx.params.secretAlias = \"-\"; let response = \"Certificado não encontrado\"; const certificateObj = await ctx.call(\"vault.retrieveSecret\", { secretType: \"\", secretAlias: ctx.params.secretAlias, addDecrypt: \"X\", }); if ( certificateObj &amp;&amp; certificateObj?.data?.pbKey &amp;&amp; certificateObj?.data?.pvKey ) { response = \"Certificado ok\"; try { let txtResponseStatus; const msgdata = this.decodeBase64( ctx.params.messageContent, ); const endpoint = this.decodeBase64(ctx.params.endpoint); const privateKeyFile = this.decodeBase64( certificateObj.data.pvKey, ); const publicKeyFile = this.decodeBase64( certificateObj.data.pbKey, ); let commResponse = \"\"; let exResponse = \"\"; /// HTTP Service // const response = await ctx.call(\"HTTP.post\", { // url: endpoint, // opt: { // method: ctx.params.method, // responseType: \"json\", // headers: ctx.params.headers, // body: msgdata, // https: { // key: privateKeyFile, // certificate: publicKeyFile // } // }, // }); /// HTTP Service commResponse = await axios .request({ url: endpoint, method: ctx.params.method, headers: ctx.params.headers, data: msgdata, httpsAgent: new https.Agent({ cert: publicKeyFile, key: privateKeyFile, }), }) .then((response) =&gt; { txtResponseStatus = response.status; return Buffer.from(response.data); }) .then((data) =&gt; { if ( txtResponseStatus &amp;&amp; txtResponseStatus &lt; 400 ) { return data; } return { context: data, statusInfo: { status: false, errorCode: txtResponseStatus, message: \"Cod Retorno HTTP invalido\", solution: null, trace: \"HTTP error return\", }, }; }) .catch((err) =&gt; { exResponse = err; }); if (exResponse) { return { context: null, statusInfo: { status: false, errorCode: exResponse?.response?.status, message: exResponse?.message, solution: null, trace: exResponse?.response?.data, }, }; } if (commResponse) commResponse = this.encodeBase64(commResponse); return { context: commResponse, statusInfo: { status: true, errorCode: null, message: txtResponseStatus, solution: null, trace: null, }, }; } catch (error) { if (error?.statusInfo?.status == false) { return error; } return { context: error.name, statusInfo: { status: false, errorCode: error.code, message: error.message, solution: null, trace: null, }, }; } } else { return { context: certificateObj, statusInfo: { status: false, errorCode: null, message: null, solution: null, trace: null, }, }; } }, openapi: { responses: { 200: { description: \"Mensagem processada\", content: { \"application/json\": { schema: { type: \"object\", properties: { context: { type: \"string\", example: \"conteudo da resposta em base64\", }, statusInfo: { type: \"object\", properties: { status: { type: \"boolean\", example: \"true\", }, errorCode: { type: \"string\", example: \"200\", }, message: { type: \"string\", example: \"Nao foi possivel obter certificado apto para assinatura\", }, solution: { type: \"string\", example: \"Revisar os parametros\", }, trace: { type: \"string\", example: \"null\", }, }, }, }, }, }, }, }, }, }, }, }, methods: { /** * @desc O method &lt;code&gt;validateInputParams()&lt;/code&gt; ... * @summary Método para ... * @method validateInputParams * @param {object} params - Parâmetros de entrada * @param {string} nodeID - ID do node * @returns {undefined} - Se passar por todas validações retorna 'undefined' * @memberof add-tools-vault-api.vaultcommunication# */ validateInputParams(params, nodeID) { const regex = /^[A-Za-z0-9]+$/; let isValid = false; isValid = params?.secretAlias ? regex.test(params.secretAlias) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"secretAlias\", nodeID, \"vault\", ), ); return errorResponse; } isValid = params?.newSecretAlias ? regex.test(params.newSecretAlias) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"newSecretAlias\", nodeID, \"vault\", ), ); return errorResponse; } isValid = params?.secretType ? regex.test(params.secretType) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"secretType\", nodeID, \"vault\", ), ); return errorResponse; } isValid = params?.companyCode ? regex.test(params.companyCode) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"companyCode\", nodeID, \"vault\", ), ); return errorResponse; } // Se passou por todas validacoes retorna 'undefined' }, /** * @desc O method &lt;code&gt;addEncrypt()&lt;/code&gt; ... * @summary Método para ... * @method addEncrypt * @param {string} e - Secret a ser encriptado * @returns {string} - Secret encriptado * @memberof add-tools-vault-api.vaultcommunication# */ addEncrypt(e) { try { for ( var r = \"\", t = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", s = t.length, c = 0; c &lt; 15; c++ ) r += t.charAt(Math.floor(Math.random() * s)); return ( (e = this.encodeBase64(e)), (e = e.replace(\"=\", \".\")), (e = `${e.substring(0, 2)}W${r.substring( 0, 2, )}add${e.substring(2, e.length)}${r.substring( 2, r.length, )}`), e ); } catch (err) { return \"ERRO: Falha ao encriptar secret\"; } }, /** * @desc O method &lt;code&gt;addDecrypt()&lt;/code&gt; ... * @summary Método para ... * @method addDecrypt * @param {string} r - Secret a ser decriptado * @returns {string} - Secret decriptado * @memberof add-tools-vault-api.vaultcommunication# */ addDecrypt(r) { try { if (!r || r.length &lt; 10) return \"ERRO: secret invalido\"; if (r.length == 19) return \"\"; } catch (err) { return \"ERRO: Falha ao avaliar o secret\"; } try { let e = r.substring(0, 2) + r.substring(8, r.length - 13); return (e = e.replace(\".\", \"=\")), (e = this.decodeBase64(e)); } catch (r) { return \"ERRO: Falha ao realizar o decrypt do secret informado\"; } }, /** * @desc O method &lt;code&gt;encodeBase64()&lt;/code&gt; ... * @summary Método para ... * @method encodeBase64 * @param {string} str - String a ser codificada * @returns {string} - String codificada em base64 * @memberof add-tools-vault-api.vaultcommunication# */ encodeBase64(str) { return Buffer.from(str).toString(\"base64\"); }, /** * @desc O method &lt;code&gt;decodeBase64()&lt;/code&gt; ... * @summary Método para ... * @method decodeBase64 * @param {string} str - String a ser decodificada * @returns {string} - String decodificada em utf-8 * @memberof add-tools-vault-api.vaultcommunication# */ decodeBase64(str) { return Buffer.from(str, \"base64\").toString(\"utf-8\"); }, }, }; × Search results Close "},"add-tools-vault-api_src_services_vaultsignature.service.js.html":{"id":"add-tools-vault-api_src_services_vaultsignature.service.js.html","title":"Source: add-tools-vault-api/src/services/vaultsignature.service.js","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Source: add-tools-vault-api/src/services/vaultsignature.service.js const path = require(\"path\"); const vaultErrorMessage = require(\"classes/resources/vaultErrorMessage\"); const utilslib = require(\"add-base-utils-lib/libs/utils\"); /** * @desc O Serviço de vaultsignature faz ... * @namespace add-tools-vault-api.vaultsignature * @memberof add-tools-vault-api * @property {string} name - Nome do serviço * @todo @property {number} version - Versão do serviço * @property {array} mixins - Mixins do serviço * @property {object} metadata - Metadados do serviço * @property {object} settings - Configurações do serviço * @property {object} actions - Ações do serviço &lt;strong&gt;sign&lt;/strong&gt; * @property {object} methods - Métodos do serviço &lt;code&gt;validateInputParams()&lt;/code&gt;, &lt;code&gt;addEncrypt()&lt;/code&gt;, &lt;code&gt;addDecrypt()&lt;/code&gt;, &lt;code&gt;encodeBase64()&lt;/code&gt;, &lt;code&gt;decodeBase64()&lt;/code&gt; */ module.exports = { name: \"vaultsignature\", // version: 1, mixins: [], metadata: { $description: \"Vault Signature client API\" }, settings: { IDAPP: `${path.dirname(__filename).split(path.sep).pop()}`, rest: true, MONETIZATION: false, }, /** * @summary Actions do serviço * @property {object} sign - Action sign {@link add-tools-vault-api.vaultsignature#sign action sign} * @memberof add-tools-vault-api.vaultsignature# */ actions: { /** * @desc A ação sign faz ... * @summary Ação sign * @action sign * @property {string} description - Descrição da action * @todo @property {string} rest - Rota da action * @property {object} params - Parâmetros da action * @property {string} params.secretAlias - Alias do certificado * @property {string} params.messageContent - Conteúdo da mensagem * @property {string} [params.messageContentFormat] - Formato do conteúdo da mensagem * @property {string} params.signatureModel - Modelo de assinatura * @property {string} [params.tag] - Tag * @property {string} [params.uri] - URI * @property {boolean} [params.emptyUri] - URI vazia * @property {array} [params.transforms] - Transformações * @property {string} [params.canonicalizationAlgorithm] - Algoritmo de canonicalização * @property {string} [params.location] - Localização * @property {string} [params.locationTag] - Tag de localização * @property {array} permissions - Permissões da action * @memberof add-tools-vault-api.vaultsignature# */ sign: { description: \"Sign Message\", // rest: \"POST /sign\", params: { secretAlias: { type: \"string\", }, messageContent: { type: \"string\", }, messageContentFormat: { type: \"string\", // raw, escaped, base64 - default é base64 optional: true, }, signatureModel: { type: \"string\", // nfe, nfse, satmx, etc }, tag: { type: \"string\", // infevento optional: true, }, uri: { type: \"string\", optional: true, }, emptyUri: { type: \"boolean\", optional: true, }, transforms: { type: \"array\", optional: true, }, canonicalizationAlgorithm: { type: \"string\", optional: true, }, location: { type: \"string\", // append (default), prepend, before (using locationTag), after (using locationTag) optional: true, }, locationTag: { type: \"string\", optional: true, }, }, permissions: [\"add-tools-vault-api\", \"ORG\"], async handler(ctx) { if (!ctx.params.secretAlias) ctx.params.secretAlias = \"-\"; const certificateObj = await ctx.call(\"vault.retrieveSecret\", { secretType: \"\", secretAlias: ctx.params.secretAlias, addDecrypt: \"X\", }); if ( certificateObj &amp;&amp; certificateObj?.data?.pbKey &amp;&amp; certificateObj?.data?.pvKey ) { const privateKeyFile = this.decodeBase64( certificateObj.data.pvKey, ); const publicKeyFile = this.decodeBase64( certificateObj.data.pbKey, ); const signatureImpl = require(\"classes/resources/SignatureObjectFactory\").signatureObjectFactory( ctx.params, ctx.params?.signatureModel, ); const signatureResponse = await signatureImpl.sign( ctx.params, privateKeyFile, publicKeyFile, ); return signatureResponse; } return { context: null, statusInfo: { status: false, errorCode: 503, message: \"Nao foi possivel obter certificado apto para assinatura\", solution: \"Revisar os parametros\", trace: null, }, }; }, openapi: { responses: { 200: { description: \"Secret obtido com sucesso\", content: { \"application/json\": { schema: { type: \"object\", properties: { context: { type: \"string\", example: \"conteudo da resposta em base64\", }, statusInfo: { type: \"object\", properties: { status: { type: \"boolean\", example: \"true\", }, errorCode: { type: \"string\", example: \"200\", }, message: { type: \"string\", example: \"Nao foi possivel obter certificado apto para assinatura\", }, solution: { type: \"string\", example: \"Revisar os parametros\", }, trace: { type: \"string\", example: \"null\", }, }, }, }, }, }, }, }, }, }, }, }, methods: { /** * @desc O method &lt;code&gt;validateInputParams()&lt;/code&gt; ... * @summary Método para ... * @method validateInputParams * @param {object} params - Parâmetros da action * @param {object} nodeID - ID do nó * @returns {undefined} - Se passou por todas validacoes retorna 'undefined' * @memberof add-tools-vault-api.vaultsignature# */ validateInputParams(params, nodeID) { const regex = /^[A-Za-z0-9]+$/; let isValid = false; isValid = params?.secretAlias ? regex.test(params.secretAlias) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"secretAlias\", nodeID, \"vault\", ), ); return errorResponse; } isValid = params?.newSecretAlias ? regex.test(params.newSecretAlias) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"newSecretAlias\", nodeID, \"vault\", ), ); return errorResponse; } isValid = params?.secretType ? regex.test(params.secretType) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"secretType\", nodeID, \"vault\", ), ); return errorResponse; } isValid = params?.companyCode ? regex.test(params.companyCode) : true; if (!isValid) { var errorResponse = vaultErrorMessage.getErrorMessageObj( \"ValidationError\", \"Parameters validation error!\", 422, \"VALIDATION_ERROR\", null, vaultErrorMessage.getErrorMessageDataObj( \"required\", \"Caracter Invalido nos parametros de entrada\", \"companyCode\", nodeID, \"vault\", ), ); return errorResponse; } // Se passou por todas validacoes retorna 'undefined' }, /** * @desc O method &lt;code&gt;addEncrypt()&lt;/code&gt; ... * @summary Método para ... * @method addEncrypt * @param {string} e - Parâmetros da action * @memberof add-tools-vault-api.vaultsignature# */ addEncrypt(e) { try { for ( var r = \"\", t = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", s = t.length, c = 0; c &lt; 15; c++ ) r += t.charAt(Math.floor(Math.random() * s)); return ( (e = this.encodeBase64(e)), (e = e.replace(\"=\", \".\")), (e = `${e.substring(0, 2)}W${r.substring( 0, 2, )}add${e.substring(2, e.length)}${r.substring( 2, r.length, )}`), e ); } catch (err) { return \"ERRO: Falha ao encriptar secret\"; } }, /** * @desc O method &lt;code&gt;addDecrypt()&lt;/code&gt; ... * @summary Método para ... * @method addDecrypt * @param {string} r - Parâmetros da action * @returns {string} - Retorna o secret descriptografado * @memberof add-tools-vault-api.vaultsignature# */ addDecrypt(r) { try { if (!r || r.length &lt; 10) return \"ERRO: secret invalido\"; if (r.length == 19) return \"\"; } catch (err) { return \"ERRO: Falha ao avaliar o secret\"; } try { let e = r.substring(0, 2) + r.substring(8, r.length - 13); return (e = e.replace(\".\", \"=\")), (e = this.decodeBase64(e)); } catch (r) { return \"ERRO: Falha ao realizar o decrypt do secret informado\"; } }, /** * @desc O method &lt;code&gt;encodeBase64()&lt;/code&gt; ... * @summary Método para ... * @method encodeBase64 * @param {string} str - Parâmetros da action * @returns {string} - Retorna o secret criptografado em base64 * @memberof add-tools-vault-api.vaultsignature# */ encodeBase64(str) { return Buffer.from(str).toString(\"base64\"); }, /** * @desc O method &lt;code&gt;decodeBase64()&lt;/code&gt; ... * @summary Método para ... * @method decodeBase64 * @param {string} str - Parâmetros da action * @returns {string} - Retorna o secret descriptografado em utf-8 * @memberof add-tools-vault-api.vaultsignature# */ decodeBase64(str) { return Buffer.from(str, \"base64\").toString(\"utf-8\"); }, }, }; × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Classes Classes Settings Namespaces add-tools-browser-api add-tools-drive-api add-tools-http-api add-tools-mail-api add-tools-ocr-api add-tools-platform-api add-tools-vault-api × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespaces Classes Settings Namespaces add-tools-browser-api add-tools-drive-api add-tools-http-api add-tools-mail-api add-tools-ocr-api add-tools-platform-api add-tools-vault-api × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Plano de Testes Addson / Addtax Cloud - Versão 1.1 Esta documentação descreve a aplicação de processos de qualidade de software Histórico de Revisões Data Versão Descrição Autor 24/07/2023 1.0 Versão Inicial RCruz 05/09/2023 1.1 Inclusão de Prettier e ESLint RCruz 08/12/2023 1.2 Documentação do módulo Tools Kelvya Mendonça Índice 1. Introdução Objetivos Addtax Cloud Addson Escopo Identificação de Projeto 2. Itens de Teste Microsserviços Banco de Dados Armazenamento de Arquivos Autenticação e Autorização Teste de componentes Teste de Segurança e de Controle de Acesso Teste da Interface do Usuário Teste de Performance Teste de Carga 3. Estratégia de Teste Tipos de Teste Documentação de Testes Ferramentas 4. Recursos Habilidades Requeridas Instalação de bibliotecas Introdução Objetivos Esse documento do Plano de Testes do sistema Addson compõe-se dos seguintes objetivos: • Identificar informações de projeto existentes e os componentes de software que devem ser testados. • Listar os itens de teste recomendados. • Recomendar e descrever as estratégias de teste a serem empregadas. • Identificar os recursos necessários e prover uma estimativa dos esforços de teste. • Listar os elementos resultantes do projeto de testes. Addtax Cloud O AddTax é um sistema desenvolvido para automatizar o recebimento de documentos fiscais e não fiscais eletrônicos. Com o propósito de melhorar os fluxos de processamento e racionalizar a gestão de documentos fiscais eletrônicos, a fim de mitigar possíveis problemas no recebimento. Addson É um produto desenvolvido pela Addvisor com o propósito de gerenciar clientes, usuários, aplicativos e fornecer API's que otimizam tarefas manuais, controlam custos e garantem a segurança das aplicações. Escopo O sistema passará pelos testes de unidade, de integração, testes funcionais, também chamados de end-to-end e testes de carga. Os testes unitários e de integração vão lidar com a qualidade das funcionalidades, do sistema de bases de dados. Nesta fase será possível usar dados simulados e estes testes serão executados na máquina local de cada desenvolvedor e também estará vinculado ao sistema de implantação. Os testes funcionais testarão toda uma jornada do usuário, incluindo a interface do usuário e deverá ser executado em sistema idêntico a produção. Os testes de carga tratarão as questões de performance e infraestrutura e deverão ser realizados em ambiente controlado. Identificação de Projeto A tabela abaixo identifica os artefatos existentes necessários para desenvolver o plano de testes: Documento Existente Documento de arquitetura ✅ Protótipo ✅ Especificação de requisitos ❎ Manual do usuário ❎ Documento de riscos ❎ Documentação técnica ❎ 2. Itens de teste A lista abaixo identifica aqueles itens que foram identificados como alvos de teste. Essa lista representa o que será testado. Microsserviços Verificar que o funcionamento de cada rotina no nível mais unitário esteja funcionando conforme o esperado. Verificar que o código possua boas práticas de programação. Banco de Dados Verificar que os serviços que persistem dados possam realizar as seguintes ações: list (Lista todos os registros) find (Lista com mais opções de filtro) get (Seleciona pelo ID) count (Contagem de registros) create (Cria um registro) replace (Substitui o registro completo) update (Atualiza parte do registro) remove (Deleta o registro) Verificar que as ações adicionais customizadas por meio de mixins sejam executadas corretamente. Armazenamento de Arquivos Verificar que o sistema de armazenamento de arquivos esteja se comunicando corretamente com o repositório em nuvem. Autenticação e Autorização Verificar que os serviços estejam se comunicação corretamente com o provedor de identidade. Teste de Componentes Verificar que os seguintes processos estejam funcionando: Coleta de documentos Extração de dados Execução de processos Verificar que os seguintes aplicativos estejam funcionando: CRM User Management App Management Teste de Segurança e de Controle de Acesso Verificar que usuários não cadastrados não possam acessar o sistema. Verificar que os usuários somente acessam as informações que pertencem ao mandante deles. Verificar que os usuários do sistema podem acessar apenas as funcionalidades associadas ao seu usuário. Verificar que além do perfil administrador, ninguém mais pode inserir, atualizar ou remover dados que pertencem ao proprietário do sistema. Teste da Interface do Usuário Verificar que o usuário possa efetuar um processo de autenticação Verificar que o usuário possa acessar as interfaces gráficas que tenha direito. Verificar que os componentes gráficos estejam funcionando corretamente. Teste de Performance Verificar que o tempo de resposta dos serviços esteja abaixo do tempo máximo de espera. Verificar que o tempo de resposta das interfaces gráficas esteja de acordo com o esperado. Teste de Carga Verificar a resposta do sistema com 10 usuários usando uma determinada parte do sistema ao mesmo. Verificar a resposta do sistema com 100 usuários usando uma determinada parte do sistema ao mesmo tempo. Verificar a resposta do sistema com 1000 usuários usando uma determinada parte do sistema ao mesmo tempo. 3. Estratégia de Teste Tipos de Teste Testes unitários: Exercita a menor parte testável e determina se ele se comporta conforme o esperado, realizado em nível de método, ou função, validando regras de negócios. Exemplo: Tipo de campo, Obrigatoriedade de campos, Tamanho máximo, parâmetros e retorno. A ferramenta Jest será usada para comparar o resultado recebido com o resultado esperado, gerando relatório com o resultado dos testes e o percentual de cobertura de código. Testes integrados: Os testes de integração verificam como diferentes unidades do software funcionam juntos. Isso inclui testar interfaces, comunicação entre serviços e a integração com sistemas externos, como bancos de dados e APIs. A ferramenta Jest será usada para comparar o resultado recebido com o resultado esperado, gerando relatório com o resultado dos testes e o percentual de cobertura de código. Testes de componentes: Limita o escopo em uma parte do sistema testado. Aqui, todo um serviço ou módulo pode ser testado. A ferramenta Playwright será usada para simular a navegação de um usuário pelo processo. Testes de Interface de usuário: Verifica a funcionalidade do sistema focando em usabilidade, experiência do usuário, consistência das telas, layout, etc. E também pode incluir testes de acessibilidade que garantem que pessoas com algum tipo de necessidade especial também possam operar o sistema como, necessidade visual, física, auditiva, etc. É neste nível que também pode ser automatizado um teste end-to-end, que representa toda a jornada de um usuário em determinado processo. A ferramenta Playwright será usada para simular a navegação de um usuário pelo processo. Testes exploratórios: Testes manuais visando explorar comportamentos atípicos dos usuários. (Dedo gordo, caminho infeliz, etc) Teste de carga: A ferramenta Jmeter será usada para simular acessos simultâneos ao sistema. Documentação de Testes Uma documentação será gerada usando a ferramenta JSdoc, detalhando tecnicamente os requisitos que serão testados. Ferramentas As seguintes ferramentas serão empregadas para esse projeto: Jest Playwright Apache Jmeter JSdoc Recursos Essa seção apresenta os recursos recomendados para formar parte de uma equipe de Qualidade, suas principais responsabilidades, seus conhecimentos ou conjunto de habilidades. Habilidades Requeridas Essa tabela mostra as suposições de recrutamento para o projeto. Função Responsabilidades Diretor de qualidade Fornece supervisionamento gerencial. Responsabilidades: Prover direcionamento técnico, adquirir e administrar os recursos necessários, avaliar a eficiência do esforço de teste, fornecer relatórios de gerenciamento Engenheiro de qualidade Identificar, priorizar, e implementar os casos de teste. Responsabilidades: Gerar o plano de teste, implementar a arquitetura de testes, avaliar a qualidade do produto, documentar a execução dos testes Analista de testes Implementa e executa os testes. Responsabilidades: Implementar os testes, garantir a execução dos testes, registrar os resultados, analisar as falhas, documentar os incidentes Administrador do sistema de testes Garante que o ambiente e os bens de teste sejam gerenciados e mantidos. Responsabilidades: Administrar o sistema de gerenciamento de testes, garantir o funcionamento dos ambientes de testes, administrar os bancos de dados usados para teste, Instalações de bibliotecas Descreve o procedimento de instalação das bibliotecas comuns que podem ser necessárias na formatação e inspeção do código assim como a execução de testes. Prettier - Formatação de código npm install prettier -D .prettierrc { \"printWidth\": 120, \"singleQuote\": false, \"tabWidth\": 2, \"useTabs\": false, \"trailingComma\": \"none\", \"arrowParens\": \"avoid\", \"bracketSpacing\":true } ESLint - Inspeção de código npm init @eslint/config ✔ How would you like to use ESLint? · style ✔ What type of modules does your project use? · commonjs ✔ Which framework does your project use? · none ✔ Does your project use TypeScript? · No ✔ Where does your code run? · node ✔ How would you like to define a style for your project? · guide ✔ Which style guide do you want to follow? · airbnb ✔ What format do you want your config file to be in? · JavaScript ✔ Would you like to install them now? · No / Yes ? Which package manager do you want to use? npm npm install eslint-config-prettier -D extends: [\"airbnb-base\", \"prettier\"], ignorePatterns: [\"**/test/**\"], Jest - Testes npm install jest jest-cli -D npm install jest-extended -D package.json \"jest\": { \"coverageDirectory\": \"./src/services/test/coverage\", \"collectCoverageFrom\": [ \"src/services/*.js\" ], \"coveragePathIgnorePatterns\": [ \"src/services/test/\" ], \"testEnvironment\": \"node\", \"moduleFileExtensions\": [ \"ts\", \"tsx\", \"js\" ], \"testMatch\": [ \"**/*.spec.(ts|js)\" ], \"setupFilesAfterEnv\": [ \"jest-extended/all\" ] } JSDoc - Documentação npm install jsdoc ink-docstrap taffydb -D Copiar README.md com Plano de testes conf.json { \"templates\": { \"systemName\": \"Addson\", \"theme\": \"cerulean\", \"copyright\" : \"© Addson - 2023\", \"outputSourceFiles\": true, \"outputSourcePath\": true, \"linenums\" : true, \"sort\": false, \"inverseNav\": true }, \"opts\": { \"template\": \"./node_modules/ink-docstrap/template\", \"destination\": \"./src/services/test/doc\", \"recurse\": true, \"readme\": \"./src/services/test/README.md\" } } Dockerfile e docker-compose É necessário ajustar o dockerfile para build multi stage test e prod É necessário criar um docker-compose local para efeito de teste unitário FROM base as test RUN npm install --include=dev COPY . . CMD [\"npm\", \"run\", \"test\"] FROM base as prod RUN npm pkg delete scripts.prepare &amp;&amp; npm install --omit-dev COPY . . CMD [\"npm\", \"start\"] NPM Scripts Formatação de código npm run prettier Inspeção de código npm run dc:lint Testes Automatizados npm run dc:test Geração de Documentação npm run jsdoc Instalação dependências Dev npm install --only=dev \"ci\": \"jest --watch --verbose\", \"test\": \"jest --verbose\", \"test:unit\": \"jest\", \"jsdoc\": \"jsdoc -c ./src/services/test/conf.json ./src/services/test\", \"lint\": \"eslint src/services --fix\", \"prettier\": \"npx prettier src/services '!src/services/test' --write\", \"dc:lint\": \"docker-compose -f docker-compose.yml build &amp;&amp; docker-compose -f docker-compose.yml run tax-00100-api npm run lint\", \"dc:test\": \"docker-compose -f docker-compose.yml build &amp;&amp; docker-compose -f docker-compose.yml run *app* npm run test\", Pre Commit npx husky-init &amp;&amp; npm install npm run prettier npm run lint npm run dc:test Git Hub Actions unit.yml # Teste de Unidade name: Unit Test on: push: branches: - '**' paths-ignore: - '.vscode/**' - '*.md' workflow_dispatch: jobs: test: runs-on: ubuntu-latest strategy: matrix: node-version: [16.x, 18.x, 20.x] fail-fast: false steps: - uses: actions/checkout@v2 with: submodules: 'true' token: ${{ secrets.PAT_TOKEN }} - name: Use Node.js ${{ matrix.node-version }} uses: actions/setup-node@v1 with: node-version: ${{ matrix.node-version }} - name: Install dependencies run: | npm install - name: Run unit tests run: npm run test:unit × Search results Close "},"add-tools-browser-api.html":{"id":"add-tools-browser-api.html","title":"Namespace: add-tools-browser-api","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: add-tools-browser-api add-tools-browser-api add-tools-browser-api Source: add-tools-browser-api/src/services/BA2933307.service.js, line 5 Namespaces BA2933307 BROWSER GOVBR PR4106902 RJ3304557 Testes × Search results Close "},"add-tools-browser-api.BA2933307.html":{"id":"add-tools-browser-api.BA2933307.html","title":"Namespace: BA2933307","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: BA2933307 add-tools-browser-api. BA2933307 O Serviço BA2933307 automatiza o navegador para baixar documentos do Rio de Janeiro Properties: Name Type Description name string Nome do serviço, que obtém o nome do arquivo atual sem a extensão settings object Configurações internas do serviço Properties Name Type Description IDAPP string ID do APP que pode ser usado em permissões para chamar este serviço Source: add-tools-browser-api/src/services/BA2933307.service.js, line 9 Members actions Actions do serviço Properties: Name Type Description getDocuments object Baixa documentos do Rio de Janeiro action getDocuments Source: add-tools-browser-api/src/services/BA2933307.service.js, line 26 Actions getDocuments Action getDocuments A ação getDocuments automatiza a tarefa de navegar até um site, fazer login, navegar até uma página específica, inserir algumas informações e baixar um documento. Properties: Name Type Description description string Descrição breve da ação usada em listas automáticas params object Parâmetros da ação Properties Name Type Description REQ_XML string string contendo xml com os dados para baixar documentos do Rio de Janeiro secretAlias string é o alias do secret que contém o usuário e senha para acessar o site do Rio de Janeiro cache boolean Cache da ação Source: add-tools-browser-api/src/services/BA2933307.service.js, line 27 Returns: Retorna uma string como o conteúdo do arquivo envolvido com a tag ListNFSe Type string Example Chamada da ação getDocuments const result = await ctx.call(\"BA2933307.getDocuments\", { REQ_XML: \"&lt;xml&gt;Seu XML aqui&lt;/xml&gt;\", secretAlias: \"aliasDoSeuSecret\" }); console.log(result); // Exibe o conteúdo do arquivo baixado × Search results Close "},"add-tools-browser-api.BROWSER.html":{"id":"add-tools-browser-api.BROWSER.html","title":"Namespace: BROWSER","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: BROWSER add-tools-browser-api. BROWSER O Serviço BROWSER é responsável por automatizar a navegação em um site via navegador Properties: Name Type Description name string Nome do serviço mixins array Usado para distribuir funcionalidades reutilizáveis para os serviços metadata object Usado para armazenar qualquer metadados do serviço Properties Name Type Description $description string Descrição breve do serviço usada em listas automáticas settings object Configurações internas do serviço Properties Name Type Description IDAPP string ID do APP que pode ser usado em permissões Source: add-tools-browser-api/src/services/BROWSER.service.js, line 9 To Do: @property {boolean} settings.rest - Se estiver marcado, o serviço será acessível via REST Members actions Actions do serviço Properties: Name Type Description viewDacte object Gera a visualização DACTE action viewDacte download object Efetua download de arquivos action download urlToPdf object Converte uma página web em PDF action urlToPdf Source: add-tools-browser-api/src/services/BROWSER.service.js, line 35 Actions viewDacte Ação viewDacte Gera a visualização DACTE A action viewDacte é responsável por gerar a visualização do Dacte. Esta função está no container Browser devido ao grande tamanho do contêiner 2000 Properties: Name Type Description rest string Rota da ação: \"POST /\" description string Descrição breve da ação usada em listas automáticas params object Parâmetros da ação Properties Name Type Description doc Object documento XML Source: add-tools-browser-api/src/services/BROWSER.service.js, line 36 Returns: pdfBase64String - Arquivo PDF em base64 Type string download Ação download Efetua download de arquivos Properties: Name Type Description rest string Rota da ação: \"POST /\" description string Descrição breve da ação usada em listas automáticas permissions function Permissões da action params object Parâmetros da ação Properties Name Type Argument Default Description responseType String &lt;optional&gt; \"BASE64\" Tipo de resposta, um enum que pode ter as seguintes opções: \"PDF\" - Exibe o retorno como arquivo PDF \"GIF\" - Exibe o retorno como arquivo GIF \"XML\" - Exibe o retorno como arquivo XML \"BASE64\" - Exibe o retorno como Base64 browser String &lt;optional&gt; \"firefox\" Navegador a ser utilizado, um enum que pode ter as seguintes opções: \"chromium\" - Usa o Chromium como Engine \"firefox\" - Usa o Firefox como engine \"webkit\" - Usa o webkit como engine visible Boolean &lt;optional&gt; Exibe o navegador durante o processamento steps Array Um array de objetos no qual cada item do array é um objeto que representa uma etapa específica no processo. Properties Name Type Description items Object Objeto que representa uma etapa específica no processo. Properties Name Type Description props Object Propriedades do objeto que representa uma etapa específica no processo. Properties Name Type Argument Description type String Tipo de passo a ser realizado, um enum que pode ter as seguintes opções: \"URL\" - Navega para uma URL \"LINK\" - Download de Link direto para arquivo \"CLICK\" - Clica em um elemento da página \"CLICKDOWNLOAD\" - Clica em um seletor e faz Download \"AWAITDOWNLOAD\" - Clica em um seletor e faz Download \"POPUP\" - Aguarda popup e faz download baseado em seletor \"IMG\" - Download de imagem incorporada em uma página \"PORTO\" - Caminho personalizado \"PDF\" - Gera PDF da URL \"CONTENT\" - Retorna o conteúdo da página value String &lt;optional&gt; Valor do passo a ser executado. Nota: este campo é opcional, mas se presente, não pode ser uma string vazia. Source: add-tools-browser-api/src/services/BROWSER.service.js, line 633 To Do: @property {string} params.url - url a ser processada Returns: - Se uma das ações que definem o retorno for realizada, a função retornará o resultado dessa ação. Caso contrário, retornará a string \"Solicitação recebida\". Type String | Object urlToPdf Ação urlToPdf A action urlToPdf converte uma URL em um PDF, criando um PDF da página web aberta, com certas configurações de margem e formato. Ela verifica se o parâmetro urlBase64 foi fornecido. Se sim, ele decodifica a URL que foi codificada em base64. Caso contrário, usa a URL fornecida diretamente. Properties: Name Type Description rest String Rota da ação: \"POST /urlToPdf\" description String Descrição breve da ação usada em listas automáticas params Object Parâmetros da ação Properties Name Type Argument Description url String &lt;optional&gt; URL a ser processada urlBase64 string &lt;optional&gt; URL a ser processada em Base64 Source: add-tools-browser-api/src/services/BROWSER.service.js, line 862 Throws: Se ocorrer algum erro durante esse processo, ele será registrado no console. Returns: Retorna o PDF criado. Methods createPage(ctx) Método createPage O method createPage inicia o navegador com o motor selecionado, cria um novo contexto de navegador com configurações específicas (aceitar downloads e ignorar erros HTTPS) e cria uma nova página nesse contexto. Parameters: Name Type Description ctx object Contexto da requisição Properties Name Type Description params.visible boolean Exibe o navegador durante o processamento params.browser string Navegador a ser utilizado, um enum que pode ter as seguintes opções: \"chromium\" - Usa o Chromium como Engine \"firefox\" - Usa o Firefox como engine \"webkit\" - Usa o webkit como engine Source: add-tools-browser-api/src/services/BROWSER.service.js, line 942 Returns: - Retorna um objeto contendo a página criada e o navegador iniciado. Type object goToUrl(page, url) método goToUrl O method goToUrl navega para uma URL específica em uma página de navegador e espera até que um elemento com o ID \"Form1\" esteja anexado ao DOM. Parameters: Name Type Description page object Página do navegador, representa uma única guia ou janela de navegador url string URL para a qual a página deve navegar Source: add-tools-browser-api/src/services/BROWSER.service.js, line 991 link(ctx, url) método link O method link faz uma solicitação HTTP GET para uma URL específica e retorna os dados da resposta. Parameters: Name Type Description ctx object Contém os parâmetros da solicitação e métodos para interagir com o serviço. url string URL para a qual a solicitação HTTP GET deve ser feita. Source: add-tools-browser-api/src/services/BROWSER.service.js, line 1003 Throws: Se ocorrer algum erro durante esse processo, ele será registrado no console. Returns: - Retorna uma Promise que resolve para uma string base64 ou um buffer, dependendo do parâmetro responseType. Type Promise click(page, selector) método click O method click executa a ação de um click em um seletor da página Parameters: Name Type Description page object Página do navegador, representa uma única guia ou janela de navegador selector string Seletor do elemento a ser clicado Source: add-tools-browser-api/src/services/BROWSER.service.js, line 1034 clickDownload(ctx, page, selector) Método para efetuar download O method clickDownload efetua a ação de clique e aguarda pelo evento de download Parameters: Name Type Description ctx object Contexto da requisição page object Página do navegador selector string Seletor do elemento a ser clicado Source: add-tools-browser-api/src/services/BROWSER.service.js, line 1046 awaitDownload(ctx, page) Método para download direto O method awaitDownload aguarda por um evento direto de download Parameters: Name Type Description ctx object Contexto da requisição page object Página do navegador Source: add-tools-browser-api/src/services/BROWSER.service.js, line 1073 popup(ctx, page, selector) Método para tratar popups O method popup aguarda um popup ser aberto e faz o download do arquivo baseado no seletor informado Parameters: Name Type Description ctx object Contexto da requisição page object Página do navegador selector string Seletor do elemento a ser clicado Source: add-tools-browser-api/src/services/BROWSER.service.js, line 1096 img(ctx, page, selector) Método para download de imagem O method img() faz o download de uma imagem via http Parameters: Name Type Description ctx object Contexto da requisição page object Página do navegador selector string Seletor do elemento a ser clicado Source: add-tools-browser-api/src/services/BROWSER.service.js, line 1139 pdf(ctx, page, url) Método para conversão em formato PDF O method pdf() retorna o conteúdo da página em formato PDF Parameters: Name Type Description ctx object Contexto da requisição page object Página do navegador url string URL a ser processada Source: add-tools-browser-api/src/services/BROWSER.service.js, line 1178 content(ctx, page) Método para retornar o conteúdo da página O method content() retorna o conteúdo da página Parameters: Name Type Description ctx object Contexto da requisição page object Página do navegador Source: add-tools-browser-api/src/services/BROWSER.service.js, line 1201 returnBin(ctx, data) Método para retornar um arquivo binário O method returnBin() retorna um arquivo binário Parameters: Name Type Description ctx object Contexto da requisição data object Dados a serem processados Source: add-tools-browser-api/src/services/BROWSER.service.js, line 1216 returnBase64(data) Método para encode base64 O method returnBase64() converte o conteúdo para base64 Parameters: Name Type Description data object Dados a serem processados Source: add-tools-browser-api/src/services/BROWSER.service.js, line 1253 × Search results Close "},"add-tools-browser-api.GOVBR.html":{"id":"add-tools-browser-api.GOVBR.html","title":"Namespace: GOVBR","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: GOVBR add-tools-browser-api. GOVBR O Serviço de GOVBR acessa páginas desse sistema para obter o conteúdo de arquivos Properties: Name Type Description name string Nome do serviço, que obtém o nome do arquivo atual sem a extensão settings object Configurações do serviço actions object Ações do serviço: getDocuments Source: add-tools-browser-api/src/services/GOVBR.service.js, line 6 To Do: property {object} methods - Métodos do serviço NomeDoMétodo() Members actions Actions do serviço Properties: Name Type Description getDocuments object Action getDocuments action getDocuments Source: add-tools-browser-api/src/services/GOVBR.service.js, line 25 Actions getDocuments Ação getDocuments Ação para baixar documentos de GOVBR Properties: Name Type Description rest string Rota da action description string Descrição da action params object Parâmetros da action Properties Name Type Description REQ_XML string Parâmetro REQ_XML secretAlias string Parâmetro secretAlias cache boolean Cache da action Source: add-tools-browser-api/src/services/GOVBR.service.js, line 26 Returns: Retorna uma string como o conteúdo do arquivo envolvido com a tag ListNFSe Type string × Search results Close "},"add-tools-browser-api.PR4106902.html":{"id":"add-tools-browser-api.PR4106902.html","title":"Namespace: PR4106902","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: PR4106902 add-tools-browser-api. PR4106902 O Serviço de PR4106902 baixa documentos de Curitiba Properties: Name Type Description name string Nome do serviço, que obtém o nome do arquivo atual sem a extensão settings object Configurações do serviço actions object Ações do serviço: getDocuments Source: add-tools-browser-api/src/services/PR4106902.service.js, line 6 To Do: property {object} methods - Métodos do serviço NomeDoMétodo() Members actions actions Properties: Name Type Description getDocuments object Action getDocuments Source: add-tools-browser-api/src/services/PR4106902.service.js, line 25 Actions getDocuments Action getDocuments Ação para baixar documentos Properties: Name Type Description rest string Rota da action description string Descrição da action params object Parâmetros da action Properties Name Type Description REQ_XML string Parâmetro REQ_XML secretAlias string Parâmetro secretAlias cache boolean Cache da action Source: add-tools-browser-api/src/services/PR4106902.service.js, line 26 Returns: fileContent Type string | buffer × Search results Close "},"add-tools-browser-api.RJ3304557.html":{"id":"add-tools-browser-api.RJ3304557.html","title":"Namespace: RJ3304557","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: RJ3304557 add-tools-browser-api. RJ3304557 O Serviço RJ3304557 ... Properties: Name Type Description name string Nome do serviço, que obtém o nome do arquivo atual sem a extensão settings object Configurações do serviço Properties Name Type Argument Description IDAPP string &lt;optional&gt; ID do APP que pode ser usado em permissões actions object Ações do serviço: getDocuments Source: add-tools-browser-api/src/services/RJ3304557.service.js, line 6 To Do: @property {object} methods - Métodos do serviço: NomeDoMétodo() Members actions Actions do serviço Properties: Name Type Description getDocuments object Action getDocuments Source: add-tools-browser-api/src/services/RJ3304557.service.js, line 26 Actions getDocuments Action getDocuments Ação para ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Description REQ_XML string Parâmetro REQ_XML secretAlias string Parâmetro secretAlias cache boolean Cache da action Source: add-tools-browser-api/src/services/RJ3304557.service.js, line 27 Returns: Retorna ... Type string × Search results Close "},"add-tools-browser-api.Testes.html":{"id":"add-tools-browser-api.Testes.html","title":"Namespace: Testes","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: Testes add-tools-browser-api. Testes Testes para os serviços contidos em add-tools-ocr-api Source: add-tools-browser-api/src/services/test/unit/BA2933307.service.spec.js, line 9 Namespaces BA2933307 BROWSER GOVBR PR4106902 RJ3304557 × Search results Close "},"add-tools-browser-api.Testes.BA2933307.html":{"id":"add-tools-browser-api.Testes.BA2933307.html","title":"Namespace: BA2933307","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: BA2933307 add-tools-browser-api.Testes. BA2933307 Este arquivo contém os testes para o serviço BA2933307 Source: add-tools-browser-api/src/services/test/unit/BA2933307.service.spec.js, line 14 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço BA2933307 deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-browser-api/src/services/test/unit/BA2933307.service.spec.js, line 29 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço BA2933307 existe um código IDAPP. O serviço BA2933307 deve ter um código IDAPP nas suas configurações definido. Source: add-tools-browser-api/src/services/test/unit/BA2933307.service.spec.js, line 40 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço BA2933307 deve ter uma descrição breve, que aceita qualquer valor do tipo string. Source: add-tools-browser-api/src/services/test/unit/BA2933307.service.spec.js, line 55 × Search results Close "},"add-tools-browser-api.Testes.BROWSER.html":{"id":"add-tools-browser-api.Testes.BROWSER.html","title":"Namespace: BROWSER","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: BROWSER add-tools-browser-api.Testes. BROWSER Este arquivo contém os testes para o serviço BROWSER Source: add-tools-browser-api/src/services/test/unit/BROWSER.service.spec.js, line 9 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço BROWSER deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-browser-api/src/services/test/unit/BROWSER.service.spec.js, line 24 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço BROWSER existe um código IDAPP. O serviço BROWSER deve ter um código IDAPP nas suas configurações definido. Source: add-tools-browser-api/src/services/test/unit/BROWSER.service.spec.js, line 35 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço BROWSER deve ter uma descrição, que aceita qualquer valor do tipo string. Source: add-tools-browser-api/src/services/test/unit/BROWSER.service.spec.js, line 50 × Search results Close "},"add-tools-browser-api.Testes.GOVBR.html":{"id":"add-tools-browser-api.Testes.GOVBR.html","title":"Namespace: GOVBR","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: GOVBR add-tools-browser-api.Testes. GOVBR Este arquivo contém os testes para o serviço GOVBR Source: add-tools-browser-api/src/services/test/unit/GOVBR.service.spec.js, line 9 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço GOVBR deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-browser-api/src/services/test/unit/GOVBR.service.spec.js, line 24 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço GOVBR existe um código IDAPP. O serviço GOVBR deve ter um código IDAPP nas suas configurações definido. Source: add-tools-browser-api/src/services/test/unit/GOVBR.service.spec.js, line 35 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço GOVBR deve ter uma descrição, que aceita qualquer valor do tipo string. Source: add-tools-browser-api/src/services/test/unit/GOVBR.service.spec.js, line 50 × Search results Close "},"add-tools-browser-api.Testes.PR4106902.html":{"id":"add-tools-browser-api.Testes.PR4106902.html","title":"Namespace: PR4106902","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: PR4106902 add-tools-browser-api.Testes. PR4106902 Este arquivo contém os testes para o serviço PR4106902 Source: add-tools-browser-api/src/services/test/unit/PR4106902.service.spec.js, line 9 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço PR4106902 deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-browser-api/src/services/test/unit/PR4106902.service.spec.js, line 24 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço PR4106902 existe um código IDAPP. O serviço PR4106902 deve ter um código IDAPP nas suas configurações definido. Source: add-tools-browser-api/src/services/test/unit/PR4106902.service.spec.js, line 35 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço PR4106902 deve ter uma descrição, que aceita qualquer valor do tipo string. Source: add-tools-browser-api/src/services/test/unit/PR4106902.service.spec.js, line 50 × Search results Close "},"add-tools-browser-api.Testes.RJ3304557.html":{"id":"add-tools-browser-api.Testes.RJ3304557.html","title":"Namespace: RJ3304557","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: RJ3304557 add-tools-browser-api.Testes. RJ3304557 Este arquivo contém os testes para o serviço RJ3304557 Source: add-tools-browser-api/src/services/test/unit/RJ3304557.service.spec.js, line 9 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço RJ3304557 deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-browser-api/src/services/test/unit/RJ3304557.service.spec.js, line 24 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço RJ3304557 existe um código IDAPP. O serviço RJ3304557 deve ter um código IDAPP nas suas configurações definido. Source: add-tools-browser-api/src/services/test/unit/RJ3304557.service.spec.js, line 35 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço RJ3304557 deve ter uma descrição, que aceita qualquer valor do tipo string. Source: add-tools-browser-api/src/services/test/unit/RJ3304557.service.spec.js, line 50 × Search results Close "},"add-tools-drive-api.html":{"id":"add-tools-drive-api.html","title":"Namespace: add-tools-drive-api","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: add-tools-drive-api add-tools-drive-api add-tools-drive-api Source: add-tools-drive-api/src/services/DRIVE.service.js, line 6 Namespaces DRIVE Testes × Search results Close "},"add-tools-drive-api.DRIVE.html":{"id":"add-tools-drive-api.DRIVE.html","title":"Namespace: DRIVE","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: DRIVE add-tools-drive-api. DRIVE O Serviço de DRIVE interage com um sistema de armazenamento (local ou S3) para criar, obter em base64, verificar se existe, obter estatísticas, obter conteúdo, obter fluxo (Stream) e deletar arquivos. Ele também possui um canal para escutar um evento e criar uma identificação de uma corporação no S3 quando uma corporação é criada. Properties: Name Type Description name string Nome do serviço mixins object Mixins do serviço Properties Name Type Description DriveMixin array O Mixin DriveMixin é responsável por criar um sistema de armazenamento metadata object Usado para armazenar qualquer metadados do serviço Estas informações podem ser acessadas via this.metadata e são transferidas para outros nós durante a chamada Properties Name Type Description $description string Descrição breve do serviço usada em listas automáticas settings object Configurações internas do serviço Properties Name Type Description IDAPP string ID do APP que pode ser usado em permissões para chamar este serviço rest boolean Se o serviço é REST ou não STORAGE_ROOT string Diretório raiz do armazenamento: \"/upload\" storageConfig object Configurações do armazenamento Properties Name Type Description disks object Tipos de discos do armazenamento Properties Name Type Description local object Disco local Properties Name Type Description driver String Driver do disco local s3 object Disco S3 Properties Name Type Description driver String Driver do disco S3 config object Configurações do disco S3 Source: add-tools-drive-api/src/services/DRIVE.service.js, line 11 Members actions Actions do serviço Properties: Name Type Description create object Action create action create getBase64 object Action getBase64 action getBase64 exists object Action exists action exists getStat object Action getStat action getStat getContent object Action getContent action getContent getStream object Action getStream action getStream delete object Action delete action delete Source: add-tools-drive-api/src/services/DRIVE.service.js, line 79 channels channels Possui um canal para escutar um evento e criar uma pasta no S3 quando uma corporação é criada \"corporation.created\" Source: add-tools-drive-api/src/services/DRIVE.service.js, line 280 Actions create Ação create Ação para criar um arquivo no sistema de armazenamento. Ela recebe o nome do arquivo filename, o conteúdo fileContent em diferentes formatos (string, Buffer ou Stream), ou uma string codificada em Base64 base64. Ela retorna a chamada da função this.storage (que vem do Mixin DriveMixin). Essa função é chamada com os métodos disk (com o parâmetro \"s3\") e create (com os parâmetros filename e fileContent). Properties: Name Type Argument Description description string Descrição breve da ação usada em listas automáticas params.filename string Nome do arquivo params.fileContent array &lt;optional&gt; Conteúdo do arquivo que pode ser uma string, Buffer ou Stream params.base64 string &lt;optional&gt; Conteúdo do arquivo em base64 Source: add-tools-drive-api/src/services/DRIVE.service.js, line 80 Returns: Promessa que resolve quando o arquivo é criado. Type Promise.&lt;any&gt; getBase64 Ação getBase64 Ação para retornar o conteúdo de um arquivo em Base64. Ela recebe o nome do arquivo filename e retorna o conteúdo em Base64 ou uma mensagem de erro. Properties: Name Type Description description string - Descrição breve da ação usada em listas automáticas params object Parâmetros da ação Properties Name Type Description filename string Nome do arquivo Source: add-tools-drive-api/src/services/DRIVE.service.js, line 124 Returns: Conteúdo do arquivo em Base64 Type string exists Ação exists Ação para verificar se um arquivo existe. Ela recebe o nome do arquivo filename e retorna um booleano indicando se o arquivo existe ou não. Properties: Name Type Description description string Descrição breve da ação usada em listas automáticas description string Descrição breve da ação usada em listas automáticas params.filename string Nome do arquivo Source: add-tools-drive-api/src/services/DRIVE.service.js, line 157 Returns: Retorna o caminho do arquivo Type boolean getStat Ação getStat Ação para retornar estatísticas de um arquivo. Ela recebe o nome do arquivo filename e retorna um objeto com as estatísticas do arquivo. Properties: Name Type Description description string Descrição da action description string Descrição breve da ação usada em listas automáticas params.filename string Nome do arquivo Source: add-tools-drive-api/src/services/DRIVE.service.js, line 183 Returns: Estatísticas do arquivo Type object getContent Ação getContent Ação para retornar o conteúdo de um arquivo. Ela recebe como parâmetro: o nome do arquivo filename e a codificação encoding Ela retorna o conteúdo do arquivo como string. Properties: Name Type Argument Default Description description string Descrição da action description string Descrição breve da ação usada em listas automáticas params.filename string Nome do arquivo params.encoding string &lt;optional&gt; \"utf-8\" Codificação do arquivo Source: add-tools-drive-api/src/services/DRIVE.service.js, line 206 Returns: Conteúdo do arquivo como string Type string getStream Ação getStream Ação para retornar o conteúdo de um arquivo como um fluxo (Stream) do armazenamento S3. Ela recebe o nome do arquivo filename e retorna o conteúdo do arquivo como um fluxo (Stream). Properties: Name Type Description description string Descrição breve da ação usada em listas automáticas params.filename string Nome do arquivo Source: add-tools-drive-api/src/services/DRIVE.service.js, line 231 Returns: Conteúdo do arquivo como um fluxo (Stream) Type Stream delete Ação delete Ação para deletar um arquivo. Ela recebe o nome do arquivo filename e retorna um booleano indicando se o arquivo foi deletado ou não. Properties: Name Type Description description string Descrição breve da ação usada em listas automáticas params.filename string Nome do arquivo Source: add-tools-drive-api/src/services/DRIVE.service.js, line 252 Returns: Retorna um booleano indicando se o arquivo foi deletado ou não Type boolean × Search results Close "},"add-tools-drive-api.Testes.html":{"id":"add-tools-drive-api.Testes.html","title":"Namespace: Testes","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: Testes add-tools-drive-api. Testes Testes para os serviços contidos em add-tools-ocr-api Source: add-tools-drive-api/src/services/test/unit/DRIVE.service.spec.js, line 9 Namespaces DRIVE × Search results Close "},"add-tools-drive-api.Testes.DRIVE.html":{"id":"add-tools-drive-api.Testes.DRIVE.html","title":"Namespace: DRIVE","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: DRIVE add-tools-drive-api.Testes. DRIVE Este arquivo contém os testes para o serviço OCR Source: add-tools-drive-api/src/services/test/unit/DRIVE.service.spec.js, line 14 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço DRIVE deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-drive-api/src/services/test/unit/DRIVE.service.spec.js, line 43 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço DRIVE existe um código IDAPP. O serviço DRIVE deve ter um código IDAPP nas suas configurações definido. Source: add-tools-drive-api/src/services/test/unit/DRIVE.service.spec.js, line 54 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço DRIVE deve ter uma descrição breve, que aceita qualquer valor do tipo string. Source: add-tools-drive-api/src/services/test/unit/DRIVE.service.spec.js, line 69 Parâmetro_Filename Parâmetro filename Teste para verificar o parâmetro filename de todas as actions Todas as actions do serviço DRIVE deve ter o parâmetro filename, que não pode ser opcional e deve ser do tipo string. Source: add-tools-drive-api/src/services/test/unit/DRIVE.service.spec.js, line 81 Parâmetro_Inválido Tipo de parâmetro inválido Teste para verificar exceção de validação ao enviar parâmetros inválidos. Todas as actions do serviço DRIVE devem lançar uma exceção de validação quando enviado o parâmetro filename de tipo diferente de string (number). Source: add-tools-drive-api/src/services/test/unit/DRIVE.service.spec.js, line 96 Chamada_thisStorage Chamada da função this.storage Teste para verificar a chamada da função 'this.storage'. A action create do serviço DRIVE deve chamar a função 'this.storage' com os parâmetros corretos e na ordem correta. Source: add-tools-drive-api/src/services/test/unit/DRIVE.service.spec.js, line 124 × Search results Close "},"add-tools-http-api.html":{"id":"add-tools-http-api.html","title":"Namespace: add-tools-http-api","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: add-tools-http-api add-tools-http-api add-tools-http-api Source: add-tools-http-api/src/services/HTTP.service.js, line 43 Namespaces HTTP Testes × Search results Close "},"add-tools-http-api.HTTP.html":{"id":"add-tools-http-api.HTTP.html","title":"Namespace: HTTP","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: HTTP add-tools-http-api. HTTP O Serviço de HTTP é usado para fazer solicitações HTTP e lidar com erros e respostas de uma maneira específica. Properties: Name Type Description name string Nome do serviço mixins array Mixins do serviço: HTTPClientService metadata object Usado para armazenar qualquer metadados do serviço Estas informações podem ser acessadas via this.metadata e são transferidas para outros nós durante a chamada Properties Name Type Description $description string Descrição breve do serviço usada em listas automáticas settings object Configurações internas do serviço Properties Name Type Description IDAPP string ID do APP que pode ser usado em permissões httpClient object Configurações do cliente HTTP, valor booleano que indica se a solicitação deve ser registrada ou não. Source: add-tools-http-api/src/services/HTTP.service.js, line 47 Methods created() created é um dos métodos do ciclo de vida do serviço no Moleculer. Ele é chamado uma vez, quando o serviço é criado. Aqui, ele está configurando um cliente HTTP personalizado para o serviço, com opções para registro e formatação de resposta. O cliente é então armazenado no serviço para uso posterior. Source: add-tools-http-api/src/services/HTTP.service.js, line 78 × Search results Close "},"add-tools-http-api.Testes.html":{"id":"add-tools-http-api.Testes.html","title":"Namespace: Testes","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: Testes add-tools-http-api. Testes Testes para os serviços contidos em add-tools-ocr-api Source: add-tools-http-api/src/services/test/unit/HTTP.service.spec.js, line 8 Namespaces HTTP × Search results Close "},"add-tools-http-api.Testes.HTTP.html":{"id":"add-tools-http-api.Testes.HTTP.html","title":"Namespace: HTTP","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: HTTP add-tools-http-api.Testes. HTTP Este arquivo contém os testes para o serviço HTTP Source: add-tools-http-api/src/services/test/unit/HTTP.service.spec.js, line 13 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço HTTP deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-http-api/src/services/test/unit/HTTP.service.spec.js, line 27 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço HTTP existe um código IDAPP. O serviço HTTP deve ter um código IDAPP nas suas configurações definido. Source: add-tools-http-api/src/services/test/unit/HTTP.service.spec.js, line 38 × Search results Close "},"add-tools-mail-api.html":{"id":"add-tools-mail-api.html","title":"Namespace: add-tools-mail-api","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: add-tools-mail-api add-tools-mail-api add-tools-mail-api Source: add-tools-mail-api/src/services/mail-portal.service.js, line 4 Namespaces mail-portal mail-welcome mail Testes × Search results Close "},"add-tools-mail-api.mail-portal.html":{"id":"add-tools-mail-api.mail-portal.html","title":"Namespace: mail-portal","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: mail-portal add-tools-mail-api. mail-portal O Serviço de MailPortal faz ... Properties: Name Type Description name string Nome do serviço metadata object Metadados do serviço settings object Configurações do serviço actions object Ações do serviço: (send) Source: add-tools-mail-api/src/services/mail-portal.service.js, line 8 Members actions Actions do serviço Properties: Name Type Description send object Action send action send Source: add-tools-mail-api/src/services/mail-portal.service.js, line 27 Actions send Ação send Properties: Name Type Description rest string Rota da action description string Descrição da action params object Parâmetros da action Properties Name Type Argument Default Description language string &lt;optional&gt; \"pt-BR\" Idioma do email to string Email do destinatário subject string Assunto do email app string &lt;optional&gt; \"Portal de Documentos\" Nome do app title string &lt;optional&gt; \"Recebimento de Arquivos\" Título do email info object &lt;optional&gt; Informações do email attachments array &lt;optional&gt; Anexos do email Properties Name Type Argument Default Description filename string Nome do anexo, neste caso não pode ser vazio content string Conteúdo do anexo, neste caso é um base64 e não pode ser vazio encoding string &lt;optional&gt; \"base64\" Codificação do anexo Source: add-tools-mail-api/src/services/mail-portal.service.js, line 28 × Search results Close "},"add-tools-mail-api.mail-welcome.html":{"id":"add-tools-mail-api.mail-welcome.html","title":"Namespace: mail-welcome","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: mail-welcome add-tools-mail-api. mail-welcome O Serviço de MailWelcome faz ... Properties: Name Type Description name string Nome do serviço metadata object Metadados do serviço settings object Configurações do serviço actions object Ações do serviço: (send) Source: add-tools-mail-api/src/services/mail-welcome.service.js, line 4 Members actions actions Properties: Name Type Description send object Action send action send Source: add-tools-mail-api/src/services/mail-welcome.service.js, line 24 Actions send Action send A ação send ... Properties: Name Type Description rest string Rota da action description string Descrição da action params object Parâmetros da action Properties Name Type Argument Default Description user string Nome do usuário email string Email do usuário language string &lt;optional&gt; \"pt-BR\" Idioma do email modules object Módulos... Properties Name Type Description type Array.&lt;string&gt; Tipo de módulos, deve ser um array de strings enum Array.&lt;string&gt; Lista de módulos possíveis: \"nfe\", \"nfse\", \"cte\", \"mde\" Source: add-tools-mail-api/src/services/mail-welcome.service.js, line 25 Returns: - Retorna uma mensagem de sucesso Type string × Search results Close "},"add-tools-mail-api.mail.html":{"id":"add-tools-mail-api.mail.html","title":"Namespace: mail","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: mail add-tools-mail-api. mail O Serviço de MailService faz ... Properties: Name Type Description name string Nome do serviço metadata object Metadados do serviço settings object Configurações do serviço settings object Configurações do serviço Source: add-tools-mail-api/src/services/mail.service.js, line 22 × Search results Close "},"add-tools-mail-api.Testes.html":{"id":"add-tools-mail-api.Testes.html","title":"Namespace: Testes","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: Testes add-tools-mail-api. Testes Testes para os serviços contidos em add-tools-mail-api Source: add-tools-mail-api/src/services/test/unit/mail-portal.service.spec.js, line 8 Namespaces mail-portal mail-welcome mail × Search results Close "},"add-tools-mail-api.Testes.mail-portal.html":{"id":"add-tools-mail-api.Testes.mail-portal.html","title":"Namespace: mail-portal","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: mail-portal add-tools-mail-api.Testes. mail-portal Este arquivo contém os testes para o serviço mail-portal Source: add-tools-mail-api/src/services/test/unit/mail-portal.service.spec.js, line 13 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço MailPortal deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-mail-api/src/services/test/unit/mail-portal.service.spec.js, line 27 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço MailPortal existe um código IDAPP. O serviço MailPortal deve ter um código IDAPP nas suas configurações definido. Source: add-tools-mail-api/src/services/test/unit/mail-portal.service.spec.js, line 38 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço MailPortal deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-mail-api/src/services/test/unit/mail-portal.service.spec.js, line 53 × Search results Close "},"add-tools-mail-api.Testes.mail-welcome.html":{"id":"add-tools-mail-api.Testes.mail-welcome.html","title":"Namespace: mail-welcome","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: mail-welcome add-tools-mail-api.Testes. mail-welcome Este arquivo contém os testes para o serviço mail-welcome Source: add-tools-mail-api/src/services/test/unit/mail-welcome.service.spec.js, line 9 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço MailWelcome deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-mail-api/src/services/test/unit/mail-welcome.service.spec.js, line 23 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço MailWelcome existe um código IDAPP. O serviço MailWelcome deve ter um código IDAPP nas suas configurações definido. Source: add-tools-mail-api/src/services/test/unit/mail-welcome.service.spec.js, line 34 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço MailWelcome deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-mail-api/src/services/test/unit/mail-welcome.service.spec.js, line 49 × Search results Close "},"add-tools-mail-api.Testes.mail.html":{"id":"add-tools-mail-api.Testes.mail.html","title":"Namespace: mail","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: mail add-tools-mail-api.Testes. mail Este arquivo contém os testes para o serviço mail Source: add-tools-mail-api/src/services/test/unit/mail.service.spec.js, line 9 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço MailService deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-mail-api/src/services/test/unit/mail.service.spec.js, line 23 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço MailService existe um código IDAPP. O serviço MailService deve ter um código IDAPP nas suas configurações definido. Source: add-tools-mail-api/src/services/test/unit/mail.service.spec.js, line 34 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço MailService deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-mail-api/src/services/test/unit/mail.service.spec.js, line 49 × Search results Close "},"add-tools-ocr-api.html":{"id":"add-tools-ocr-api.html","title":"Namespace: add-tools-ocr-api","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: add-tools-ocr-api add-tools-ocr-api add-tools-ocr-api Source: add-tools-ocr-api/src/services/OCR.service.js, line 8 Namespaces OCR PDF Testes × Search results Close "},"add-tools-ocr-api.OCR.html":{"id":"add-tools-ocr-api.OCR.html","title":"Namespace: OCR","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: OCR add-tools-ocr-api. OCR O Serviço de OCR faz o Reconhecimento Óptico de Caracteres em imagens e PDFs. Ele tem duas ações principais: img e pdf. Ele também tem um hook before para a ação img que verifica o template a ser utilizado no OCR. Se nenhum template for especificado, o template 1 é usado por padrão. Properties: Name Type Description name string Nome do serviço metadata object Usado para armazenar qualquer metadados do serviço Estas informações podem ser acessadas via this.metadata e são transferidas para outros nós durante a chamada Properties Name Type Description $description string Descrição breve do serviço usada em listas automáticas settings object Configurações internas do serviço Properties Name Type Description IDAPP string ID do APP que pode ser usado em permissões MONETIZATION boolean Se estiver marcado, o usuário precisa ter um contrato para chamar este serviço Source: add-tools-ocr-api/src/services/OCR.service.js, line 12 Members hooks Hooks do Serviço de OCR O serviço OCR possui hooks Properties: Name Type Description before object Executado antes da chamada da ação Properties Name Type Description img array Lista de funções executadas antes da ação img Source: add-tools-ocr-api/src/services/OCR.service.js, line 41 See: methods getTemplate actions Actions do serviço Properties: Name Type Description img object Processa arquivos com formato de imagem action img pdf object Tenta chamar a action text do Serviço PDF action pdf Source: add-tools-ocr-api/src/services/OCR.service.js, line 52 Actions img Ação img A ação img recebe uma imagem (como uma URL, um caminho de arquivo ou um buffer) e retorna o texto contido nela. A imagem pode ser pré-processada antes do OCR, incluindo: a conversão para escala de cinza, redimensionamento, aplicação de um limite e a extensão da imagem. Properties: Name Type Argument Description description string Descrição breve da ação usada em listas automáticas rest string Rota da ação: \"POST /\" params object Parâmetros da ação Properties Name Type Argument Default Description input string &lt;optional&gt; Imagem a ser processada. Pode ser no formato de URL, um caminho para o filesystem ou um buffer base64 string &lt;optional&gt; Imagem a ser processada no formato base64 resize number &lt;optional&gt; Tamanho que a imagem será redimensionada removeBorder boolean &lt;optional&gt; false Remove bordas da imagem no formato de tabela config object &lt;optional&gt; Configurações do OCR permissions array &lt;optional&gt; Permissões da ação. Se estiver preenchido, o usuário precisa ter todas as permissões listadas para executar Source: add-tools-ocr-api/src/services/OCR.service.js, line 53 Throws: ERR_OCR_IMG - Erro no servidor OCR Type AddsonServerError Returns: Retorna um objeto com uma única propriedade result, que contém o texto extraído da imagem Type object pdf Action pdf A ação pdf tenta chamar o serviço \"PDF.text\" add-tools-ocr-api.PDF#text PDF.text com os parâmetros fornecidos no contexto (ctx.params). O resultado dessa chamada (que é uma Promise) é aguardado e o valor resolvido é armazenado na variável text. Se a chamada ao serviço \"PDF.text\" for bem-sucedida, a função retorna um objeto com uma única propriedade result, que contém o texto extraído do serviço \"PDF.text\". Properties: Name Type Description description string Descrição breve da ação usada em listas automáticas rest string Rota da ação params object Parâmetros da ação: \"POST /\" Properties Name Type Argument Default Description fileName string &lt;optional&gt; nome do arquivo PDF a ser processado base64 string &lt;optional&gt; PDF a ser processado codificado em formato base64 type string &lt;optional&gt; \"ocr\" Tipo de processamento do PDF, pode ser \"text\" ou \"ocr\", mas \"ocr\" é o padrão. permissions array Permissões da ação. Se estiver preenchido, o usuário precisa ter todas as permissões listadas para executar Source: add-tools-ocr-api/src/services/OCR.service.js, line 229 Throws: ERR_OCR_PDF - Erro no servidor OCR Type AddsonServerError Returns: Retorna um objeto com uma única propriedade result, que contém o texto extraído do PDF Type object Methods getTemplate(ctx) Função para verificar o template a ser utilizado no OCR. Caso não seja informado um template, o template 1 é utilizado por padrão. Parameters: Name Type Description ctx object Contexto da requisição Source: add-tools-ocr-api/src/services/OCR.service.js, line 298 × Search results Close "},"add-tools-ocr-api.PDF.html":{"id":"add-tools-ocr-api.PDF.html","title":"Namespace: PDF","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: PDF add-tools-ocr-api. PDF O Serviço de PDF extrai texto de arquivos PDF. O Serviço tem uma ação principal: text. Ele também tem um método extractText() que recebe o caminho para o arquivo PDF e o tipo de processamento. Properties: Name Type Description name string Nome do serviço mixins array Usado para distribuir funcionalidades reutilizáveis para os serviços metadata object Usado para armazenar qualquer metadados do serviço Properties Name Type Description $description string Descrição breve do serviço usada em listas automáticas settings object Configurações internas do serviço Properties Name Type Description IDAPP string ID do APP que pode ser usado em permissões Source: add-tools-ocr-api/src/services/PDF.service.js, line 6 To Do: @property {number} version - Versão do serviço @property {boolean} settings.rest - Se estiver marcado, o serviço será acessível via REST Members actions Actions do serviço Properties: Name Type Description text object Processa arquivos com formato PDF action text Source: add-tools-ocr-api/src/services/PDF.service.js, line 37 Actions text Ação text A ação text recebe um arquivo PDF (como uma string base64) e um tipo de processamento (\"text\" ou \"ocr\"). Se o tipo de processamento não for especificado, será definido \"text\" por padrão. A ação salva o arquivo PDF, extrai o texto dele usando o método extractText(), e retorna o texto extraído. Se ocorrer um erro durante este processo, um erro de servidor é lançado. Properties: Name Type Description description string Descrição da action rest string Rota da action: \"POST /\" params object Parâmetros da action Properties Name Type Argument Default Description fileName string &lt;optional&gt; Nome do arquivo a ser processado base64 string PDF a ser processado codificado em formato base64 type string &lt;optional&gt; \"text\" Tipo de processamento do PDF (text ou ocr) Source: add-tools-ocr-api/src/services/PDF.service.js, line 38 Throws: - ERR_PDF_TEXT - Erro no servidor OCR Type AddsonServerError Returns: Retorna o texto extraído do PDF Type string Methods extractText(filePath, type) Método para extração de texto A função extractText() recebe como parâmetro o caminho para o arquivo PDF e o tipo de processamento. Se o tipo de processamento for \"ocr\", ele usará o OCR para extrair o texto. Parameters: Name Type Description filePath string Caminho para do aqruivo type string Tipo de processamento \"text\" ou \"ocr\" Source: add-tools-ocr-api/src/services/PDF.service.js, line 120 Returns: - Texto extraído do PDF Type string × Search results Close "},"add-tools-ocr-api.Testes.html":{"id":"add-tools-ocr-api.Testes.html","title":"Namespace: Testes","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: Testes add-tools-ocr-api. Testes Testes para os serviços contidos em add-tools-ocr-api Source: add-tools-ocr-api/src/services/test/unit/OCR.service.spec.js, line 9 Namespaces OCR PDF × Search results Close "},"add-tools-ocr-api.Testes.OCR.html":{"id":"add-tools-ocr-api.Testes.OCR.html","title":"Namespace: OCR","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: OCR add-tools-ocr-api.Testes. OCR Este arquivo contém os testes para o serviço OCR Source: add-tools-ocr-api/src/services/test/unit/OCR.service.spec.js, line 14 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço OCR deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-ocr-api/src/services/test/unit/OCR.service.spec.js, line 31 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço OCR existe um código IDAPP. O serviço OCR deve ter um código IDAPP nas suas configurações definido. Source: add-tools-ocr-api/src/services/test/unit/OCR.service.spec.js, line 42 Descrição_Action Descrição da action img Teste para verificar se a descrição da action img está preenchida. A action img do serviço OCR deve ter uma descrição breve, que aceita qualquer valor do tipo string. Source: add-tools-ocr-api/src/services/test/unit/OCR.service.spec.js, line 58 Base64_Opcional Validação de parâmetro opcional Teste para verificar a validação de parâmetro opcional para base64 da action img do Serviço OCR. O parâmetro base64 da action img do serviço OCR deve ser opcional. Source: add-tools-ocr-api/src/services/test/unit/OCR.service.spec.js, line 75 Input_Preenchido Validação de parâmetro input Teste para verificar a exceção AddsonClientError ao enviar parâmetro input em branco. Quando o parâmetro base64 da actiom img estiver em branco o parâmetro input da action img deve estar preenchido. Source: add-tools-ocr-api/src/services/test/unit/OCR.service.spec.js, line 87 Parâmetro_Inválido Parâmetro base64 inválido Teste para verificar exceção de validação ao enviar parâmetros inválidos. A action img do serviço OCR deve lançar uma exceção de validação quando enviado o parâmetro base64 inválido. Source: add-tools-ocr-api/src/services/test/unit/OCR.service.spec.js, line 106 Imagem_Inválida Imagem inválida Teste para verificar exceção ao enviar um base64 que não é uma imagem. A action img do serviço OCR deve lançar uma exceção ao enviar um base64 que não é uma imagem. Source: add-tools-ocr-api/src/services/test/unit/OCR.service.spec.js, line 126 Campos_Serviço Valores dos campos Teste para verificar o valor dos campos de acordo com o nome dos campos. Aqui o teste deve ser executado quando o campo não for opcional. Este teste verifica cada campo que não está marcado como opcional e confirma se o valor do campo retornado está de acordo com o cenário. Source: add-tools-ocr-api/src/services/test/unit/OCR.service.spec.js, line 189 × Search results Close "},"add-tools-ocr-api.Testes.PDF.html":{"id":"add-tools-ocr-api.Testes.PDF.html","title":"Namespace: PDF","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: PDF add-tools-ocr-api.Testes. PDF Este arquivo contém os testes para o serviço PDF Source: add-tools-ocr-api/src/services/test/unit/PDF.service.spec.js, line 11 Tests Descrição_Serviço Descrição do Serviço Teste para verificar se a descrição do serviço está preenchida. O serviço PDF deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-ocr-api/src/services/test/unit/PDF.service.spec.js, line 28 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço PDF existe um código IDAPP. O serviço PDF deve ter um código IDAPP nas suas configurações definido. Source: add-tools-ocr-api/src/services/test/unit/PDF.service.spec.js, line 39 Descrição_Action Descrição da action text Teste para verificar se a descrição da action text está preenchida. A action text do serviço PDF deve ter uma descrição breve, que aceita qualquer valor do tipo string. Source: add-tools-ocr-api/src/services/test/unit/PDF.service.spec.js, line 55 Base64_Obrigatório Validação de parâmetro obrigatório Teste para verificar a exceção de validação para os parâmetros da action text do Serviço PDF. O parâmetro base64 da action text do serviço PDF deve ser obrigatório. Source: add-tools-ocr-api/src/services/test/unit/PDF.service.spec.js, line 68 Base64_Inválido Validação de parâmetro base64 Teste para verificar exceção de validação ao enviar parâmetros inválidos. A action text do serviço PDF deve lançar uma exceção de validação quando enviado o parâmetro base64 inválido. Source: add-tools-ocr-api/src/services/test/unit/PDF.service.spec.js, line 86 Imagem_Inválida Imagem inválida Teste para verificar exceção ao enviar um base64 que não é uma imagem. A action text do serviço PDF deve lançar uma exceção ao enviar um base64 que não é uma imagem. Source: add-tools-ocr-api/src/services/test/unit/PDF.service.spec.js, line 106 Campos_Serviço Valores dos campos Teste para verificar o valor dos campos de acordo com o nome dos campos. Aqui o teste deve ser executado quando o campo não for opcional. Este teste verifica cada campo que não está marcado como opcional e confirma se o valor do campo retornado está de acordo com o cenário. Source: add-tools-ocr-api/src/services/test/unit/PDF.service.spec.js, line 170 × Search results Close "},"Settings.html":{"id":"Settings.html","title":"Class: Settings","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Class: Settings Settings Cenários para testes unitários new Settings(path) Construtor para classe base Parameters: Name Type Default Description path string null Diretório de cenários Source: add-tools-ocr-api/src/services/test/unit/cenarios/Settings.js, line 5 Methods getSettings() Retorna os cenários configurados Source: add-tools-ocr-api/src/services/test/unit/cenarios/Settings.js, line 18 Returns: Cenários configurados Type array × Search results Close "},"add-tools-platform-api.html":{"id":"add-tools-platform-api.html","title":"Namespace: add-tools-platform-api","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: add-tools-platform-api add-tools-platform-api add-tools-platform-api Source: add-tools-platform-api/src/services/addplatform.service.js, line 5 Namespaces addplatform Testes × Search results Close "},"add-tools-platform-api.addplatform.html":{"id":"add-tools-platform-api.addplatform.html","title":"Namespace: addplatform","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: addplatform add-tools-platform-api. addplatform O Serviço de addPlatform faz ... Properties: Name Type Description name string Nome do serviço mixins array Mixins do serviço metadata object Metadados do serviço settings object Configurações do serviço actions object Ações do serviço: callJava e callVersion methods object Métodos do serviço: createHash(), getMailInfo(), encodeBase64() e decodeBase64() Source: add-tools-platform-api/src/services/addplatform.service.js, line 9 To Do: @property {number} version - Versão do serviço Members actions actions Properties: Name Type Description callJava object Executa API Java action callJava callVersion object Teste Versao action callVersion Source: add-tools-platform-api/src/services/addplatform.service.js, line 37 Actions callJava Ação callJava A ação callJava ... Properties: Name Type Description description string Descrição da action rest string Rota da action params object Parâmetros da action Properties Name Type Argument Description hash string &lt;optional&gt; Hash da requisição permissions array Permissões da action Source: add-tools-platform-api/src/services/addplatform.service.js, line 38 callVersion Ação callVersion A ação callVersion ... Properties: Name Type Description description string Descrição da action rest string Rota da action params object Parâmetros da action Properties Name Type Argument Description hash string &lt;optional&gt; Hash da requisição Source: add-tools-platform-api/src/services/addplatform.service.js, line 130 Methods createHash(params) Método para ... O method createHash() ... Parameters: Name Type Description params object Parâmetros do método Source: add-tools-platform-api/src/services/addplatform.service.js, line 170 Returns: - Hash da requisição Type string getMailInfo(javaResponse) Método para ... O method getMailInfo() ... Parameters: Name Type Description javaResponse object Parâmetros do método Source: add-tools-platform-api/src/services/addplatform.service.js, line 208 Returns: - MailInfo Type string encodeBase64(str) Método para ... O method encodeBase64() ... Parameters: Name Type Description str object Parâmetros do método Source: add-tools-platform-api/src/services/addplatform.service.js, line 273 Returns: - string codificada em base64 Type string decodeBase64(str) Método para ... O method decodeBase64() ... Parameters: Name Type Description str object Parâmetros do método Source: add-tools-platform-api/src/services/addplatform.service.js, line 284 Returns: - string decodificada Type string × Search results Close "},"add-tools-platform-api.Testes.html":{"id":"add-tools-platform-api.Testes.html","title":"Namespace: Testes","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: Testes add-tools-platform-api. Testes Testes para os serviços contidos em add-tools-ocr-api Source: add-tools-platform-api/src/services/test/unit/addplatform.service.spec.js, line 6 Namespaces addplatform × Search results Close "},"add-tools-platform-api.Testes.addplatform.html":{"id":"add-tools-platform-api.Testes.addplatform.html","title":"Namespace: addplatform","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: addplatform add-tools-platform-api.Testes. addplatform Este arquivo contém os testes para o serviço addplatform Source: add-tools-platform-api/src/services/test/unit/addplatform.service.spec.js, line 11 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço addplatform deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-platform-api/src/services/test/unit/addplatform.service.spec.js, line 25 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço addPlatform existe um código IDAPP. O serviço addplatform deve ter um código IDAPP nas suas configurações definido. Source: add-tools-platform-api/src/services/test/unit/addplatform.service.spec.js, line 36 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço addplatform deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-platform-api/src/services/test/unit/addplatform.service.spec.js, line 51 × Search results Close "},"add-tools-vault-api.Testes.html":{"id":"add-tools-vault-api.Testes.html","title":"Namespace: Testes","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: Testes add-tools-vault-api. Testes Testes para os serviços contidos em add-tools-vault-api Source: add-tools-vault-api/src/services/test/unit/vault.service.spec.js, line 7 Namespaces vault vaultapp vaultCommunication vaultsignature × Search results Close "},"add-tools-vault-api.Testes.vault.html":{"id":"add-tools-vault-api.Testes.vault.html","title":"Namespace: vault","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: vault add-tools-vault-api.Testes. vault Este arquivo contém os testes para o serviço vault Source: add-tools-vault-api/src/services/test/unit/vault.service.spec.js, line 12 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço vault deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-vault-api/src/services/test/unit/vault.service.spec.js, line 26 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço vault existe um código IDAPP. O serviço vault deve ter um código IDAPP nas suas configurações definido. Source: add-tools-vault-api/src/services/test/unit/vault.service.spec.js, line 37 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço vault deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-vault-api/src/services/test/unit/vault.service.spec.js, line 52 × Search results Close "},"add-tools-vault-api.Testes.vaultapp.html":{"id":"add-tools-vault-api.Testes.vaultapp.html","title":"Namespace: vaultapp","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: vaultapp add-tools-vault-api.Testes. vaultapp Este arquivo contém os testes para o serviço vaultapp Source: add-tools-vault-api/src/services/test/unit/vaultapp.service.spec.js, line 7 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço vaultapp deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-vault-api/src/services/test/unit/vaultapp.service.spec.js, line 21 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço vaultapp existe um código IDAPP. O serviço vaultapp deve ter um código IDAPP nas suas configurações definido. Source: add-tools-vault-api/src/services/test/unit/vaultapp.service.spec.js, line 32 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço vaultapp deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-vault-api/src/services/test/unit/vaultapp.service.spec.js, line 47 × Search results Close "},"add-tools-vault-api.Testes.vaultCommunication.html":{"id":"add-tools-vault-api.Testes.vaultCommunication.html","title":"Namespace: vaultCommunication","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: vaultCommunication add-tools-vault-api.Testes. vaultCommunication Este arquivo contém os testes para o serviço vaultapp Source: add-tools-vault-api/src/services/test/unit/vaultcommunication.service.spec.js, line 7 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço vaultCommunication. deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-vault-api/src/services/test/unit/vaultcommunication.service.spec.js, line 21 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço vaultCommunication. existe um código IDAPP. O serviço vaultCommunication. deve ter um código IDAPP nas suas configurações definido. Source: add-tools-vault-api/src/services/test/unit/vaultcommunication.service.spec.js, line 32 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço vaultCommunication. deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-vault-api/src/services/test/unit/vaultcommunication.service.spec.js, line 47 × Search results Close "},"add-tools-vault-api.Testes.vaultsignature.html":{"id":"add-tools-vault-api.Testes.vaultsignature.html","title":"Namespace: vaultsignature","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: vaultsignature add-tools-vault-api.Testes. vaultsignature Este arquivo contém os testes para o serviço vaultsignature Source: add-tools-vault-api/src/services/test/unit/vaultsignature.service.spec.js, line 7 Tests Descrição_Serviço Descrição do serviço Teste para verificar se a descrição do serviço está preenchida. O serviço vaultsignature deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-vault-api/src/services/test/unit/vaultsignature.service.spec.js, line 21 IDAPP_Serviço IDAPP do Serviço Teste para verificar se nas configurações do serviço vaultsignature existe um código IDAPP. O serviço vaultsignature deve ter um código IDAPP nas suas configurações definido. Source: add-tools-vault-api/src/services/test/unit/vaultsignature.service.spec.js, line 32 Descrição_Action Descrição das actions Teste para verificar se a descrição das actions está preenchida. Todas as actions do serviço vaultsignature deve ter uma descrição breve em sua metadata, que aceita qualquer valor do tipo string. Source: add-tools-vault-api/src/services/test/unit/vaultsignature.service.spec.js, line 47 × Search results Close "},"add-tools-vault-api.html":{"id":"add-tools-vault-api.html","title":"Namespace: add-tools-vault-api","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: add-tools-vault-api add-tools-vault-api add-tools-vault-api Source: add-tools-vault-api/src/services/vault.service.js, line 13 Namespaces Testes vault vaultapp vaultcommunication vaultsignature × Search results Close "},"add-tools-vault-api.vault.html":{"id":"add-tools-vault-api.vault.html","title":"Namespace: vault","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: vault add-tools-vault-api. vault O Serviço vault faz ... Properties: Name Type Description name string Nome do serviço mixins array Mixins do serviço metadata object Metadados do serviço settings object Configurações do serviço actions object Ações do serviço: retrieveSecret, upsertSecret, listSecrets, copySecret, deleteSecret, convertCertificate methods object Métodos do serviço: validateInputParams(), addEncrypt(), addDecrypt(), encodeBase64(), decodeBase64(), deleteTempFiles(), readFromString(), localConvertCertificate() Source: add-tools-vault-api/src/services/vault.service.js, line 17 To Do: @property {number} version - Versão do serviço Members actions actions do serviço VAULT Properties: Name Type Description retrieveSecret object Recuperar segredo do cofre action retrieveSecret upsertSecret object Gravar segredo no cofre action upsertSecret listSecrets object Listar segredos do cofre action listSecrets copySecret object Copiar segredo do cofre action copySecret deleteSecret object Deletar segredo do cofre action deleteSecret convertCertificate object Converter certificado action convertCertificate Source: add-tools-vault-api/src/services/vault.service.js, line 48 Actions retrieveSecret Ação retrieveSecret A ação retrieveSecret faz ... Properties: Name Type Description description string Descrição da action permissions array Permissões da action ctx.params object Parâmetros da action Properties Name Type Description secretType string Tipo do segredo Tipo do segredo Tipo do segredo Tipo do segredo Tipo do segredoTipo do segredoTipo do segredoTipo do segredoTipo do segredoTipo do segredo Tipo do segredo secretAlias string Alias do segredo Source: add-tools-vault-api/src/services/vault.service.js, line 49 To Do: @property {string} rest - Rota da action upsertSecret Ação upsertSecret A ação upsertSecret ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Description secretType string Tipo do segredo secretAlias string Alias do segredo permissions array Permissões da action handler function @Link VAULT.upsertSecret.handler Source: add-tools-vault-api/src/services/vault.service.js, line 267 To Do: @property {string} rest - Rota da action listSecrets Ação listSecrets A ação listSecrets ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Argument Description secretType string &lt;optional&gt; Tipo do segredo permissions array Permissões da action Source: add-tools-vault-api/src/services/vault.service.js, line 470 To Do: @property {string} rest - Rota da action copySecret Ação copySecret Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Description secretType string Tipo do segredo secretAlias string Alias do segredo permissions array Permissões da action Source: add-tools-vault-api/src/services/vault.service.js, line 551 To Do: @property {string} rest - Rota da action deleteSecret Ação deleteSecret Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Description secretType string Tipo do segredo secretAlias string Alias do segredo permissions array Permissões da action Source: add-tools-vault-api/src/services/vault.service.js, line 623 To Do: @property {string} rest - Rota da action convertCertificate Ação convertCertificate A ação convertCertificate ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Description pkcs12File string Arquivo pkcs12 pkcs12Password string Senha do arquivo pkcs12 permissions array Permissões da action Source: add-tools-vault-api/src/services/vault.service.js, line 693 To Do: @property {string} rest - Rota da action Methods validateInputParams(params, nodeID) Método para ... O method validateInputParams() ... Parameters: Name Type Description params object Parâmetros de entrada nodeID object ID do nó Source: add-tools-vault-api/src/services/vault.service.js, line 748 Returns: - Se passar por todas validacoes retorna 'undefined' Type undefined addEncrypt(e) Método para ... O method addEncrypt() ... Parameters: Name Type Description e string String a ser encriptada Source: add-tools-vault-api/src/services/vault.service.js, line 845 Returns: - String encriptada Type string addDecrypt(r) Método para ... O method addDecrypt() ... Parameters: Name Type Description r string String a ser decriptada Source: add-tools-vault-api/src/services/vault.service.js, line 881 Returns: - String decriptada Type string encodeBase64(str) Método para ... O method encodeBase64() ... Parameters: Name Type Description str string String a ser codificada Source: add-tools-vault-api/src/services/vault.service.js, line 903 Returns: - String codificada em base64 Type string decodeBase64(str) Método para ... O method decodeBase64() ... Parameters: Name Type Description str string String a ser decodificada Source: add-tools-vault-api/src/services/vault.service.js, line 914 Returns: - String decodificada em utf-8 Type string readFromString(string, start, end) Método para ... O method readFromString() ... Parameters: Name Type Description string string String a ser lida start string String de inicio end string String de fim Source: add-tools-vault-api/src/services/vault.service.js, line 938 Returns: - Array de strings Type array localConvertCertificate(certificateFile, certificatePassword) Método para ... O method localConvertCertificate() ... Parameters: Name Type Description certificateFile string Arquivo de certificado certificatePassword string Senha do certificado Source: add-tools-vault-api/src/services/vault.service.js, line 970 Returns: - Objeto com chave e certificado Type object × Search results Close "},"add-tools-vault-api.vaultapp.html":{"id":"add-tools-vault-api.vaultapp.html","title":"Namespace: vaultapp","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: vaultapp add-tools-vault-api. vaultapp O Serviço de vaultapp faz ... Properties: Name Type Description name string Nome do serviço mixins array Mixins do serviço metadata object Metadados do serviço settings object Configurações do serviço actions object Ações do serviço: get, create, update, list, copySecret, remove, convertCertificate methods object Métodos do serviço: validateInputParams(), addEncrypt(), encodeBase64(), decodeBase64(), deleteTempFiles(), readFromString() e localConvertCertificate() Source: add-tools-vault-api/src/services/vaultapp.service.js, line 13 To Do: @property {number} version - Versão do serviço Members actions actions Properties: Name Type Description get object Ação para obter um secret action get create object Ação para criar um secret action create update object Ação para atualizar um secret action update list object Ação para listar secrets action list copySecret object Ação para copiar um secret action copySecret remove object Ação para remover um secret action remove convertCertificate object Ação para converter um certificado action convertCertificate Source: add-tools-vault-api/src/services/vaultapp.service.js, line 50 Actions get Ação get A ação get faz ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Argument Description secretType string &lt;optional&gt; Tipo do segredo secretAlias string Alias do segredo SECRETALIAS string &lt;optional&gt; Alias do segredo permissions array Permissões da action Source: add-tools-vault-api/src/services/vaultapp.service.js, line 51 To Do: @property {string} rest - Rota da action create Ação create A ação create faz ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Description SECRETALIAS string Alias do segredo SECRETTYPE string Tipo do segredo permissions array Permissões da action Source: add-tools-vault-api/src/services/vaultapp.service.js, line 306 To Do: @property {string} rest - Rota da action update Ação update A ação update faz ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Description SECRETTYPE string Tipo do segredo SECRETALIAS string Alias do segredo permissions array Permissões da action Source: add-tools-vault-api/src/services/vaultapp.service.js, line 517 To Do: @property {string} rest - Rota da action list Ação list A ação list ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Argument Description secretType string &lt;optional&gt; Tipo do segredo permissions array Permissões da action Source: add-tools-vault-api/src/services/vaultapp.service.js, line 922 To Do: @property {string} rest - Rota da action copySecret Ação copySecret A ação copySecret faz ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Description secretType string Tipo do segredo secretAlias string Alias do segredo permissions array Permissões da action Source: add-tools-vault-api/src/services/vaultapp.service.js, line 1007 To Do: @property {string} rest - Rota da action remove Ação remove A ação remove faz ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Argument Description secretType string &lt;optional&gt; Tipo do segredo secretAlias string &lt;optional&gt; Alias do segredo id string id do segredo permissions array Permissões da action Source: add-tools-vault-api/src/services/vaultapp.service.js, line 1079 To Do: @property {string} rest - Rota da action convertCertificate Ação convertCertificate A ação convertCertificate faz ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Description pkcs12File string Arquivo pkcs12 pkcs12Password string Senha do arquivo pkcs12 permissions array Permissões da action Source: add-tools-vault-api/src/services/vaultapp.service.js, line 1157 To Do: @property {string} rest - Rota da action Methods validateInputParams(params, nodeID) Método para ... O method validateInputParams() ... Parameters: Name Type Description params object Parâmetros de entrada nodeID string ID do nó Source: add-tools-vault-api/src/services/vaultapp.service.js, line 1212 Returns: - Se passar por todas validações retorna 'undefined' Type undefined addEncrypt(e) Método para ... O method addEncrypt() ... Parameters: Name Type Description e string String a ser encriptada Source: add-tools-vault-api/src/services/vaultapp.service.js, line 1309 Returns: - String encriptada Type string addDecrypt(r) Método para ... O method addDecrypt() ... Parameters: Name Type Description r string String a ser decriptada Source: add-tools-vault-api/src/services/vaultapp.service.js, line 1345 Returns: - String decriptada Type string encodeBase64(str) Método para ... O method encodeBase64() ... Parameters: Name Type Description str string String a ser codificada Source: add-tools-vault-api/src/services/vaultapp.service.js, line 1367 Returns: - String codificada em base64 Type string decodeBase64(str) Método para ... O method decodeBase64() ... Parameters: Name Type Description str string String a ser decodificada Source: add-tools-vault-api/src/services/vaultapp.service.js, line 1378 Returns: - String decodificada em utf-8 Type string deleteTempFiles(list) Método para ... O method deleteTempFiles() ... Parameters: Name Type Description list array Lista de arquivos a serem excluidos Source: add-tools-vault-api/src/services/vaultapp.service.js, line 1389 readFromString(string, start, end) Método para ... O method readFromString() ... Parameters: Name Type Description string string String a ser lida start string String de inicio end string String de fim Source: add-tools-vault-api/src/services/vaultapp.service.js, line 1401 Returns: - Array de strings Type array localConvertCertificate(certificateFile, certificatePassword) Método para ... O method localConvertCertificate() ... Parameters: Name Type Description certificateFile string Arquivo do certificado certificatePassword string Senha do certificado Source: add-tools-vault-api/src/services/vaultapp.service.js, line 1433 Returns: - Objeto com chave e certificado Type object × Search results Close "},"add-tools-vault-api.vaultcommunication.html":{"id":"add-tools-vault-api.vaultcommunication.html","title":"Namespace: vaultcommunication","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: vaultcommunication add-tools-vault-api. vaultcommunication O Serviço de vaultcommunication faz ... Properties: Name Type Description name string Nome do serviço mixins array Mixins do serviço metadata object Metadados do serviço settings object Configurações do serviço actions object Ações do serviço: send methods object Métodos do serviço: validateInputParams(), addEncrypt(), addDecrypt(), encodeBase64(), decodeBase64() Source: add-tools-vault-api/src/services/vaultcommunication.service.js, line 12 To Do: @property {number} version - Versão do serviço Members actions Actions do serviço Properties: Name Type Description send object Action send action send Source: add-tools-vault-api/src/services/vaultcommunication.service.js, line 39 Actions send Ação send A ação send fez ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Argument Description secretAlias string Alias do certificado messageContent string Conteudo da mensagem messageContentFormat string &lt;optional&gt; Formato do conteudo da mensagem endpoint string Endpoint da mensagem method string Metodo da mensagem headers object &lt;optional&gt; Headers da mensagem permissions array Permissões da action Source: add-tools-vault-api/src/services/vaultcommunication.service.js, line 40 To Do: @property {string} rest - Rota da action Methods validateInputParams(params, nodeID) Método para ... O method validateInputParams() ... Parameters: Name Type Description params object Parâmetros de entrada nodeID string ID do node Source: add-tools-vault-api/src/services/vaultcommunication.service.js, line 271 Returns: - Se passar por todas validações retorna 'undefined' Type undefined addEncrypt(e) Método para ... O method addEncrypt() ... Parameters: Name Type Description e string Secret a ser encriptado Source: add-tools-vault-api/src/services/vaultcommunication.service.js, line 368 Returns: - Secret encriptado Type string addDecrypt(r) Método para ... O method addDecrypt() ... Parameters: Name Type Description r string Secret a ser decriptado Source: add-tools-vault-api/src/services/vaultcommunication.service.js, line 404 Returns: - Secret decriptado Type string encodeBase64(str) Método para ... O method encodeBase64() ... Parameters: Name Type Description str string String a ser codificada Source: add-tools-vault-api/src/services/vaultcommunication.service.js, line 426 Returns: - String codificada em base64 Type string decodeBase64(str) Método para ... O method decodeBase64() ... Parameters: Name Type Description str string String a ser decodificada Source: add-tools-vault-api/src/services/vaultcommunication.service.js, line 437 Returns: - String decodificada em utf-8 Type string × Search results Close "},"add-tools-vault-api.vaultsignature.html":{"id":"add-tools-vault-api.vaultsignature.html","title":"Namespace: vaultsignature","body":" Addson Namespaces add-tools-browser-apiadd-tools-drive-apiadd-tools-http-apiadd-tools-mail-apiadd-tools-ocr-apiadd-tools-platform-apiadd-tools-vault-api Classes Settings Namespace: vaultsignature add-tools-vault-api. vaultsignature O Serviço de vaultsignature faz ... Properties: Name Type Description name string Nome do serviço mixins array Mixins do serviço metadata object Metadados do serviço settings object Configurações do serviço actions object Ações do serviço sign methods object Métodos do serviço validateInputParams(), addEncrypt(), addDecrypt(), encodeBase64(), decodeBase64() Source: add-tools-vault-api/src/services/vaultsignature.service.js, line 5 To Do: @property {number} version - Versão do serviço Members actions Actions do serviço Properties: Name Type Description sign object Action sign action sign Source: add-tools-vault-api/src/services/vaultsignature.service.js, line 32 Actions sign Ação sign A ação sign faz ... Properties: Name Type Description description string Descrição da action params object Parâmetros da action Properties Name Type Argument Description secretAlias string Alias do certificado messageContent string Conteúdo da mensagem messageContentFormat string &lt;optional&gt; Formato do conteúdo da mensagem signatureModel string Modelo de assinatura tag string &lt;optional&gt; Tag uri string &lt;optional&gt; URI emptyUri boolean &lt;optional&gt; URI vazia transforms array &lt;optional&gt; Transformações canonicalizationAlgorithm string &lt;optional&gt; Algoritmo de canonicalização location string &lt;optional&gt; Localização locationTag string &lt;optional&gt; Tag de localização permissions array Permissões da action Source: add-tools-vault-api/src/services/vaultsignature.service.js, line 33 To Do: @property {string} rest - Rota da action Methods validateInputParams(params, nodeID) Método para ... O method validateInputParams() ... Parameters: Name Type Description params object Parâmetros da action nodeID object ID do nó Source: add-tools-vault-api/src/services/vaultsignature.service.js, line 195 Returns: - Se passou por todas validacoes retorna 'undefined' Type undefined addEncrypt(e) Método para ... O method addEncrypt() ... Parameters: Name Type Description e string Parâmetros da action Source: add-tools-vault-api/src/services/vaultsignature.service.js, line 292 addDecrypt(r) Método para ... O method addDecrypt() ... Parameters: Name Type Description r string Parâmetros da action Source: add-tools-vault-api/src/services/vaultsignature.service.js, line 327 Returns: - Retorna o secret descriptografado Type string encodeBase64(str) Método para ... O method encodeBase64() ... Parameters: Name Type Description str string Parâmetros da action Source: add-tools-vault-api/src/services/vaultsignature.service.js, line 349 Returns: - Retorna o secret criptografado em base64 Type string decodeBase64(str) Método para ... O method decodeBase64() ... Parameters: Name Type Description str string Parâmetros da action Source: add-tools-vault-api/src/services/vaultsignature.service.js, line 360 Returns: - Retorna o secret descriptografado em utf-8 Type string × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
